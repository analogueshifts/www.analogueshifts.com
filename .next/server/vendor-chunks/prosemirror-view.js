"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-view";
exports.ids = ["vendor-chunks/prosemirror-view"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/prosemirror-view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* binding */ Decoration),\n/* harmony export */   DecorationSet: () => (/* binding */ DecorationSet),\n/* harmony export */   EditorView: () => (/* binding */ EditorView),\n/* harmony export */   __endComposition: () => (/* binding */ __endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* binding */ __parseFromClipboard),\n/* harmony export */   __serializeForClipboard: () => (/* binding */ __serializeForClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n\n\n\nconst domIndex = function(node) {\n    for(var index = 0;; index++){\n        node = node.previousSibling;\n        if (!node) return index;\n    }\n};\nconst parentNode = function(node) {\n    let parent = node.assignedSlot || node.parentNode;\n    return parent && parent.nodeType == 11 ? parent.host : parent;\n};\nlet reusedRange = null;\n// Note that this will always return the same range, because DOM range\n// objects are every expensive, and keep slowing down subsequent DOM\n// updates, for some reason.\nconst textRange = function(node, from, to) {\n    let range = reusedRange || (reusedRange = document.createRange());\n    range.setEnd(node, to == null ? node.nodeValue.length : to);\n    range.setStart(node, from || 0);\n    return range;\n};\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nconst isEquivalentPosition = function(node, off, targetNode, targetOff) {\n    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));\n};\nconst atomElements = /^(img|br|input|textarea|hr)$/i;\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for(;;){\n        if (node == targetNode && off == targetOff) return true;\n        if (off == (dir < 0 ? 0 : nodeSize(node))) {\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == \"false\") return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        } else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (node.contentEditable == \"false\") return false;\n            off = dir < 0 ? nodeSize(node) : 0;\n        } else {\n            return false;\n        }\n    }\n}\nfunction nodeSize(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction isOnEdge(node, offset, parent) {\n    for(let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;){\n        if (node == parent) return true;\n        let index = domIndex(node);\n        node = node.parentNode;\n        if (!node) return false;\n        atStart = atStart && index == 0;\n        atEnd = atEnd && index == nodeSize(node);\n    }\n}\nfunction hasBlockDesc(dom) {\n    let desc;\n    for(let cur = dom; cur; cur = cur.parentNode)if (desc = cur.pmViewDesc) break;\n    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);\n}\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nconst selectionCollapsed = function(domSel) {\n    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);\n};\nfunction keyEvent(keyCode, key) {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"keydown\", true, true);\n    event.keyCode = keyCode;\n    event.key = event.code = key;\n    return event;\n}\nfunction deepActiveElement(doc) {\n    let elt = doc.activeElement;\n    while(elt && elt.shadowRoot)elt = elt.shadowRoot.activeElement;\n    return elt;\n}\nfunction caretFromPoint(doc, x, y) {\n    if (doc.caretPositionFromPoint) {\n        try {\n            let pos = doc.caretPositionFromPoint(x, y);\n            if (pos) return {\n                node: pos.offsetNode,\n                offset: pos.offset\n            };\n        } catch (_) {}\n    }\n    if (doc.caretRangeFromPoint) {\n        let range = doc.caretRangeFromPoint(x, y);\n        if (range) return {\n            node: range.startContainer,\n            offset: range.startOffset\n        };\n    }\n}\nconst nav = typeof navigator != \"undefined\" ? navigator : null;\nconst doc = typeof document != \"undefined\" ? document : null;\nconst agent = nav && nav.userAgent || \"\";\nconst ie_edge = /Edge\\/(\\d+)/.exec(agent);\nconst ie_upto10 = /MSIE \\d/.exec(agent);\nconst ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(agent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;\nconst gecko = !ie && /gecko\\/(\\d+)/i.test(agent);\ngecko && +(/Firefox\\/(\\d+)/.exec(agent) || [\n    0,\n    0\n])[1];\nconst _chrome = !ie && /Chrome\\/(\\d+)/.exec(agent);\nconst chrome = !!_chrome;\nconst chrome_version = _chrome ? +_chrome[1] : 0;\nconst safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);\n// Is true for both iOS and iPadOS for convenience\nconst ios = safari && (/Mobile\\/\\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);\nconst mac = ios || (nav ? /Mac/.test(nav.platform) : false);\nconst windows = nav ? /Win/.test(nav.platform) : false;\nconst android = /Android \\d/.test(agent);\nconst webkit = !!doc && \"webkitFontSmoothing\" in doc.documentElement.style;\nconst webkit_version = webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [\n    0,\n    0\n])[1] : 0;\nfunction windowRect(doc) {\n    return {\n        left: 0,\n        right: doc.documentElement.clientWidth,\n        top: 0,\n        bottom: doc.documentElement.clientHeight\n    };\n}\nfunction getSide(value, side) {\n    return typeof value == \"number\" ? value : value[side];\n}\nfunction clientRect(node) {\n    let rect = node.getBoundingClientRect();\n    // Adjust for elements with style \"transform: scale()\"\n    let scaleX = rect.width / node.offsetWidth || 1;\n    let scaleY = rect.height / node.offsetHeight || 1;\n    // Make sure scrollbar width isn't included in the rectangle\n    return {\n        left: rect.left,\n        right: rect.left + node.clientWidth * scaleX,\n        top: rect.top,\n        bottom: rect.top + node.clientHeight * scaleY\n    };\n}\nfunction scrollRectIntoView(view, rect, startDOM) {\n    let scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5;\n    let doc = view.dom.ownerDocument;\n    for(let parent = startDOM || view.dom;; parent = parentNode(parent)){\n        if (!parent) break;\n        if (parent.nodeType != 1) continue;\n        let elt = parent;\n        let atTop = elt == doc.body;\n        let bounding = atTop ? windowRect(doc) : clientRect(elt);\n        let moveX = 0, moveY = 0;\n        if (rect.top < bounding.top + getSide(scrollThreshold, \"top\")) moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"));\n        else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\")) moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, \"top\") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\");\n        if (rect.left < bounding.left + getSide(scrollThreshold, \"left\")) moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"));\n        else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\")) moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\");\n        if (moveX || moveY) {\n            if (atTop) {\n                doc.defaultView.scrollBy(moveX, moveY);\n            } else {\n                let startX = elt.scrollLeft, startY = elt.scrollTop;\n                if (moveY) elt.scrollTop += moveY;\n                if (moveX) elt.scrollLeft += moveX;\n                let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;\n                rect = {\n                    left: rect.left - dX,\n                    top: rect.top - dY,\n                    right: rect.right - dX,\n                    bottom: rect.bottom - dY\n                };\n            }\n        }\n        if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position)) break;\n    }\n}\n// Store the scroll position of the editor's parent nodes, along with\n// the top position of an element near the top of the editor, which\n// will be used to make sure the visible viewport remains stable even\n// when the size of the content above changes.\nfunction storeScrollPos(view) {\n    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n    let refDOM, refTop;\n    for(let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5){\n        let dom = view.root.elementFromPoint(x, y);\n        if (!dom || dom == view.dom || !view.dom.contains(dom)) continue;\n        let localRect = dom.getBoundingClientRect();\n        if (localRect.top >= startY - 20) {\n            refDOM = dom;\n            refTop = localRect.top;\n            break;\n        }\n    }\n    return {\n        refDOM: refDOM,\n        refTop: refTop,\n        stack: scrollStack(view.dom)\n    };\n}\nfunction scrollStack(dom) {\n    let stack = [], doc = dom.ownerDocument;\n    for(let cur = dom; cur; cur = parentNode(cur)){\n        stack.push({\n            dom: cur,\n            top: cur.scrollTop,\n            left: cur.scrollLeft\n        });\n        if (dom == doc) break;\n    }\n    return stack;\n}\n// Reset the scroll position of the editor's parent nodes to that what\n// it was before, when storeScrollPos was called.\nfunction resetScrollPos({ refDOM, refTop, stack }) {\n    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n}\nfunction restoreScrollStack(stack, dTop) {\n    for(let i = 0; i < stack.length; i++){\n        let { dom, top, left } = stack[i];\n        if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop;\n        if (dom.scrollLeft != left) dom.scrollLeft = left;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive) return dom.setActive(); // in IE\n    if (preventScrollSupported) return dom.focus(preventScrollSupported);\n    let stored = scrollStack(dom);\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll () {\n            preventScrollSupported = {\n                preventScroll: true\n            };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        restoreScrollStack(stored, 0);\n    }\n}\nfunction findOffsetInNode(node, coords) {\n    let closest, dxClosest = 2e8, coordsClosest, offset = 0;\n    let rowBot = coords.top, rowTop = coords.top;\n    let firstBelow, coordsBelow;\n    for(let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++){\n        let rects;\n        if (child.nodeType == 1) rects = child.getClientRects();\n        else if (child.nodeType == 3) rects = textRange(child).getClientRects();\n        else continue;\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (rect.top <= rowBot && rect.bottom >= rowTop) {\n                rowBot = Math.max(rect.bottom, rowBot);\n                rowTop = Math.min(rect.top, rowTop);\n                let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;\n                if (dx < dxClosest) {\n                    closest = child;\n                    dxClosest = dx;\n                    coordsClosest = dx && closest.nodeType == 3 ? {\n                        left: rect.right < coords.left ? rect.right : rect.left,\n                        top: coords.top\n                    } : coords;\n                    if (child.nodeType == 1 && dx) offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n                    continue;\n                }\n            } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {\n                firstBelow = child;\n                coordsBelow = {\n                    left: Math.max(rect.left, Math.min(rect.right, coords.left)),\n                    top: rect.top\n                };\n            }\n            if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) offset = childIndex + 1;\n        }\n    }\n    if (!closest && firstBelow) {\n        closest = firstBelow;\n        coordsClosest = coordsBelow;\n        dxClosest = 0;\n    }\n    if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest);\n    if (!closest || dxClosest && closest.nodeType == 1) return {\n        node,\n        offset\n    };\n    return findOffsetInNode(closest, coordsClosest);\n}\nfunction findOffsetInText(node, coords) {\n    let len = node.nodeValue.length;\n    let range = document.createRange();\n    for(let i = 0; i < len; i++){\n        range.setEnd(node, i + 1);\n        range.setStart(node, i);\n        let rect = singleRect(range, 1);\n        if (rect.top == rect.bottom) continue;\n        if (inRect(coords, rect)) return {\n            node,\n            offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)\n        };\n    }\n    return {\n        node,\n        offset: 0\n    };\n}\nfunction inRect(coords, rect) {\n    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;\n}\nfunction targetKludge(dom, coords) {\n    let parent = dom.parentNode;\n    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) return parent;\n    return dom;\n}\nfunction posFromElement(view, elt, coords) {\n    let { node, offset } = findOffsetInNode(elt, coords), bias = -1;\n    if (node.nodeType == 1 && !node.firstChild) {\n        let rect = node.getBoundingClientRect();\n        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n    }\n    return view.docView.posFromDOM(node, offset, bias);\n}\nfunction posFromCaret(view, node, offset, coords) {\n    // Browser (in caretPosition/RangeFromPoint) will agressively\n    // normalize towards nearby inline nodes. Since we are interested in\n    // positions between block nodes too, we first walk up the hierarchy\n    // of nodes to see if there are block nodes that the coordinates\n    // fall outside of. If so, we take the position before/after that\n    // block. If not, we call `posFromDOM` on the raw node/offset.\n    let outsideBlock = -1;\n    for(let cur = node, sawBlock = false;;){\n        if (cur == view.dom) break;\n        let desc = view.docView.nearestDesc(cur, true);\n        if (!desc) return null;\n        if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent && !sawBlock || !desc.contentDOM)) {\n            let rect = desc.dom.getBoundingClientRect();\n            if (desc.node.isBlock && desc.parent && !sawBlock) {\n                sawBlock = true;\n                if (rect.left > coords.left || rect.top > coords.top) outsideBlock = desc.posBefore;\n                else if (rect.right < coords.left || rect.bottom < coords.top) outsideBlock = desc.posAfter;\n            }\n            if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {\n                // If we are inside a leaf, return the side of the leaf closer to the coords\n                let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;\n                return before ? desc.posBefore : desc.posAfter;\n            }\n        }\n        cur = desc.dom.parentNode;\n    }\n    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);\n}\nfunction elementFromPoint(element, coords, box) {\n    let len = element.childNodes.length;\n    if (len && box.top < box.bottom) {\n        for(let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;){\n            let child = element.childNodes[i];\n            if (child.nodeType == 1) {\n                let rects = child.getClientRects();\n                for(let j = 0; j < rects.length; j++){\n                    let rect = rects[j];\n                    if (inRect(coords, rect)) return elementFromPoint(child, coords, rect);\n                }\n            }\n            if ((i = (i + 1) % len) == startI) break;\n        }\n    }\n    return element;\n}\n// Given an x,y position on the editor, get the position in the document.\nfunction posAtCoords(view, coords) {\n    let doc = view.dom.ownerDocument, node, offset = 0;\n    let caret = caretFromPoint(doc, coords.left, coords.top);\n    if (caret) ({ node, offset } = caret);\n    let elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top);\n    let pos;\n    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n        let box = view.dom.getBoundingClientRect();\n        if (!inRect(coords, box)) return null;\n        elt = elementFromPoint(view.dom, coords, box);\n        if (!elt) return null;\n    }\n    // Safari's caretRangeFromPoint returns nonsense when on a draggable element\n    if (safari) {\n        for(let p = elt; node && p; p = parentNode(p))if (p.draggable) node = undefined;\n    }\n    elt = targetKludge(elt, coords);\n    if (node) {\n        if (gecko && node.nodeType == 1) {\n            // Firefox will sometimes return offsets into <input> nodes, which\n            // have no actual children, from caretPositionFromPoint (#953)\n            offset = Math.min(offset, node.childNodes.length);\n            // It'll also move the returned position before image nodes,\n            // even if those are behind it.\n            if (offset < node.childNodes.length) {\n                let next = node.childNodes[offset], box;\n                if (next.nodeName == \"IMG\" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top) offset++;\n            }\n        }\n        let prev;\n        // When clicking above the right side of an uneditable node, Chrome will report a cursor position after that node.\n        if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == \"false\" && prev.getBoundingClientRect().top >= coords.top) offset--;\n        // Suspiciously specific kludge to work around caret*FromPoint\n        // never returning a position at the end of the document\n        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom) pos = view.state.doc.content.size;\n        else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\") pos = posFromCaret(view, node, offset, coords);\n    }\n    if (pos == null) pos = posFromElement(view, elt, coords);\n    let desc = view.docView.nearestDesc(elt, true);\n    return {\n        pos,\n        inside: desc ? desc.posAtStart - desc.border : -1\n    };\n}\nfunction nonZero(rect) {\n    return rect.top < rect.bottom || rect.left < rect.right;\n}\nfunction singleRect(target, bias) {\n    let rects = target.getClientRects();\n    if (rects.length) {\n        let first = rects[bias < 0 ? 0 : rects.length - 1];\n        if (nonZero(first)) return first;\n    }\n    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();\n}\nconst BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nfunction coordsAtPos(view, pos, side) {\n    let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);\n    let supportEmptyRange = webkit || gecko;\n    if (node.nodeType == 3) {\n        // These browsers support querying empty text ranges. Prefer that in\n        // bidi context or when at the end of a node.\n        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n            let rect = singleRect(textRange(node, offset, offset), side);\n            // Firefox returns bad results (the position before the space)\n            // when querying a position directly after line-broken\n            // whitespace. Detect this situation and and kludge around it\n            if (gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n                let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n                if (rectBefore.top == rect.top) {\n                    let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n                    if (rectAfter.top != rect.top) return flattenV(rectAfter, rectAfter.left < rectBefore.left);\n                }\n            }\n            return rect;\n        } else {\n            let from = offset, to = offset, takeSide = side < 0 ? 1 : -1;\n            if (side < 0 && !offset) {\n                to++;\n                takeSide = -1;\n            } else if (side >= 0 && offset == node.nodeValue.length) {\n                from--;\n                takeSide = 1;\n            } else if (side < 0) {\n                from--;\n            } else {\n                to++;\n            }\n            return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);\n        }\n    }\n    let $dom = view.state.doc.resolve(pos - (atom || 0));\n    // Return a horizontal line in block context\n    if (!$dom.parent.inlineContent) {\n        if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n            let before = node.childNodes[offset - 1];\n            if (before.nodeType == 1) return flattenH(before.getBoundingClientRect(), false);\n        }\n        if (atom == null && offset < nodeSize(node)) {\n            let after = node.childNodes[offset];\n            if (after.nodeType == 1) return flattenH(after.getBoundingClientRect(), true);\n        }\n        return flattenH(node.getBoundingClientRect(), side >= 0);\n    }\n    // Inline, not in text node (this is not Bidi-safe)\n    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n        let before = node.childNodes[offset - 1];\n        let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != \"BR\" || !before.nextSibling) ? before : null;\n        if (target) return flattenV(singleRect(target, 1), false);\n    }\n    if (atom == null && offset < nodeSize(node)) {\n        let after = node.childNodes[offset];\n        while(after.pmViewDesc && after.pmViewDesc.ignoreForCoords)after = after.nextSibling;\n        let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;\n        if (target) return flattenV(singleRect(target, -1), true);\n    }\n    // All else failed, just try to get a rectangle for the target node\n    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);\n}\nfunction flattenV(rect, left) {\n    if (rect.width == 0) return rect;\n    let x = left ? rect.left : rect.right;\n    return {\n        top: rect.top,\n        bottom: rect.bottom,\n        left: x,\n        right: x\n    };\n}\nfunction flattenH(rect, top) {\n    if (rect.height == 0) return rect;\n    let y = top ? rect.top : rect.bottom;\n    return {\n        top: y,\n        bottom: y,\n        left: rect.left,\n        right: rect.right\n    };\n}\nfunction withFlushedState(view, state, f) {\n    let viewState = view.state, active = view.root.activeElement;\n    if (viewState != state) view.updateState(state);\n    if (active != view.dom) view.focus();\n    try {\n        return f();\n    } finally{\n        if (viewState != state) view.updateState(viewState);\n        if (active != view.dom && active) active.focus();\n    }\n}\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n    let sel = state.selection;\n    let $pos = dir == \"up\" ? sel.$from : sel.$to;\n    return withFlushedState(view, state, ()=>{\n        let { node: dom } = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1);\n        for(;;){\n            let nearest = view.docView.nearestDesc(dom, true);\n            if (!nearest) break;\n            if (nearest.node.isBlock) {\n                dom = nearest.contentDOM || nearest.dom;\n                break;\n            }\n            dom = nearest.dom.parentNode;\n        }\n        let coords = coordsAtPos(view, $pos.pos, 1);\n        for(let child = dom.firstChild; child; child = child.nextSibling){\n            let boxes;\n            if (child.nodeType == 1) boxes = child.getClientRects();\n            else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects();\n            else continue;\n            for(let i = 0; i < boxes.length; i++){\n                let box = boxes[i];\n                if (box.bottom > box.top + 1 && (dir == \"up\" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) return false;\n            }\n        }\n        return true;\n    });\n}\nconst maybeRTL = /[\\u0590-\\u08ac]/;\nfunction endOfTextblockHorizontal(view, state, dir) {\n    let { $head } = state.selection;\n    if (!$head.parent.isTextblock) return false;\n    let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n    let sel = view.domSelection();\n    // If the textblock is all LTR, or the browser doesn't support\n    // Selection.modify (Edge), fall back to a primitive approach\n    if (!maybeRTL.test($head.parent.textContent) || !sel.modify) return dir == \"left\" || dir == \"backward\" ? atStart : atEnd;\n    return withFlushedState(view, state, ()=>{\n        // This is a huge hack, but appears to be the best we can\n        // currently do: use `Selection.modify` to move the selection by\n        // one character, and see if that moves the cursor out of the\n        // textblock (or doesn't move it at all, when at the start/end of\n        // the document).\n        let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();\n        let oldBidiLevel = sel.caretBidiLevel // Only for Firefox\n        ;\n        sel.modify(\"move\", dir, \"character\");\n        let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n        let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();\n        let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;\n        // Restore the previous selection\n        try {\n            sel.collapse(anchorNode, anchorOffset);\n            if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend) sel.extend(oldNode, oldOff);\n        } catch (_) {}\n        if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel;\n        return result;\n    });\n}\nlet cachedState = null;\nlet cachedDir = null;\nlet cachedResult = false;\nfunction endOfTextblock(view, state, dir) {\n    if (cachedState == state && cachedDir == dir) return cachedResult;\n    cachedState = state;\n    cachedDir = dir;\n    return cachedResult = dir == \"up\" || dir == \"down\" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);\n}\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor's content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\nconst NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nclass ViewDesc {\n    constructor(parent, children, dom, // This is the node that holds the child views. It may be null for\n    // descs that don't have children.\n    contentDOM){\n        this.parent = parent;\n        this.children = children;\n        this.dom = dom;\n        this.contentDOM = contentDOM;\n        this.dirty = NOT_DIRTY;\n        // An expando property on the DOM node provides a link back to its\n        // description.\n        dom.pmViewDesc = this;\n    }\n    // Used to check whether a given description corresponds to a\n    // widget/mark/node.\n    matchesWidget(widget) {\n        return false;\n    }\n    matchesMark(mark) {\n        return false;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n        return false;\n    }\n    matchesHack(nodeName) {\n        return false;\n    }\n    // When parsing in-editor content (in domchange.js), we allow\n    // descriptions to determine the parse rules that should be used to\n    // parse them.\n    parseRule() {\n        return null;\n    }\n    // Used by the editor's event handler to ignore events that come\n    // from certain descs.\n    stopEvent(event) {\n        return false;\n    }\n    // The size of the content represented by this desc.\n    get size() {\n        let size = 0;\n        for(let i = 0; i < this.children.length; i++)size += this.children[i].size;\n        return size;\n    }\n    // For block nodes, this represents the space taken up by their\n    // start/end tokens.\n    get border() {\n        return 0;\n    }\n    destroy() {\n        this.parent = undefined;\n        if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = undefined;\n        for(let i = 0; i < this.children.length; i++)this.children[i].destroy();\n    }\n    posBeforeChild(child) {\n        for(let i = 0, pos = this.posAtStart;; i++){\n            let cur = this.children[i];\n            if (cur == child) return pos;\n            pos += cur.size;\n        }\n    }\n    get posBefore() {\n        return this.parent.posBeforeChild(this);\n    }\n    get posAtStart() {\n        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;\n    }\n    get posAfter() {\n        return this.posBefore + this.size;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.size - 2 * this.border;\n    }\n    localPosFromDOM(dom, offset, bias) {\n        // If the DOM position is in the content, use the child desc after\n        // it to figure out a position.\n        if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n            if (bias < 0) {\n                let domBefore, desc;\n                if (dom == this.contentDOM) {\n                    domBefore = dom.childNodes[offset - 1];\n                } else {\n                    while(dom.parentNode != this.contentDOM)dom = dom.parentNode;\n                    domBefore = dom.previousSibling;\n                }\n                while(domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))domBefore = domBefore.previousSibling;\n                return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;\n            } else {\n                let domAfter, desc;\n                if (dom == this.contentDOM) {\n                    domAfter = dom.childNodes[offset];\n                } else {\n                    while(dom.parentNode != this.contentDOM)dom = dom.parentNode;\n                    domAfter = dom.nextSibling;\n                }\n                while(domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))domAfter = domAfter.nextSibling;\n                return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;\n            }\n        }\n        // Otherwise, use various heuristics, falling back on the bias\n        // parameter, to determine whether to return the position at the\n        // start or at the end of this view desc.\n        let atEnd;\n        if (dom == this.dom && this.contentDOM) {\n            atEnd = offset > domIndex(this.contentDOM);\n        } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n            atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n        } else if (this.dom.firstChild) {\n            if (offset == 0) for(let search = dom;; search = search.parentNode){\n                if (search == this.dom) {\n                    atEnd = false;\n                    break;\n                }\n                if (search.previousSibling) break;\n            }\n            if (atEnd == null && offset == dom.childNodes.length) for(let search = dom;; search = search.parentNode){\n                if (search == this.dom) {\n                    atEnd = true;\n                    break;\n                }\n                if (search.nextSibling) break;\n            }\n        }\n        return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;\n    }\n    nearestDesc(dom, onlyNodes = false) {\n        for(let first = true, cur = dom; cur; cur = cur.parentNode){\n            let desc = this.getDesc(cur), nodeDOM;\n            if (desc && (!onlyNodes || desc.node)) {\n                // If dom is outside of this desc's nodeDOM, don't count it.\n                if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom)) first = false;\n                else return desc;\n            }\n        }\n    }\n    getDesc(dom) {\n        let desc = dom.pmViewDesc;\n        for(let cur = desc; cur; cur = cur.parent)if (cur == this) return desc;\n    }\n    posFromDOM(dom, offset, bias) {\n        for(let scan = dom; scan; scan = scan.parentNode){\n            let desc = this.getDesc(scan);\n            if (desc) return desc.localPosFromDOM(dom, offset, bias);\n        }\n        return -1;\n    }\n    // Find the desc for the node after the given pos, if any. (When a\n    // parent node overrode rendering, there might not be one.)\n    descAt(pos) {\n        for(let i = 0, offset = 0; i < this.children.length; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (offset == pos && end != offset) {\n                while(!child.border && child.children.length)child = child.children[0];\n                return child;\n            }\n            if (pos < end) return child.descAt(pos - offset - child.border);\n            offset = end;\n        }\n    }\n    domFromPos(pos, side) {\n        if (!this.contentDOM) return {\n            node: this.dom,\n            offset: 0,\n            atom: pos + 1\n        };\n        // First find the position in the child array\n        let i = 0, offset = 0;\n        for(let curPos = 0; i < this.children.length; i++){\n            let child = this.children[i], end = curPos + child.size;\n            if (end > pos || child instanceof TrailingHackViewDesc) {\n                offset = pos - curPos;\n                break;\n            }\n            curPos = end;\n        }\n        // If this points into the middle of a child, call through\n        if (offset) return this.children[i].domFromPos(offset - this.children[i].border, side);\n        // Go back if there were any zero-length widgets with side >= 0 before this point\n        for(let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--){}\n        // Scan towards the first useable node\n        if (side <= 0) {\n            let prev, enter = true;\n            for(;; i--, enter = false){\n                prev = i ? this.children[i - 1] : null;\n                if (!prev || prev.dom.parentNode == this.contentDOM) break;\n            }\n            if (prev && side && enter && !prev.border && !prev.domAtom) return prev.domFromPos(prev.size, side);\n            return {\n                node: this.contentDOM,\n                offset: prev ? domIndex(prev.dom) + 1 : 0\n            };\n        } else {\n            let next, enter = true;\n            for(;; i++, enter = false){\n                next = i < this.children.length ? this.children[i] : null;\n                if (!next || next.dom.parentNode == this.contentDOM) break;\n            }\n            if (next && enter && !next.border && !next.domAtom) return next.domFromPos(0, side);\n            return {\n                node: this.contentDOM,\n                offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length\n            };\n        }\n    }\n    // Used to find a DOM range in a single parent for a given changed\n    // range.\n    parseRange(from, to, base = 0) {\n        if (this.children.length == 0) return {\n            node: this.contentDOM,\n            from,\n            to,\n            fromOffset: 0,\n            toOffset: this.contentDOM.childNodes.length\n        };\n        let fromOffset = -1, toOffset = -1;\n        for(let offset = base, i = 0;; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (fromOffset == -1 && from <= end) {\n                let childBase = offset + child.border;\n                // FIXME maybe descend mark views to parse a narrower range?\n                if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM)) return child.parseRange(from, to, childBase);\n                from = offset;\n                for(let j = i; j > 0; j--){\n                    let prev = this.children[j - 1];\n                    if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n                        fromOffset = domIndex(prev.dom) + 1;\n                        break;\n                    }\n                    from -= prev.size;\n                }\n                if (fromOffset == -1) fromOffset = 0;\n            }\n            if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n                to = end;\n                for(let j = i + 1; j < this.children.length; j++){\n                    let next = this.children[j];\n                    if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n                        toOffset = domIndex(next.dom);\n                        break;\n                    }\n                    to += next.size;\n                }\n                if (toOffset == -1) toOffset = this.contentDOM.childNodes.length;\n                break;\n            }\n            offset = end;\n        }\n        return {\n            node: this.contentDOM,\n            from,\n            to,\n            fromOffset,\n            toOffset\n        };\n    }\n    emptyChildAt(side) {\n        if (this.border || !this.contentDOM || !this.children.length) return false;\n        let child = this.children[side < 0 ? 0 : this.children.length - 1];\n        return child.size == 0 || child.emptyChildAt(side);\n    }\n    domAfterPos(pos) {\n        let { node, offset } = this.domFromPos(pos, 0);\n        if (node.nodeType != 1 || offset == node.childNodes.length) throw new RangeError(\"No node after pos \" + pos);\n        return node.childNodes[offset];\n    }\n    // View descs are responsible for setting any selection that falls\n    // entirely inside of them, so that custom implementations can do\n    // custom things with the selection. Note that this falls apart when\n    // a selection starts in such a node and ends in another, in which\n    // case we just use whatever domFromPos produces as a best effort.\n    setSelection(anchor, head, root, force = false) {\n        // If the selection falls entirely in a child, give it to that child\n        let from = Math.min(anchor, head), to = Math.max(anchor, head);\n        for(let i = 0, offset = 0; i < this.children.length; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (from > offset && to < end) return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);\n            offset = end;\n        }\n        let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n        let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n        let domSel = root.getSelection();\n        let brKludge = false;\n        // On Firefox, using Selection.collapse to put the cursor after a\n        // BR node for some reason doesn't always work (#1073). On Safari,\n        // the cursor sometimes inexplicable visually lags behind its\n        // reported position in such situations (#1092).\n        if ((gecko || safari) && anchor == head) {\n            let { node, offset } = anchorDOM;\n            if (node.nodeType == 3) {\n                brKludge = !!(offset && node.nodeValue[offset - 1] == \"\\n\");\n                // Issue #1128\n                if (brKludge && offset == node.nodeValue.length) {\n                    for(let scan = node, after; scan; scan = scan.parentNode){\n                        if (after = scan.nextSibling) {\n                            if (after.nodeName == \"BR\") anchorDOM = headDOM = {\n                                node: after.parentNode,\n                                offset: domIndex(after) + 1\n                            };\n                            break;\n                        }\n                        let desc = scan.pmViewDesc;\n                        if (desc && desc.node && desc.node.isBlock) break;\n                    }\n                }\n            } else {\n                let prev = node.childNodes[offset - 1];\n                brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\");\n            }\n        }\n        // Firefox can act strangely when the selection is in front of an\n        // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536\n        if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {\n            let after = domSel.focusNode.childNodes[domSel.focusOffset];\n            if (after && after.contentEditable == \"false\") force = true;\n        }\n        if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) return;\n        // Selection.extend can be used to create an 'inverted' selection\n        // (one where the focus is before the anchor), but not all\n        // browsers support it yet.\n        let domSelExtended = false;\n        if ((domSel.extend || anchor == head) && !brKludge) {\n            domSel.collapse(anchorDOM.node, anchorDOM.offset);\n            try {\n                if (anchor != head) domSel.extend(headDOM.node, headDOM.offset);\n                domSelExtended = true;\n            } catch (_) {\n            // In some cases with Chrome the selection is empty after calling\n            // collapse, even when it should be valid. This appears to be a bug, but\n            // it is difficult to isolate. If this happens fallback to the old path\n            // without using extend.\n            // Similarly, this could crash on Safari if the editor is hidden, and\n            // there was no selection.\n            }\n        }\n        if (!domSelExtended) {\n            if (anchor > head) {\n                let tmp = anchorDOM;\n                anchorDOM = headDOM;\n                headDOM = tmp;\n            }\n            let range = document.createRange();\n            range.setEnd(headDOM.node, headDOM.offset);\n            range.setStart(anchorDOM.node, anchorDOM.offset);\n            domSel.removeAllRanges();\n            domSel.addRange(range);\n        }\n    }\n    ignoreMutation(mutation) {\n        return !this.contentDOM && mutation.type != \"selection\";\n    }\n    get contentLost() {\n        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);\n    }\n    // Remove a subtree of the element tree that has been touched\n    // by a DOM change, so that the next update will redraw it.\n    markDirty(from, to) {\n        for(let offset = 0, i = 0; i < this.children.length; i++){\n            let child = this.children[i], end = offset + child.size;\n            if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n                let startInside = offset + child.border, endInside = end - child.border;\n                if (from >= startInside && to <= endInside) {\n                    this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n                    if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM)) child.dirty = NODE_DIRTY;\n                    else child.markDirty(from - startInside, to - startInside);\n                    return;\n                } else {\n                    child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;\n                }\n            }\n            offset = end;\n        }\n        this.dirty = CONTENT_DIRTY;\n    }\n    markParentsDirty() {\n        let level = 1;\n        for(let node = this.parent; node; node = node.parent, level++){\n            let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n            if (node.dirty < dirty) node.dirty = dirty;\n        }\n    }\n    get domAtom() {\n        return false;\n    }\n    get ignoreForCoords() {\n        return false;\n    }\n}\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nclass WidgetViewDesc extends ViewDesc {\n    constructor(parent, widget, view, pos){\n        let self, dom = widget.type.toDOM;\n        if (typeof dom == \"function\") dom = dom(view, ()=>{\n            if (!self) return pos;\n            if (self.parent) return self.parent.posBeforeChild(self);\n        });\n        if (!widget.type.spec.raw) {\n            if (dom.nodeType != 1) {\n                let wrap = document.createElement(\"span\");\n                wrap.appendChild(dom);\n                dom = wrap;\n            }\n            dom.contentEditable = \"false\";\n            dom.classList.add(\"ProseMirror-widget\");\n        }\n        super(parent, [], dom, null);\n        this.widget = widget;\n        this.widget = widget;\n        self = this;\n    }\n    matchesWidget(widget) {\n        return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);\n    }\n    parseRule() {\n        return {\n            ignore: true\n        };\n    }\n    stopEvent(event) {\n        let stop = this.widget.spec.stopEvent;\n        return stop ? stop(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"selection\" || this.widget.spec.ignoreSelection;\n    }\n    destroy() {\n        this.widget.type.destroy(this.dom);\n        super.destroy();\n    }\n    get domAtom() {\n        return true;\n    }\n    get side() {\n        return this.widget.type.side;\n    }\n}\nclass CompositionViewDesc extends ViewDesc {\n    constructor(parent, dom, textDOM, text){\n        super(parent, [], dom, null);\n        this.textDOM = textDOM;\n        this.text = text;\n    }\n    get size() {\n        return this.text.length;\n    }\n    localPosFromDOM(dom, offset) {\n        if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0);\n        return this.posAtStart + offset;\n    }\n    domFromPos(pos) {\n        return {\n            node: this.textDOM,\n            offset: pos\n        };\n    }\n    ignoreMutation(mut) {\n        return mut.type === \"characterData\" && mut.target.nodeValue == mut.oldValue;\n    }\n}\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nclass MarkViewDesc extends ViewDesc {\n    constructor(parent, mark, dom, contentDOM){\n        super(parent, [], dom, contentDOM);\n        this.mark = mark;\n    }\n    static create(parent, mark, inline, view) {\n        let custom = view.nodeViews[mark.type.name];\n        let spec = custom && custom(mark, view, inline);\n        if (!spec || !spec.dom) spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));\n        return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);\n    }\n    parseRule() {\n        if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) return null;\n        return {\n            mark: this.mark.type.name,\n            attrs: this.mark.attrs,\n            contentElement: this.contentDOM\n        };\n    }\n    matchesMark(mark) {\n        return this.dirty != NODE_DIRTY && this.mark.eq(mark);\n    }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        // Move dirty info to nearest node view\n        if (this.dirty != NOT_DIRTY) {\n            let parent = this.parent;\n            while(!parent.node)parent = parent.parent;\n            if (parent.dirty < this.dirty) parent.dirty = this.dirty;\n            this.dirty = NOT_DIRTY;\n        }\n    }\n    slice(from, to, view) {\n        let copy = MarkViewDesc.create(this.parent, this.mark, true, view);\n        let nodes = this.children, size = this.size;\n        if (to < size) nodes = replaceNodes(nodes, to, size, view);\n        if (from > 0) nodes = replaceNodes(nodes, 0, from, view);\n        for(let i = 0; i < nodes.length; i++)nodes[i].parent = copy;\n        copy.children = nodes;\n        return copy;\n    }\n}\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nclass NodeViewDesc extends ViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos){\n        super(parent, [], dom, contentDOM);\n        this.node = node;\n        this.outerDeco = outerDeco;\n        this.innerDeco = innerDeco;\n        this.nodeDOM = nodeDOM;\n    }\n    // By default, a node is rendered using the `toDOM` method from the\n    // node type spec. But client code can use the `nodeViews` spec to\n    // supply a custom node view, which can influence various aspects of\n    // the way the node works.\n    //\n    // (Using subclassing for this was intentionally decided against,\n    // since it'd require exposing a whole slew of finicky\n    // implementation details to the user code that they probably will\n    // never need.)\n    static create(parent, node, outerDeco, innerDeco, view, pos) {\n        let custom = view.nodeViews[node.type.name], descObj;\n        let spec = custom && custom(node, view, ()=>{\n            // (This is a function that allows the custom view to find its\n            // own position)\n            if (!descObj) return pos;\n            if (descObj.parent) return descObj.parent.posBeforeChild(descObj);\n        }, outerDeco, innerDeco);\n        let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n        if (node.isText) {\n            if (!dom) dom = document.createTextNode(node.text);\n            else if (dom.nodeType != 3) throw new RangeError(\"Text must be rendered as a DOM text node\");\n        } else if (!dom) {\n            ({ dom, contentDOM } = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)));\n        }\n        if (!contentDOM && !node.isText && dom.nodeName != \"BR\") {\n            if (!dom.hasAttribute(\"contenteditable\")) dom.contentEditable = \"false\";\n            if (node.type.spec.draggable) dom.draggable = true;\n        }\n        let nodeDOM = dom;\n        dom = applyOuterDeco(dom, outerDeco, node);\n        if (spec) return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);\n        else if (node.isText) return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);\n        else return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);\n    }\n    parseRule() {\n        // Experimental kludge to allow opt-in re-parsing of nodes\n        if (this.node.type.spec.reparseInView) return null;\n        // FIXME the assumption that this can always return the current\n        // attrs means that if the user somehow manages to change the\n        // attrs in the dom, that won't be picked up. Not entirely sure\n        // whether this is a problem\n        let rule = {\n            node: this.node.type.name,\n            attrs: this.node.attrs\n        };\n        if (this.node.type.whitespace == \"pre\") rule.preserveWhitespace = \"full\";\n        if (!this.contentDOM) {\n            rule.getContent = ()=>this.node.content;\n        } else if (!this.contentLost) {\n            rule.contentElement = this.contentDOM;\n        } else {\n            // Chrome likes to randomly recreate parent nodes when\n            // backspacing things. When that happens, this tries to find the\n            // new parent.\n            for(let i = this.children.length - 1; i >= 0; i--){\n                let child = this.children[i];\n                if (this.dom.contains(child.dom.parentNode)) {\n                    rule.contentElement = child.dom.parentNode;\n                    break;\n                }\n            }\n            if (!rule.contentElement) rule.getContent = ()=>prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        }\n        return rule;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n        return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);\n    }\n    get size() {\n        return this.node.nodeSize;\n    }\n    get border() {\n        return this.node.isLeaf ? 0 : 1;\n    }\n    // Syncs `this.children` to match `this.node.content` and the local\n    // decorations, possibly introducing nesting for marks. Then, in a\n    // separate step, syncs the DOM inside `this.contentDOM` to\n    // `this.children`.\n    updateChildren(view, pos) {\n        let inline = this.node.inlineContent, off = pos;\n        let composition = view.composing ? this.localCompositionInfo(view, pos) : null;\n        let localComposition = composition && composition.pos > -1 ? composition : null;\n        let compositionInChild = composition && composition.pos < 0;\n        let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);\n        iterDeco(this.node, this.innerDeco, (widget, i, insideNode)=>{\n            if (widget.spec.marks) updater.syncToMarks(widget.spec.marks, inline, view);\n            else if (widget.type.side >= 0 && !insideNode) updater.syncToMarks(i == this.node.childCount ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none : this.node.child(i).marks, inline, view);\n            // If the next node is a desc matching this widget, reuse it,\n            // otherwise insert the widget as a new view desc.\n            updater.placeWidget(widget, view, off);\n        }, (child, outerDeco, innerDeco, i)=>{\n            // Make sure the wrapping mark descs match the node's marks.\n            updater.syncToMarks(child.marks, inline, view);\n            // Try several strategies for drawing this node\n            let compIndex;\n            if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;\n            else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;\n            else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;\n            else {\n                // Add it as a new view\n                updater.addNode(child, outerDeco, innerDeco, view, off);\n            }\n            off += child.nodeSize;\n        });\n        // Drop all remaining descs after the current position.\n        updater.syncToMarks([], inline, view);\n        if (this.node.isTextblock) updater.addTextblockHacks();\n        updater.destroyRest();\n        // Sync the DOM if anything changed\n        if (updater.changed || this.dirty == CONTENT_DIRTY) {\n            // May have to protect focused DOM from being changed if a composition is active\n            if (localComposition) this.protectLocalComposition(view, localComposition);\n            renderDescs(this.contentDOM, this.children, view);\n            if (ios) iosHacks(this.dom);\n        }\n    }\n    localCompositionInfo(view, pos) {\n        // Only do something if both the selection and a focused text node\n        // are inside of this node\n        let { from, to } = view.state.selection;\n        if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || from < pos || to > pos + this.node.content.size) return null;\n        let sel = view.domSelectionRange();\n        let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);\n        if (!textNode || !this.dom.contains(textNode.parentNode)) return null;\n        if (this.node.inlineContent) {\n            // Find the text in the focused node in the node, stop if it's not\n            // there (may have been modified through other means, in which\n            // case it should overwritten)\n            let text = textNode.nodeValue;\n            let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);\n            return textPos < 0 ? null : {\n                node: textNode,\n                pos: textPos,\n                text\n            };\n        } else {\n            return {\n                node: textNode,\n                pos: -1,\n                text: \"\"\n            };\n        }\n    }\n    protectLocalComposition(view, { node, pos, text }) {\n        // The node is already part of a local view desc, leave it there\n        if (this.getDesc(node)) return;\n        // Create a composition view for the orphaned nodes\n        let topNode = node;\n        for(;; topNode = topNode.parentNode){\n            if (topNode.parentNode == this.contentDOM) break;\n            while(topNode.previousSibling)topNode.parentNode.removeChild(topNode.previousSibling);\n            while(topNode.nextSibling)topNode.parentNode.removeChild(topNode.nextSibling);\n            if (topNode.pmViewDesc) topNode.pmViewDesc = undefined;\n        }\n        let desc = new CompositionViewDesc(this, topNode, node, text);\n        view.input.compositionNodes.push(desc);\n        // Patch up this.children to contain the composition view\n        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);\n    }\n    // If this desc must be updated to match the given node decoration,\n    // do so and return true.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node)) return false;\n        this.updateInner(node, outerDeco, innerDeco, view);\n        return true;\n    }\n    updateInner(node, outerDeco, innerDeco, view) {\n        this.updateOuterDeco(outerDeco);\n        this.node = node;\n        this.innerDeco = innerDeco;\n        if (this.contentDOM) this.updateChildren(view, this.posAtStart);\n        this.dirty = NOT_DIRTY;\n    }\n    updateOuterDeco(outerDeco) {\n        if (sameOuterDeco(outerDeco, this.outerDeco)) return;\n        let needsWrap = this.nodeDOM.nodeType != 1;\n        let oldDOM = this.dom;\n        this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));\n        if (this.dom != oldDOM) {\n            oldDOM.pmViewDesc = undefined;\n            this.dom.pmViewDesc = this;\n        }\n        this.outerDeco = outerDeco;\n    }\n    // Mark this node as being the selected node.\n    selectNode() {\n        if (this.nodeDOM.nodeType == 1) this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n        if (this.contentDOM || !this.node.type.spec.draggable) this.dom.draggable = true;\n    }\n    // Remove selected node marking from this node.\n    deselectNode() {\n        if (this.nodeDOM.nodeType == 1) this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n        if (this.contentDOM || !this.node.type.spec.draggable) this.dom.removeAttribute(\"draggable\");\n    }\n    get domAtom() {\n        return this.node.isAtom;\n    }\n}\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nfunction docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n    applyOuterDeco(dom, outerDeco, doc);\n    let docView = new NodeViewDesc(undefined, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);\n    if (docView.contentDOM) docView.updateChildren(view, 0);\n    return docView;\n}\nclass TextViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view){\n        super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);\n    }\n    parseRule() {\n        let skip = this.nodeDOM.parentNode;\n        while(skip && skip != this.dom && !skip.pmIsDeco)skip = skip.parentNode;\n        return {\n            skip: skip || true\n        };\n    }\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node)) return false;\n        this.updateOuterDeco(outerDeco);\n        if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n            this.nodeDOM.nodeValue = node.text;\n            if (view.trackWrites == this.nodeDOM) view.trackWrites = null;\n        }\n        this.node = node;\n        this.dirty = NOT_DIRTY;\n        return true;\n    }\n    inParent() {\n        let parentDOM = this.parent.contentDOM;\n        for(let n = this.nodeDOM; n; n = n.parentNode)if (n == parentDOM) return true;\n        return false;\n    }\n    domFromPos(pos) {\n        return {\n            node: this.nodeDOM,\n            offset: pos\n        };\n    }\n    localPosFromDOM(dom, offset, bias) {\n        if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length);\n        return super.localPosFromDOM(dom, offset, bias);\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"characterData\" && mutation.type != \"selection\";\n    }\n    slice(from, to, view) {\n        let node = this.node.cut(from, to), dom = document.createTextNode(node.text);\n        return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);\n    }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length)) this.dirty = NODE_DIRTY;\n    }\n    get domAtom() {\n        return false;\n    }\n}\n// A dummy desc used to tag trailing BR or IMG nodes created to work\n// around contentEditable terribleness.\nclass TrailingHackViewDesc extends ViewDesc {\n    parseRule() {\n        return {\n            ignore: true\n        };\n    }\n    matchesHack(nodeName) {\n        return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;\n    }\n    get domAtom() {\n        return true;\n    }\n    get ignoreForCoords() {\n        return this.dom.nodeName == \"IMG\";\n    }\n}\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nclass CustomNodeViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos){\n        super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n        this.spec = spec;\n    }\n    // A custom `update` method gets to decide whether the update goes\n    // through. If it does, and there's a `contentDOM` node, our logic\n    // updates the children.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY) return false;\n        if (this.spec.update) {\n            let result = this.spec.update(node, outerDeco, innerDeco);\n            if (result) this.updateInner(node, outerDeco, innerDeco, view);\n            return result;\n        } else if (!this.contentDOM && !node.isLeaf) {\n            return false;\n        } else {\n            return super.update(node, outerDeco, innerDeco, view);\n        }\n    }\n    selectNode() {\n        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();\n    }\n    deselectNode() {\n        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();\n    }\n    setSelection(anchor, head, root, force) {\n        this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : super.setSelection(anchor, head, root, force);\n    }\n    destroy() {\n        if (this.spec.destroy) this.spec.destroy();\n        super.destroy();\n    }\n    stopEvent(event) {\n        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n}\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs, view) {\n    let dom = parentDOM.firstChild, written = false;\n    for(let i = 0; i < descs.length; i++){\n        let desc = descs[i], childDOM = desc.dom;\n        if (childDOM.parentNode == parentDOM) {\n            while(childDOM != dom){\n                dom = rm(dom);\n                written = true;\n            }\n            dom = dom.nextSibling;\n        } else {\n            written = true;\n            parentDOM.insertBefore(childDOM, dom);\n        }\n        if (desc instanceof MarkViewDesc) {\n            let pos = dom ? dom.previousSibling : parentDOM.lastChild;\n            renderDescs(desc.contentDOM, desc.children, view);\n            dom = pos ? pos.nextSibling : parentDOM.firstChild;\n        }\n    }\n    while(dom){\n        dom = rm(dom);\n        written = true;\n    }\n    if (written && view.trackWrites == parentDOM) view.trackWrites = null;\n}\nconst OuterDecoLevel = function(nodeName) {\n    if (nodeName) this.nodeName = nodeName;\n};\nOuterDecoLevel.prototype = Object.create(null);\nconst noDeco = [\n    new OuterDecoLevel\n];\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n    if (outerDeco.length == 0) return noDeco;\n    let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [\n        top\n    ];\n    for(let i = 0; i < outerDeco.length; i++){\n        let attrs = outerDeco[i].type.attrs;\n        if (!attrs) continue;\n        if (attrs.nodeName) result.push(top = new OuterDecoLevel(attrs.nodeName));\n        for(let name in attrs){\n            let val = attrs[name];\n            if (val == null) continue;\n            if (needsWrap && result.length == 1) result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"));\n            if (name == \"class\") top.class = (top.class ? top.class + \" \" : \"\") + val;\n            else if (name == \"style\") top.style = (top.style ? top.style + \";\" : \"\") + val;\n            else if (name != \"nodeName\") top[name] = val;\n        }\n    }\n    return result;\n}\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n    // Shortcut for trivial case\n    if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM;\n    let curDOM = nodeDOM;\n    for(let i = 0; i < curComputed.length; i++){\n        let deco = curComputed[i], prev = prevComputed[i];\n        if (i) {\n            let parent;\n            if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {\n                curDOM = parent;\n            } else {\n                parent = document.createElement(deco.nodeName);\n                parent.pmIsDeco = true;\n                parent.appendChild(curDOM);\n                prev = noDeco[0];\n                curDOM = parent;\n            }\n        }\n        patchAttributes(curDOM, prev || noDeco[0], deco);\n    }\n    return curDOM;\n}\nfunction patchAttributes(dom, prev, cur) {\n    for(let name in prev)if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur)) dom.removeAttribute(name);\n    for(let name in cur)if (name != \"class\" && name != \"style\" && name != \"nodeName\" && cur[name] != prev[name]) dom.setAttribute(name, cur[name]);\n    if (prev.class != cur.class) {\n        let prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : [];\n        let curList = cur.class ? cur.class.split(\" \").filter(Boolean) : [];\n        for(let i = 0; i < prevList.length; i++)if (curList.indexOf(prevList[i]) == -1) dom.classList.remove(prevList[i]);\n        for(let i = 0; i < curList.length; i++)if (prevList.indexOf(curList[i]) == -1) dom.classList.add(curList[i]);\n        if (dom.classList.length == 0) dom.removeAttribute(\"class\");\n    }\n    if (prev.style != cur.style) {\n        if (prev.style) {\n            let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m;\n            while(m = prop.exec(prev.style))dom.style.removeProperty(m[1]);\n        }\n        if (cur.style) dom.style.cssText += cur.style;\n    }\n}\nfunction applyOuterDeco(dom, deco, node) {\n    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));\n}\nfunction sameOuterDeco(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!a[i].type.eq(b[i].type)) return false;\n    return true;\n}\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nclass ViewTreeUpdater {\n    constructor(top, lock, view){\n        this.lock = lock;\n        this.view = view;\n        // Index into `this.top`'s child array, represents the current\n        // update position.\n        this.index = 0;\n        // When entering a mark, the current top and index are pushed\n        // onto this.\n        this.stack = [];\n        // Tracks whether anything was changed\n        this.changed = false;\n        this.top = top;\n        this.preMatch = preMatch(top.node.content, top);\n    }\n    // Destroy and remove the children between the given indices in\n    // `this.top`.\n    destroyBetween(start, end) {\n        if (start == end) return;\n        for(let i = start; i < end; i++)this.top.children[i].destroy();\n        this.top.children.splice(start, end - start);\n        this.changed = true;\n    }\n    // Destroy all remaining children in `this.top`.\n    destroyRest() {\n        this.destroyBetween(this.index, this.top.children.length);\n    }\n    // Sync the current stack of mark descs with the given array of\n    // marks, reusing existing mark descs when possible.\n    syncToMarks(marks, inline, view) {\n        let keep = 0, depth = this.stack.length >> 1;\n        let maxKeep = Math.min(depth, marks.length);\n        while(keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)keep++;\n        while(keep < depth){\n            this.destroyRest();\n            this.top.dirty = NOT_DIRTY;\n            this.index = this.stack.pop();\n            this.top = this.stack.pop();\n            depth--;\n        }\n        while(depth < marks.length){\n            this.stack.push(this.top, this.index + 1);\n            let found = -1;\n            for(let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++){\n                let next = this.top.children[i];\n                if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {\n                    found = i;\n                    break;\n                }\n            }\n            if (found > -1) {\n                if (found > this.index) {\n                    this.changed = true;\n                    this.destroyBetween(this.index, found);\n                }\n                this.top = this.top.children[this.index];\n            } else {\n                let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);\n                this.top.children.splice(this.index, 0, markDesc);\n                this.top = markDesc;\n                this.changed = true;\n            }\n            this.index = 0;\n            depth++;\n        }\n    }\n    // Try to find a node desc matching the given data. Skip over it and\n    // return true when successful.\n    findNodeMatch(node, outerDeco, innerDeco, index) {\n        let found = -1, targetDesc;\n        if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n            found = this.top.children.indexOf(targetDesc, this.index);\n        } else {\n            for(let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++){\n                let child = this.top.children[i];\n                if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n                    found = i;\n                    break;\n                }\n            }\n        }\n        if (found < 0) return false;\n        this.destroyBetween(this.index, found);\n        this.index++;\n        return true;\n    }\n    updateNodeAt(node, outerDeco, innerDeco, index, view) {\n        let child = this.top.children[index];\n        if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM) child.dirty = CONTENT_DIRTY;\n        if (!child.update(node, outerDeco, innerDeco, view)) return false;\n        this.destroyBetween(this.index, index);\n        this.index++;\n        return true;\n    }\n    findIndexWithChild(domNode) {\n        for(;;){\n            let parent = domNode.parentNode;\n            if (!parent) return -1;\n            if (parent == this.top.contentDOM) {\n                let desc = domNode.pmViewDesc;\n                if (desc) for(let i = this.index; i < this.top.children.length; i++){\n                    if (this.top.children[i] == desc) return i;\n                }\n                return -1;\n            }\n            domNode = parent;\n        }\n    }\n    // Try to update the next node, if any, to the given data. Checks\n    // pre-matches to avoid overwriting nodes that could still be used.\n    updateNextNode(node, outerDeco, innerDeco, view, index, pos) {\n        for(let i = this.index; i < this.top.children.length; i++){\n            let next = this.top.children[i];\n            if (next instanceof NodeViewDesc) {\n                let preMatch = this.preMatch.matched.get(next);\n                if (preMatch != null && preMatch != index) return false;\n                let nextDOM = next.dom, updated;\n                // Can't update if nextDOM is or contains this.lock, except if\n                // it's a text node whose content already matches the new text\n                // and whose decorations match the new ones.\n                let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n                if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n                    this.destroyBetween(this.index, i);\n                    if (next.dom != nextDOM) this.changed = true;\n                    this.index++;\n                    return true;\n                } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {\n                    this.top.children[this.index] = updated;\n                    if (updated.contentDOM) {\n                        updated.dirty = CONTENT_DIRTY;\n                        updated.updateChildren(view, pos + 1);\n                        updated.dirty = NOT_DIRTY;\n                    }\n                    this.changed = true;\n                    this.index++;\n                    return true;\n                }\n                break;\n            }\n        }\n        return false;\n    }\n    // When a node with content is replaced by a different node with\n    // identical content, move over its children.\n    recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {\n        if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content)) return null;\n        let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (wrapper.contentDOM) {\n            wrapper.children = next.children;\n            next.children = [];\n            for (let ch of wrapper.children)ch.parent = wrapper;\n        }\n        next.destroy();\n        return wrapper;\n    }\n    // Insert the node as a newly created node desc.\n    addNode(node, outerDeco, innerDeco, view, pos) {\n        let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (desc.contentDOM) desc.updateChildren(view, pos + 1);\n        this.top.children.splice(this.index++, 0, desc);\n        this.changed = true;\n    }\n    placeWidget(widget, view, pos) {\n        let next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n        if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n            this.index++;\n        } else {\n            let desc = new WidgetViewDesc(this.top, widget, view, pos);\n            this.top.children.splice(this.index++, 0, desc);\n            this.changed = true;\n        }\n    }\n    // Make sure a textblock looks and behaves correctly in\n    // contentEditable.\n    addTextblockHacks() {\n        let lastChild = this.top.children[this.index - 1], parent = this.top;\n        while(lastChild instanceof MarkViewDesc){\n            parent = lastChild;\n            lastChild = parent.children[parent.children.length - 1];\n        }\n        if (!lastChild || // Empty textblock\n        !(lastChild instanceof TextViewDesc) || /\\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\\s$/.test(lastChild.node.text)) {\n            // Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)\n            if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == \"false\") this.addHackNode(\"IMG\", parent);\n            this.addHackNode(\"BR\", this.top);\n        }\n    }\n    addHackNode(nodeName, parent) {\n        if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {\n            this.index++;\n        } else {\n            let dom = document.createElement(nodeName);\n            if (nodeName == \"IMG\") {\n                dom.className = \"ProseMirror-separator\";\n                dom.alt = \"\";\n            }\n            if (nodeName == \"BR\") dom.className = \"ProseMirror-trailingBreak\";\n            let hack = new TrailingHackViewDesc(this.top, [], dom, null);\n            if (parent != this.top) parent.children.push(hack);\n            else parent.children.splice(this.index++, 0, hack);\n            this.changed = true;\n        }\n    }\n    isLocked(node) {\n        return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));\n    }\n}\n// Iterate from the end of the fragment and array of descs to find\n// directly matching ones, in order to avoid overeagerly reusing those\n// for other nodes. Returns the fragment index of the first node that\n// is part of the sequence of matched nodes at the end of the\n// fragment.\nfunction preMatch(frag, parentDesc) {\n    let curDesc = parentDesc, descI = curDesc.children.length;\n    let fI = frag.childCount, matched = new Map, matches = [];\n    outer: while(fI > 0){\n        let desc;\n        for(;;){\n            if (descI) {\n                let next = curDesc.children[descI - 1];\n                if (next instanceof MarkViewDesc) {\n                    curDesc = next;\n                    descI = next.children.length;\n                } else {\n                    desc = next;\n                    descI--;\n                    break;\n                }\n            } else if (curDesc == parentDesc) {\n                break outer;\n            } else {\n                // FIXME\n                descI = curDesc.parent.children.indexOf(curDesc);\n                curDesc = curDesc.parent;\n            }\n        }\n        let node = desc.node;\n        if (!node) continue;\n        if (node != frag.child(fI - 1)) break;\n        --fI;\n        matched.set(desc, fI);\n        matches.push(desc);\n    }\n    return {\n        index: fI,\n        matched,\n        matches: matches.reverse()\n    };\n}\nfunction compareSide(a, b) {\n    return a.type.side - b.type.side;\n}\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n    let locals = deco.locals(parent), offset = 0;\n    // Simple, cheap variant for when there are no local decorations\n    if (locals.length == 0) {\n        for(let i = 0; i < parent.childCount; i++){\n            let child = parent.child(i);\n            onNode(child, locals, deco.forChild(offset, child), i);\n            offset += child.nodeSize;\n        }\n        return;\n    }\n    let decoIndex = 0, active = [], restNode = null;\n    for(let parentIndex = 0;;){\n        let widget, widgets;\n        while(decoIndex < locals.length && locals[decoIndex].to == offset){\n            let next = locals[decoIndex++];\n            if (next.widget) {\n                if (!widget) widget = next;\n                else (widgets || (widgets = [\n                    widget\n                ])).push(next);\n            }\n        }\n        if (widget) {\n            if (widgets) {\n                widgets.sort(compareSide);\n                for(let i = 0; i < widgets.length; i++)onWidget(widgets[i], parentIndex, !!restNode);\n            } else {\n                onWidget(widget, parentIndex, !!restNode);\n            }\n        }\n        let child, index;\n        if (restNode) {\n            index = -1;\n            child = restNode;\n            restNode = null;\n        } else if (parentIndex < parent.childCount) {\n            index = parentIndex;\n            child = parent.child(parentIndex++);\n        } else {\n            break;\n        }\n        for(let i = 0; i < active.length; i++)if (active[i].to <= offset) active.splice(i--, 1);\n        while(decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)active.push(locals[decoIndex++]);\n        let end = offset + child.nodeSize;\n        if (child.isText) {\n            let cutAt = end;\n            if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from;\n            for(let i = 0; i < active.length; i++)if (active[i].to < cutAt) cutAt = active[i].to;\n            if (cutAt < end) {\n                restNode = child.cut(cutAt - offset);\n                child = child.cut(0, cutAt - offset);\n                end = cutAt;\n                index = -1;\n            }\n        } else {\n            while(decoIndex < locals.length && locals[decoIndex].to < end)decoIndex++;\n        }\n        let outerDeco = child.isInline && !child.isLeaf ? active.filter((d)=>!d.inline) : active.slice();\n        onNode(child, outerDeco, deco.forChild(offset, child), index);\n        offset = end;\n    }\n}\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n    if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n        let oldCSS = dom.style.cssText;\n        dom.style.cssText = oldCSS + \"; list-style: square !important\";\n        window.getComputedStyle(dom).listStyle;\n        dom.style.cssText = oldCSS;\n    }\n}\nfunction nearbyTextNode(node, offset) {\n    for(;;){\n        if (node.nodeType == 3) return node;\n        if (node.nodeType == 1 && offset > 0) {\n            if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3) return node.childNodes[offset];\n            node = node.childNodes[offset - 1];\n            offset = nodeSize(node);\n        } else if (node.nodeType == 1 && offset < node.childNodes.length) {\n            node = node.childNodes[offset];\n            offset = 0;\n        } else {\n            return null;\n        }\n    }\n}\n// Find a piece of text in an inline fragment, overlapping from-to\nfunction findTextInFragment(frag, text, from, to) {\n    for(let i = 0, pos = 0; i < frag.childCount && pos <= to;){\n        let child = frag.child(i++), childStart = pos;\n        pos += child.nodeSize;\n        if (!child.isText) continue;\n        let str = child.text;\n        while(i < frag.childCount){\n            let next = frag.child(i++);\n            pos += next.nodeSize;\n            if (!next.isText) break;\n            str += next.text;\n        }\n        if (pos >= from) {\n            if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text) return to - text.length;\n            let found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;\n            if (found >= 0 && found + text.length + childStart >= from) return childStart + found;\n            if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text) return to;\n        }\n    }\n    return -1;\n}\n// Replace range from-to in an array of view descs with replacement\n// (may be null to just delete). This goes very much against the grain\n// of the rest of this code, which tends to create nodes with the\n// right shape in one go, rather than messing with them after\n// creation, but is necessary in the composition hack.\nfunction replaceNodes(nodes, from, to, view, replacement) {\n    let result = [];\n    for(let i = 0, off = 0; i < nodes.length; i++){\n        let child = nodes[i], start = off, end = off += child.size;\n        if (start >= to || end <= from) {\n            result.push(child);\n        } else {\n            if (start < from) result.push(child.slice(0, from - start, view));\n            if (replacement) {\n                result.push(replacement);\n                replacement = undefined;\n            }\n            if (end > to) result.push(child.slice(to - start, child.size, view));\n        }\n    }\n    return result;\n}\nfunction selectionFromDOM(view, origin = null) {\n    let domSel = view.domSelectionRange(), doc = view.state.doc;\n    if (!domSel.focusNode) return null;\n    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);\n    if (head < 0) return null;\n    let $head = doc.resolve(head), $anchor, selection;\n    if (selectionCollapsed(domSel)) {\n        $anchor = $head;\n        while(nearestDesc && !nearestDesc.node)nearestDesc = nearestDesc.parent;\n        let nearestDescNode = nearestDesc.node;\n        if (nearestDesc && nearestDescNode.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n            let pos = nearestDesc.posBefore;\n            selection = new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(head == pos ? $head : doc.resolve(pos));\n        }\n    } else {\n        let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);\n        if (anchor < 0) return null;\n        $anchor = doc.resolve(anchor);\n    }\n    if (!selection) {\n        let bias = origin == \"pointer\" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;\n        selection = selectionBetween(view, $anchor, $head, bias);\n    }\n    return selection;\n}\nfunction editorOwnsSelection(view) {\n    return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);\n}\nfunction selectionToDOM(view, force = false) {\n    let sel = view.state.selection;\n    syncNodeSelection(view, sel);\n    if (!editorOwnsSelection(view)) return;\n    // The delayed drag selection causes issues with Cell Selections\n    // in Safari. And the drag selection delay is to workarond issues\n    // which only present in Chrome.\n    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {\n        let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;\n        if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {\n            view.input.mouseDown.delayedSelectionSync = true;\n            view.domObserver.setCurSelection();\n            return;\n        }\n    }\n    view.domObserver.disconnectSelection();\n    if (view.cursorWrapper) {\n        selectCursorWrapper(view);\n    } else {\n        let { anchor, head } = sel, resetEditableFrom, resetEditableTo;\n        if (brokenSelectBetweenUneditable && !(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) {\n            if (!sel.$from.parent.inlineContent) resetEditableFrom = temporarilyEditableNear(view, sel.from);\n            if (!sel.empty && !sel.$from.parent.inlineContent) resetEditableTo = temporarilyEditableNear(view, sel.to);\n        }\n        view.docView.setSelection(anchor, head, view.root, force);\n        if (brokenSelectBetweenUneditable) {\n            if (resetEditableFrom) resetEditable(resetEditableFrom);\n            if (resetEditableTo) resetEditable(resetEditableTo);\n        }\n        if (sel.visible) {\n            view.dom.classList.remove(\"ProseMirror-hideselection\");\n        } else {\n            view.dom.classList.add(\"ProseMirror-hideselection\");\n            if (\"onselectionchange\" in document) removeClassOnSelectionChange(view);\n        }\n    }\n    view.domObserver.setCurSelection();\n    view.domObserver.connectSelection();\n}\n// Kludge to work around Webkit not allowing a selection to start/end\n// between non-editable block nodes. We briefly make something\n// editable, set the selection, then set it uneditable again.\nconst brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;\nfunction temporarilyEditableNear(view, pos) {\n    let { node, offset } = view.docView.domFromPos(pos, 0);\n    let after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n    let before = offset ? node.childNodes[offset - 1] : null;\n    if (safari && after && after.contentEditable == \"false\") return setEditable(after);\n    if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n        if (after) return setEditable(after);\n        else if (before) return setEditable(before);\n    }\n}\nfunction setEditable(element) {\n    element.contentEditable = \"true\";\n    if (safari && element.draggable) {\n        element.draggable = false;\n        element.wasDraggable = true;\n    }\n    return element;\n}\nfunction resetEditable(element) {\n    element.contentEditable = \"false\";\n    if (element.wasDraggable) {\n        element.draggable = true;\n        element.wasDraggable = null;\n    }\n}\nfunction removeClassOnSelectionChange(view) {\n    let doc = view.dom.ownerDocument;\n    doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n    let domSel = view.domSelectionRange();\n    let node = domSel.anchorNode, offset = domSel.anchorOffset;\n    doc.addEventListener(\"selectionchange\", view.input.hideSelectionGuard = ()=>{\n        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n            doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n            setTimeout(()=>{\n                if (!editorOwnsSelection(view) || view.state.selection.visible) view.dom.classList.remove(\"ProseMirror-hideselection\");\n            }, 20);\n        }\n    });\n}\nfunction selectCursorWrapper(view) {\n    let domSel = view.domSelection(), range = document.createRange();\n    let node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\";\n    if (img) range.setEnd(node.parentNode, domIndex(node) + 1);\n    else range.setEnd(node, 0);\n    range.collapse(false);\n    domSel.removeAllRanges();\n    domSel.addRange(range);\n    // Kludge to kill 'control selection' in IE11 when selecting an\n    // invisible cursor wrapper, since that would result in those weird\n    // resize handles and a selection that considers the absolutely\n    // positioned wrapper, rather than the root editable node, the\n    // focused element.\n    if (!img && !view.state.selection.visible && ie && ie_version <= 11) {\n        node.disabled = true;\n        node.disabled = false;\n    }\n}\nfunction syncNodeSelection(view, sel) {\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        let desc = view.docView.descAt(sel.from);\n        if (desc != view.lastSelectedViewDesc) {\n            clearNodeSelection(view);\n            if (desc) desc.selectNode();\n            view.lastSelectedViewDesc = desc;\n        }\n    } else {\n        clearNodeSelection(view);\n    }\n}\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n    if (view.lastSelectedViewDesc) {\n        if (view.lastSelectedViewDesc.parent) view.lastSelectedViewDesc.deselectNode();\n        view.lastSelectedViewDesc = undefined;\n    }\n}\nfunction selectionBetween(view, $anchor, $head, bias) {\n    return view.someProp(\"createSelectionBetween\", (f)=>f(view, $anchor, $head)) || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.between($anchor, $head, bias);\n}\nfunction hasFocusAndSelection(view) {\n    if (view.editable && !view.hasFocus()) return false;\n    return hasSelection(view);\n}\nfunction hasSelection(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.anchorNode) return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));\n    } catch (_) {\n        return false;\n    }\n}\nfunction anchorInRightPlace(view) {\n    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n    let domSel = view.domSelectionRange();\n    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);\n}\nfunction moveSelectionBlock(state, dir) {\n    let { $anchor, $head } = state.selection;\n    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n    return $start && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($start, dir);\n}\nfunction apply(view, sel) {\n    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n    return true;\n}\nfunction selectHorizontally(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (mods.indexOf(\"s\") > -1) {\n            let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;\n            if (!node || node.isText || !node.isLeaf) return false;\n            let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));\n            return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(sel.$anchor, $newHead));\n        } else if (!sel.empty) {\n            return false;\n        } else if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) {\n            let next = moveSelectionBlock(view.state, dir);\n            if (next && next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) return apply(view, next);\n            return false;\n        } else if (!(mac && mods.indexOf(\"m\") > -1)) {\n            let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n            if (!node || node.isText) return false;\n            let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n            if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false;\n            if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));\n            } else if (webkit) {\n                // Chrome and Safari will introduce extra pointless cursor\n                // positions around inline uneditable nodes, so we have to\n                // take over and move the cursor past them (#937)\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));\n            } else {\n                return false;\n            }\n        }\n    } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && sel.node.isInline) {\n        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(dir > 0 ? sel.$to : sel.$from));\n    } else {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next) return apply(view, next);\n        return false;\n    }\n}\nfunction nodeLen(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction isIgnorable(dom, dir) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != \"BR\");\n}\nfunction skipIgnoredNodes(view, dir) {\n    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);\n}\n// Make sure the cursor isn't directly after one or more ignored\n// nodes, which will confuse the browser's cursor motion logic.\nfunction skipIgnoredNodesBefore(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node) return;\n    let moveNode, moveOffset, force = false;\n    // Gecko will do odd things when the selection is directly in front\n    // of a non-editable node, so in that case, move it into the next\n    // node if possible. Issue prosemirror/prosemirror#832.\n    if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1)) force = true;\n    for(;;){\n        if (offset > 0) {\n            if (node.nodeType != 1) {\n                break;\n            } else {\n                let before = node.childNodes[offset - 1];\n                if (isIgnorable(before, -1)) {\n                    moveNode = node;\n                    moveOffset = --offset;\n                } else if (before.nodeType == 3) {\n                    node = before;\n                    offset = node.nodeValue.length;\n                } else break;\n            }\n        } else if (isBlockNode(node)) {\n            break;\n        } else {\n            let prev = node.previousSibling;\n            while(prev && isIgnorable(prev, -1)){\n                moveNode = node.parentNode;\n                moveOffset = domIndex(prev);\n                prev = prev.previousSibling;\n            }\n            if (!prev) {\n                node = node.parentNode;\n                if (node == view.dom) break;\n                offset = 0;\n            } else {\n                node = prev;\n                offset = nodeLen(node);\n            }\n        }\n    }\n    if (force) setSelFocus(view, node, offset);\n    else if (moveNode) setSelFocus(view, moveNode, moveOffset);\n}\n// Make sure the cursor isn't directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesAfter(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node) return;\n    let len = nodeLen(node);\n    let moveNode, moveOffset;\n    for(;;){\n        if (offset < len) {\n            if (node.nodeType != 1) break;\n            let after = node.childNodes[offset];\n            if (isIgnorable(after, 1)) {\n                moveNode = node;\n                moveOffset = ++offset;\n            } else break;\n        } else if (isBlockNode(node)) {\n            break;\n        } else {\n            let next = node.nextSibling;\n            while(next && isIgnorable(next, 1)){\n                moveNode = next.parentNode;\n                moveOffset = domIndex(next) + 1;\n                next = next.nextSibling;\n            }\n            if (!next) {\n                node = node.parentNode;\n                if (node == view.dom) break;\n                offset = len = 0;\n            } else {\n                node = next;\n                offset = 0;\n                len = nodeLen(node);\n            }\n        }\n    }\n    if (moveNode) setSelFocus(view, moveNode, moveOffset);\n}\nfunction isBlockNode(dom) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.node && desc.node.isBlock;\n}\nfunction textNodeAfter(node, offset) {\n    while(node && offset == node.childNodes.length && !hasBlockDesc(node)){\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n    }\n    while(node && offset < node.childNodes.length){\n        let next = node.childNodes[offset];\n        if (next.nodeType == 3) return next;\n        if (next.nodeType == 1 && next.contentEditable == \"false\") break;\n        node = next;\n        offset = 0;\n    }\n}\nfunction textNodeBefore(node, offset) {\n    while(node && !offset && !hasBlockDesc(node)){\n        offset = domIndex(node);\n        node = node.parentNode;\n    }\n    while(node && offset){\n        let next = node.childNodes[offset - 1];\n        if (next.nodeType == 3) return next;\n        if (next.nodeType == 1 && next.contentEditable == \"false\") break;\n        node = next;\n        offset = node.childNodes.length;\n    }\n}\nfunction setSelFocus(view, node, offset) {\n    if (node.nodeType != 3) {\n        let before, after;\n        if (after = textNodeAfter(node, offset)) {\n            node = after;\n            offset = 0;\n        } else if (before = textNodeBefore(node, offset)) {\n            node = before;\n            offset = before.nodeValue.length;\n        }\n    }\n    let sel = view.domSelection();\n    if (selectionCollapsed(sel)) {\n        let range = document.createRange();\n        range.setEnd(node, offset);\n        range.setStart(node, offset);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    } else if (sel.extend) {\n        sel.extend(node, offset);\n    }\n    view.domObserver.setCurSelection();\n    let { state } = view;\n    // If no state update ends up happening, reset the selection.\n    setTimeout(()=>{\n        if (view.state == state) selectionToDOM(view);\n    }, 50);\n}\nfunction findDirection(view, pos) {\n    let $pos = view.state.doc.resolve(pos);\n    if (!(chrome || windows) && $pos.parent.inlineContent) {\n        let coords = view.coordsAtPos(pos);\n        if (pos > $pos.start()) {\n            let before = view.coordsAtPos(pos - 1);\n            let mid = (before.top + before.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1) return before.left < coords.left ? \"ltr\" : \"rtl\";\n        }\n        if (pos < $pos.end()) {\n            let after = view.coordsAtPos(pos + 1);\n            let mid = (after.top + after.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1) return after.left > coords.left ? \"ltr\" : \"rtl\";\n        }\n    }\n    let computed = getComputedStyle(view.dom).direction;\n    return computed == \"rtl\" ? \"rtl\" : \"ltr\";\n}\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty || mods.indexOf(\"s\") > -1) return false;\n    if (mac && mods.indexOf(\"m\") > -1) return false;\n    let { $from, $to } = sel;\n    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next && next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) return apply(view, next);\n    }\n    if (!$from.parent.inlineContent) {\n        let side = dir < 0 ? $from : $to;\n        let beyond = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(side, dir) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(side, dir);\n        return beyond ? apply(view, beyond) : false;\n    }\n    return false;\n}\nfunction stopNativeHorizontalDelete(view, dir) {\n    if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) return true;\n    let { $head, $anchor, empty } = view.state.selection;\n    if (!$head.sameParent($anchor)) return true;\n    if (!empty) return false;\n    if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) return true;\n    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n    if (nextNode && !nextNode.isText) {\n        let tr = view.state.tr;\n        if (dir < 0) tr.delete($head.pos - nextNode.nodeSize, $head.pos);\n        else tr.delete($head.pos, $head.pos + nextNode.nodeSize);\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\nfunction switchEditable(view, node, state) {\n    view.domObserver.stop();\n    node.contentEditable = state;\n    view.domObserver.start();\n}\n// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821\n// In which Safari (and at some point in the past, Chrome) does really\n// wrong things when the down arrow is pressed when the cursor is\n// directly at the start of a textblock and has an uneditable node\n// after it\nfunction safariDownArrowBug(view) {\n    if (!safari || view.state.selection.$head.parentOffset > 0) return false;\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n        let child = focusNode.firstChild;\n        switchEditable(view, child, \"true\");\n        setTimeout(()=>switchEditable(view, child, \"false\"), 20);\n    }\n    return false;\n}\n// A backdrop key mapping used to make sure we always suppress keys\n// that have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\nfunction getMods(event) {\n    let result = \"\";\n    if (event.ctrlKey) result += \"c\";\n    if (event.metaKey) result += \"m\";\n    if (event.altKey) result += \"a\";\n    if (event.shiftKey) result += \"s\";\n    return result;\n}\nfunction captureKeyDown(view, event) {\n    let code = event.keyCode, mods = getMods(event);\n    if (code == 8 || mac && code == 72 && mods == \"c\") {\n        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);\n    } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == \"c\") {\n        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);\n    } else if (code == 13 || code == 27) {\n        return true;\n    } else if (code == 37 || mac && code == 66 && mods == \"c\") {\n        let dir = code == 37 ? findDirection(view, view.state.selection.from) == \"ltr\" ? -1 : 1 : -1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    } else if (code == 39 || mac && code == 70 && mods == \"c\") {\n        let dir = code == 39 ? findDirection(view, view.state.selection.from) == \"ltr\" ? 1 : -1 : 1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    } else if (code == 38 || mac && code == 80 && mods == \"c\") {\n        return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);\n    } else if (code == 40 || mac && code == 78 && mods == \"c\") {\n        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);\n    } else if (mods == (mac ? \"m\" : \"c\") && (code == 66 || code == 73 || code == 89 || code == 90)) {\n        return true;\n    }\n    return false;\n}\nfunction serializeForClipboard(view, slice) {\n    view.someProp(\"transformCopied\", (f)=>{\n        slice = f(slice, view);\n    });\n    let context = [], { content, openStart, openEnd } = slice;\n    while(openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1){\n        openStart--;\n        openEnd--;\n        let node = content.firstChild;\n        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n        content = node.content;\n    }\n    let serializer = view.someProp(\"clipboardSerializer\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(view.state.schema);\n    let doc = detachedDoc(), wrap = doc.createElement(\"div\");\n    wrap.appendChild(serializer.serializeFragment(content, {\n        document: doc\n    }));\n    let firstChild = wrap.firstChild, needsWrap, wrappers = 0;\n    while(firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])){\n        for(let i = needsWrap.length - 1; i >= 0; i--){\n            let wrapper = doc.createElement(needsWrap[i]);\n            while(wrap.firstChild)wrapper.appendChild(wrap.firstChild);\n            wrap.appendChild(wrapper);\n            wrappers++;\n        }\n        firstChild = wrap.firstChild;\n    }\n    if (firstChild && firstChild.nodeType == 1) firstChild.setAttribute(\"data-pm-slice\", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : \"\"} ${JSON.stringify(context)}`);\n    let text = view.someProp(\"clipboardTextSerializer\", (f)=>f(slice, view)) || slice.content.textBetween(0, slice.content.size, \"\\n\\n\");\n    return {\n        dom: wrap,\n        text\n    };\n}\n// Read a slice of content from the clipboard (or drop data).\nfunction parseFromClipboard(view, text, html, plainText, $context) {\n    let inCode = $context.parent.type.spec.code;\n    let dom, slice;\n    if (!html && !text) return null;\n    let asText = text && (plainText || inCode || !html);\n    if (asText) {\n        view.someProp(\"transformPastedText\", (f)=>{\n            text = f(text, inCode || plainText, view);\n        });\n        if (inCode) return text ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0) : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;\n        let parsed = view.someProp(\"clipboardTextParser\", (f)=>f(text, $context, plainText, view));\n        if (parsed) {\n            slice = parsed;\n        } else {\n            let marks = $context.marks();\n            let { schema } = view.state, serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(schema);\n            dom = document.createElement(\"div\");\n            text.split(/(?:\\r\\n?|\\n)+/).forEach((block)=>{\n                let p = dom.appendChild(document.createElement(\"p\"));\n                if (block) p.appendChild(serializer.serializeNode(schema.text(block, marks)));\n            });\n        }\n    } else {\n        view.someProp(\"transformPastedHTML\", (f)=>{\n            html = f(html, view);\n        });\n        dom = readHTML(html);\n        if (webkit) restoreReplacedSpaces(dom);\n    }\n    let contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n    let sliceData = contextNode && /^(\\d+) (\\d+)(?: -(\\d+))? (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\") || \"\");\n    if (sliceData && sliceData[3]) for(let i = +sliceData[3]; i > 0; i--){\n        let child = dom.firstChild;\n        while(child && child.nodeType != 1)child = child.nextSibling;\n        if (!child) break;\n        dom = child;\n    }\n    if (!slice) {\n        let parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n        slice = parser.parseSlice(dom, {\n            preserveWhitespace: !!(asText || sliceData),\n            context: $context,\n            ruleFromNode (dom) {\n                if (dom.nodeName == \"BR\" && !dom.nextSibling && dom.parentNode && !inlineParents.test(dom.parentNode.nodeName)) return {\n                    ignore: true\n                };\n                return null;\n            }\n        });\n    }\n    if (sliceData) {\n        slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);\n    } else {\n        slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);\n        if (slice.openStart || slice.openEnd) {\n            let openStart = 0, openEnd = 0;\n            for(let node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild){}\n            for(let node = slice.content.lastChild; openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild){}\n            slice = closeSlice(slice, openStart, openEnd);\n        }\n    }\n    view.someProp(\"transformPasted\", (f)=>{\n        slice = f(slice, view);\n    });\n    return slice;\n}\nconst inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\n// Takes a slice parsed with parseSlice, which means there hasn't been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don't\n// fit anywhere in the schema.\nfunction normalizeSiblings(fragment, $context) {\n    if (fragment.childCount < 2) return fragment;\n    for(let d = $context.depth; d >= 0; d--){\n        let parent = $context.node(d);\n        let match = parent.contentMatchAt($context.index(d));\n        let lastWrap, result = [];\n        fragment.forEach((node)=>{\n            if (!result) return;\n            let wrap = match.findWrapping(node.type), inLast;\n            if (!wrap) return result = null;\n            if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n                result[result.length - 1] = inLast;\n            } else {\n                if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);\n                let wrapped = withWrappers(node, wrap);\n                result.push(wrapped);\n                match = match.matchType(wrapped.type);\n                lastWrap = wrap;\n            }\n        });\n        if (result) return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(result);\n    }\n    return fragment;\n}\nfunction withWrappers(node, wrap, from = 0) {\n    for(let i = wrap.length - 1; i >= from; i--)node = wrap[i].create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node));\n    return node;\n}\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n    if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n        let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);\n        if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));\n        let match = sibling.contentMatchAt(sibling.childCount);\n        if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1])) return sibling.copy(sibling.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(withWrappers(node, wrap, depth + 1))));\n    }\n}\nfunction closeRight(node, depth) {\n    if (depth == 0) return node;\n    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n    let fill = node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n    return node.copy(fragment.append(fill));\n}\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;\n    if (fragment.childCount > 1) openEnd = 0;\n    if (depth < to - 1) inner = closeRange(inner, side, from, to, depth + 1, openEnd);\n    if (depth >= from) inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));\n}\nfunction closeSlice(slice, openStart, openEnd) {\n    if (openStart < slice.openStart) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);\n    if (openEnd < slice.openEnd) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);\n    return slice;\n}\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// \"<td>..</td>\"` the table cells are ignored.\nconst wrapMap = {\n    thead: [\n        \"table\"\n    ],\n    tbody: [\n        \"table\"\n    ],\n    tfoot: [\n        \"table\"\n    ],\n    caption: [\n        \"table\"\n    ],\n    colgroup: [\n        \"table\"\n    ],\n    col: [\n        \"table\",\n        \"colgroup\"\n    ],\n    tr: [\n        \"table\",\n        \"tbody\"\n    ],\n    td: [\n        \"table\",\n        \"tbody\",\n        \"tr\"\n    ],\n    th: [\n        \"table\",\n        \"tbody\",\n        \"tr\"\n    ]\n};\nlet _detachedDoc = null;\nfunction detachedDoc() {\n    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"));\n}\nfunction readHTML(html) {\n    let metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n    if (metas) html = html.slice(metas[0].length);\n    let elt = detachedDoc().createElement(\"div\");\n    let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap;\n    if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) html = wrap.map((n)=>\"<\" + n + \">\").join(\"\") + html + wrap.map((n)=>\"</\" + n + \">\").reverse().join(\"\");\n    elt.innerHTML = html;\n    if (wrap) for(let i = 0; i < wrap.length; i++)elt = elt.querySelector(wrap[i]) || elt;\n    return elt;\n}\n// Webkit browsers do some hard-to-predict replacement of regular\n// spaces with non-breaking spaces when putting content on the\n// clipboard. This tries to convert such non-breaking spaces (which\n// will be wrapped in a plain span on Chrome, a span with class\n// Apple-converted-space on Safari) back to regular spaces.\nfunction restoreReplacedSpaces(dom) {\n    let nodes = dom.querySelectorAll(chrome ? \"span:not([class]):not([style])\" : \"span.Apple-converted-space\");\n    for(let i = 0; i < nodes.length; i++){\n        let node = nodes[i];\n        if (node.childNodes.length == 1 && node.textContent == \"\\xa0\" && node.parentNode) node.parentNode.replaceChild(dom.ownerDocument.createTextNode(\" \"), node);\n    }\n}\nfunction addContext(slice, context) {\n    if (!slice.size) return slice;\n    let schema = slice.content.firstChild.type.schema, array;\n    try {\n        array = JSON.parse(context);\n    } catch (e) {\n        return slice;\n    }\n    let { content, openStart, openEnd } = slice;\n    for(let i = array.length - 2; i >= 0; i -= 2){\n        let type = schema.nodes[array[i]];\n        if (!type || type.hasRequiredAttrs()) break;\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(array[i + 1], content));\n        openStart++;\n        openEnd++;\n    }\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n}\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nconst handlers = {};\nconst editHandlers = {};\nconst passiveHandlers = {\n    touchstart: true,\n    touchmove: true\n};\nclass InputState {\n    constructor(){\n        this.shiftKey = false;\n        this.mouseDown = null;\n        this.lastKeyCode = null;\n        this.lastKeyCodeTime = 0;\n        this.lastClick = {\n            time: 0,\n            x: 0,\n            y: 0,\n            type: \"\"\n        };\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastIOSEnter = 0;\n        this.lastIOSEnterFallbackTimeout = -1;\n        this.lastFocus = 0;\n        this.lastTouch = 0;\n        this.lastAndroidDelete = 0;\n        this.composing = false;\n        this.composingTimeout = -1;\n        this.compositionNodes = [];\n        this.compositionEndedAt = -2e8;\n        this.compositionID = 1;\n        // Set to a composition ID when there are pending changes at compositionend\n        this.compositionPendingChanges = 0;\n        this.domChangeCount = 0;\n        this.eventHandlers = Object.create(null);\n        this.hideSelectionGuard = null;\n    }\n}\nfunction initInput(view) {\n    for(let event in handlers){\n        let handler = handlers[event];\n        view.dom.addEventListener(event, view.input.eventHandlers[event] = (event)=>{\n            if (eventBelongsToView(view, event) && !runCustomHandler(view, event) && (view.editable || !(event.type in editHandlers))) handler(view, event);\n        }, passiveHandlers[event] ? {\n            passive: true\n        } : undefined);\n    }\n    // On Safari, for reasons beyond my understanding, adding an input\n    // event handler makes an issue where the composition vanishes when\n    // you press enter go away.\n    if (safari) view.dom.addEventListener(\"input\", ()=>null);\n    ensureListeners(view);\n}\nfunction setSelectionOrigin(view, origin) {\n    view.input.lastSelectionOrigin = origin;\n    view.input.lastSelectionTime = Date.now();\n}\nfunction destroyInput(view) {\n    view.domObserver.stop();\n    for(let type in view.input.eventHandlers)view.dom.removeEventListener(type, view.input.eventHandlers[type]);\n    clearTimeout(view.input.composingTimeout);\n    clearTimeout(view.input.lastIOSEnterFallbackTimeout);\n}\nfunction ensureListeners(view) {\n    view.someProp(\"handleDOMEvents\", (currentHandlers)=>{\n        for(let type in currentHandlers)if (!view.input.eventHandlers[type]) view.dom.addEventListener(type, view.input.eventHandlers[type] = (event)=>runCustomHandler(view, event));\n    });\n}\nfunction runCustomHandler(view, event) {\n    return view.someProp(\"handleDOMEvents\", (handlers)=>{\n        let handler = handlers[event.type];\n        return handler ? handler(view, event) || event.defaultPrevented : false;\n    });\n}\nfunction eventBelongsToView(view, event) {\n    if (!event.bubbles) return true;\n    if (event.defaultPrevented) return false;\n    for(let node = event.target; node != view.dom; node = node.parentNode)if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event)) return false;\n    return true;\n}\nfunction dispatchEvent(view, event) {\n    if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) handlers[event.type](view, event);\n}\neditHandlers.keydown = (view, _event)=>{\n    let event = _event;\n    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;\n    if (inOrNearComposition(view, event)) return;\n    view.input.lastKeyCode = event.keyCode;\n    view.input.lastKeyCodeTime = Date.now();\n    // Suppress enter key events on Chrome Android, because those tend\n    // to be part of a confused sequence of composition events fired,\n    // and handling them eagerly tends to corrupt the input.\n    if (android && chrome && event.keyCode == 13) return;\n    if (event.keyCode != 229) view.domObserver.forceFlush();\n    // On iOS, if we preventDefault enter key presses, the virtual\n    // keyboard gets confused. So the hack here is to set a flag that\n    // makes the DOM change code recognize that what just happens should\n    // be replaced by whatever the Enter key handlers do.\n    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n        let now = Date.now();\n        view.input.lastIOSEnter = now;\n        view.input.lastIOSEnterFallbackTimeout = setTimeout(()=>{\n            if (view.input.lastIOSEnter == now) {\n                view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")));\n                view.input.lastIOSEnter = 0;\n            }\n        }, 200);\n    } else if (view.someProp(\"handleKeyDown\", (f)=>f(view, event)) || captureKeyDown(view, event)) {\n        event.preventDefault();\n    } else {\n        setSelectionOrigin(view, \"key\");\n    }\n};\neditHandlers.keyup = (view, event)=>{\n    if (event.keyCode == 16) view.input.shiftKey = false;\n};\neditHandlers.keypress = (view, _event)=>{\n    let event = _event;\n    if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey) return;\n    if (view.someProp(\"handleKeyPress\", (f)=>f(view, event))) {\n        event.preventDefault();\n        return;\n    }\n    let sel = view.state.selection;\n    if (!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || !sel.$from.sameParent(sel.$to)) {\n        let text = String.fromCharCode(event.charCode);\n        if (!/[\\r\\n]/.test(text) && !view.someProp(\"handleTextInput\", (f)=>f(view, sel.$from.pos, sel.$to.pos, text))) view.dispatch(view.state.tr.insertText(text).scrollIntoView());\n        event.preventDefault();\n    }\n};\nfunction eventCoords(event) {\n    return {\n        left: event.clientX,\n        top: event.clientY\n    };\n}\nfunction isNear(event, click) {\n    let dx = click.x - event.clientX, dy = click.y - event.clientY;\n    return dx * dx + dy * dy < 100;\n}\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n    if (inside == -1) return false;\n    let $pos = view.state.doc.resolve(inside);\n    for(let i = $pos.depth + 1; i > 0; i--){\n        if (view.someProp(propName, (f)=>i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false))) return true;\n    }\n    return false;\n}\nfunction updateSelection(view, selection, origin) {\n    if (!view.focused) view.focus();\n    let tr = view.state.tr.setSelection(selection);\n    if (origin == \"pointer\") tr.setMeta(\"pointer\", true);\n    view.dispatch(tr);\n}\nfunction selectClickedLeaf(view, inside) {\n    if (inside == -1) return false;\n    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n    if (node && node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n        updateSelection(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos), \"pointer\");\n        return true;\n    }\n    return false;\n}\nfunction selectClickedNode(view, inside) {\n    if (inside == -1) return false;\n    let sel = view.state.selection, selectedNode, selectAt;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) selectedNode = sel.node;\n    let $pos = view.state.doc.resolve(inside);\n    for(let i = $pos.depth + 1; i > 0; i--){\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n            if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) selectAt = $pos.before(sel.$from.depth);\n            else selectAt = $pos.before(i);\n            break;\n        }\n    }\n    if (selectAt != null) {\n        updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n        return true;\n    } else {\n        return false;\n    }\n}\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n    return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) || view.someProp(\"handleClick\", (f)=>f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));\n}\nfunction handleDoubleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) || view.someProp(\"handleDoubleClick\", (f)=>f(view, pos, event));\n}\nfunction handleTripleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) || view.someProp(\"handleTripleClick\", (f)=>f(view, pos, event)) || defaultTripleClick(view, inside, event);\n}\nfunction defaultTripleClick(view, inside, event) {\n    if (event.button != 0) return false;\n    let doc = view.state.doc;\n    if (inside == -1) {\n        if (doc.inlineContent) {\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, 0, doc.content.size), \"pointer\");\n            return true;\n        }\n        return false;\n    }\n    let $pos = doc.resolve(inside);\n    for(let i = $pos.depth + 1; i > 0; i--){\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        let nodePos = $pos.before(i);\n        if (node.inlineContent) updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\");\n        else if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(doc, nodePos), \"pointer\");\n        else continue;\n        return true;\n    }\n}\nfunction forceDOMFlush(view) {\n    return endComposition(view);\n}\nconst selectNodeModifier = mac ? \"metaKey\" : \"ctrlKey\";\nhandlers.mousedown = (view, _event)=>{\n    let event = _event;\n    view.input.shiftKey = event.shiftKey;\n    let flushed = forceDOMFlush(view);\n    let now = Date.now(), type = \"singleClick\";\n    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {\n        if (view.input.lastClick.type == \"singleClick\") type = \"doubleClick\";\n        else if (view.input.lastClick.type == \"doubleClick\") type = \"tripleClick\";\n    }\n    view.input.lastClick = {\n        time: now,\n        x: event.clientX,\n        y: event.clientY,\n        type\n    };\n    let pos = view.posAtCoords(eventCoords(event));\n    if (!pos) return;\n    if (type == \"singleClick\") {\n        if (view.input.mouseDown) view.input.mouseDown.done();\n        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);\n    } else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n        event.preventDefault();\n    } else {\n        setSelectionOrigin(view, \"pointer\");\n    }\n};\nclass MouseDown {\n    constructor(view, pos, event, flushed){\n        this.view = view;\n        this.pos = pos;\n        this.event = event;\n        this.flushed = flushed;\n        this.delayedSelectionSync = false;\n        this.mightDrag = null;\n        this.startDoc = view.state.doc;\n        this.selectNode = !!event[selectNodeModifier];\n        this.allowDefault = event.shiftKey;\n        let targetNode, targetPos;\n        if (pos.inside > -1) {\n            targetNode = view.state.doc.nodeAt(pos.inside);\n            targetPos = pos.inside;\n        } else {\n            let $pos = view.state.doc.resolve(pos.pos);\n            targetNode = $pos.parent;\n            targetPos = $pos.depth ? $pos.before() : 0;\n        }\n        const target = flushed ? null : event.target;\n        const targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n        this.target = targetDesc ? targetDesc.dom : null;\n        let { selection } = view.state;\n        if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && selection.from <= targetPos && selection.to > targetPos) this.mightDrag = {\n            node: targetNode,\n            pos: targetPos,\n            addAttr: !!(this.target && !this.target.draggable),\n            setUneditable: !!(this.target && gecko && !this.target.hasAttribute(\"contentEditable\"))\n        };\n        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr) this.target.draggable = true;\n            if (this.mightDrag.setUneditable) setTimeout(()=>{\n                if (this.view.input.mouseDown == this) this.target.setAttribute(\"contentEditable\", \"false\");\n            }, 20);\n            this.view.domObserver.start();\n        }\n        view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        setSelectionOrigin(view, \"pointer\");\n    }\n    done() {\n        this.view.root.removeEventListener(\"mouseup\", this.up);\n        this.view.root.removeEventListener(\"mousemove\", this.move);\n        if (this.mightDrag && this.target) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr) this.target.removeAttribute(\"draggable\");\n            if (this.mightDrag.setUneditable) this.target.removeAttribute(\"contentEditable\");\n            this.view.domObserver.start();\n        }\n        if (this.delayedSelectionSync) setTimeout(()=>selectionToDOM(this.view));\n        this.view.input.mouseDown = null;\n    }\n    up(event) {\n        this.done();\n        if (!this.view.dom.contains(event.target)) return;\n        let pos = this.pos;\n        if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event));\n        this.updateAllowDefault(event);\n        if (this.allowDefault || !pos) {\n            setSelectionOrigin(this.view, \"pointer\");\n        } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n            event.preventDefault();\n        } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements\n        safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a\n        // cursor, but still report that the node is selected\n        // when asked through getSelection. You'll then get a\n        // situation where clicking at the point where that\n        // (hidden) cursor is doesn't change the selection, and\n        // thus doesn't get a reaction from ProseMirror. This\n        // works around that.\n        chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {\n            updateSelection(this.view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\");\n            event.preventDefault();\n        } else {\n            setSelectionOrigin(this.view, \"pointer\");\n        }\n    }\n    move(event) {\n        this.updateAllowDefault(event);\n        setSelectionOrigin(this.view, \"pointer\");\n        if (event.buttons == 0) this.done();\n    }\n    updateAllowDefault(event) {\n        if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) this.allowDefault = true;\n    }\n}\nhandlers.touchstart = (view)=>{\n    view.input.lastTouch = Date.now();\n    forceDOMFlush(view);\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.touchmove = (view)=>{\n    view.input.lastTouch = Date.now();\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.contextmenu = (view)=>forceDOMFlush(view);\nfunction inOrNearComposition(view, event) {\n    if (view.composing) return true;\n    // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n    // On Japanese input method editors (IMEs), the Enter key is used to confirm character\n    // selection. On Safari, when Enter is pressed, compositionend and keydown events are\n    // emitted. The keydown event triggers newline insertion, which we don't want.\n    // This method returns true if the keydown event should be ignored.\n    // We only ignore it once, as pressing Enter a second time *should* insert a newline.\n    // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.\n    // This guards against the case where compositionend is triggered without the keyboard\n    // (e.g. character confirmation may be done with the mouse), and keydown is triggered\n    // afterwards- we wouldn't want to ignore the keydown event in this case.\n    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {\n        view.input.compositionEndedAt = -2e8;\n        return true;\n    }\n    return false;\n}\n// Drop active composition after 5 seconds of inactivity on Android\nconst timeoutComposition = android ? 5000 : -1;\neditHandlers.compositionstart = editHandlers.compositionupdate = (view)=>{\n    if (!view.composing) {\n        view.domObserver.flush();\n        let { state } = view, $pos = state.selection.$from;\n        if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m)=>m.type.spec.inclusive === false))) {\n            // Need to wrap the cursor in mark nodes different from the ones in the DOM context\n            view.markCursor = view.state.storedMarks || $pos.marks();\n            endComposition(view, true);\n            view.markCursor = null;\n        } else {\n            endComposition(view);\n            // In firefox, if the cursor is after but outside a marked node,\n            // the inserted text won't inherit the marks. So this moves it\n            // inside if necessary.\n            if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n                let sel = view.domSelectionRange();\n                for(let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;){\n                    let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n                    if (!before) break;\n                    if (before.nodeType == 3) {\n                        view.domSelection().collapse(before, before.nodeValue.length);\n                        break;\n                    } else {\n                        node = before;\n                        offset = -1;\n                    }\n                }\n            }\n        }\n        view.input.composing = true;\n    }\n    scheduleComposeEnd(view, timeoutComposition);\n};\neditHandlers.compositionend = (view, event)=>{\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = event.timeStamp;\n        view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;\n        if (view.input.compositionPendingChanges) Promise.resolve().then(()=>view.domObserver.flush());\n        view.input.compositionID++;\n        scheduleComposeEnd(view, 20);\n    }\n};\nfunction scheduleComposeEnd(view, delay) {\n    clearTimeout(view.input.composingTimeout);\n    if (delay > -1) view.input.composingTimeout = setTimeout(()=>endComposition(view), delay);\n}\nfunction clearComposition(view) {\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = timestampFromCustomEvent();\n    }\n    while(view.input.compositionNodes.length > 0)view.input.compositionNodes.pop().markParentsDirty();\n}\nfunction timestampFromCustomEvent() {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"event\", true, true);\n    return event.timeStamp;\n}\n/**\n@internal\n*/ function endComposition(view, forceUpdate = false) {\n    if (android && view.domObserver.flushingSoon >= 0) return;\n    view.domObserver.forceFlush();\n    clearComposition(view);\n    if (forceUpdate || view.docView && view.docView.dirty) {\n        let sel = selectionFromDOM(view);\n        if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel));\n        else view.updateState(view.state);\n        return true;\n    }\n    return false;\n}\nfunction captureCopy(view, dom) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    if (!view.dom.parentNode) return;\n    let wrap = view.dom.parentNode.appendChild(document.createElement(\"div\"));\n    wrap.appendChild(dom);\n    wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    let sel = getSelection(), range = document.createRange();\n    range.selectNodeContents(dom);\n    // Done because IE will fire a selectionchange moving the selection\n    // to its start when removeAllRanges is called and the editor still\n    // has focus (which will mess up the editor's selection state).\n    view.dom.blur();\n    sel.removeAllRanges();\n    sel.addRange(range);\n    setTimeout(()=>{\n        if (wrap.parentNode) wrap.parentNode.removeChild(wrap);\n        view.focus();\n    }, 50);\n}\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard APIall the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;\nhandlers.copy = editHandlers.cut = (view, _event)=>{\n    let event = _event;\n    let sel = view.state.selection, cut = event.type == \"cut\";\n    if (sel.empty) return;\n    // IE and Edge's clipboard interface is completely broken\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let slice = sel.content(), { dom, text } = serializeForClipboard(view, slice);\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData(\"text/html\", dom.innerHTML);\n        data.setData(\"text/plain\", text);\n    } else {\n        captureCopy(view, dom);\n    }\n    if (cut) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"));\n};\nfunction sliceSingleNode(slice) {\n    return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;\n}\nfunction capturePaste(view, event) {\n    if (!view.dom.parentNode) return;\n    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;\n    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"));\n    if (!plainText) target.contentEditable = \"true\";\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    setTimeout(()=>{\n        view.focus();\n        if (target.parentNode) target.parentNode.removeChild(target);\n        if (plainText) doPaste(view, target.value, null, plain, event);\n        else doPaste(view, target.textContent, target.innerHTML, plain, event);\n    }, 50);\n}\nfunction doPaste(view, text, html, preferPlain, event) {\n    let slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);\n    if (view.someProp(\"handlePaste\", (f)=>f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty))) return true;\n    if (!slice) return false;\n    let singleNode = sliceSingleNode(slice);\n    let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice);\n    view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n    return true;\n}\nfunction getText(clipboardData) {\n    let text = clipboardData.getData(\"text/plain\") || clipboardData.getData(\"Text\");\n    if (text) return text;\n    let uris = clipboardData.getData(\"text/uri-list\");\n    return uris ? uris.replace(/\\r?\\n/g, \" \") : \"\";\n}\neditHandlers.paste = (view, _event)=>{\n    let event = _event;\n    // Handling paste from JavaScript during composition is very poorly\n    // handled by browsers, so as a dodgy but preferable kludge, we just\n    // let the browser do its native thing there, except on Android,\n    // where the editor is almost always composing.\n    if (view.composing && !android) return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    if (data && doPaste(view, getText(data), data.getData(\"text/html\"), plain, event)) event.preventDefault();\n    else capturePaste(view, event);\n};\nclass Dragging {\n    constructor(slice, move, node){\n        this.slice = slice;\n        this.move = move;\n        this.node = node;\n    }\n}\nconst dragCopyModifier = mac ? \"altKey\" : \"ctrlKey\";\nhandlers.dragstart = (view, _event)=>{\n    let event = _event;\n    let mouseDown = view.input.mouseDown;\n    if (mouseDown) mouseDown.done();\n    if (!event.dataTransfer) return;\n    let sel = view.state.selection;\n    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));\n    let node;\n    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection ? sel.to - 1 : sel.to)) ;\n    else if (mouseDown && mouseDown.mightDrag) {\n        node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);\n    } else if (event.target && event.target.nodeType == 1) {\n        let desc = view.docView.nearestDesc(event.target, true);\n        if (desc && desc.node.type.spec.draggable && desc != view.docView) node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, desc.posBefore);\n    }\n    let slice = (node || view.state.selection).content(), { dom, text } = serializeForClipboard(view, slice);\n    event.dataTransfer.clearData();\n    event.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n    // See https://github.com/ProseMirror/prosemirror/issues/1156\n    event.dataTransfer.effectAllowed = \"copyMove\";\n    if (!brokenClipboardAPI) event.dataTransfer.setData(\"text/plain\", text);\n    view.dragging = new Dragging(slice, !event[dragCopyModifier], node);\n};\nhandlers.dragend = (view)=>{\n    let dragging = view.dragging;\n    window.setTimeout(()=>{\n        if (view.dragging == dragging) view.dragging = null;\n    }, 50);\n};\neditHandlers.dragover = editHandlers.dragenter = (_, e)=>e.preventDefault();\neditHandlers.drop = (view, _event)=>{\n    let event = _event;\n    let dragging = view.dragging;\n    view.dragging = null;\n    if (!event.dataTransfer) return;\n    let eventPos = view.posAtCoords(eventCoords(event));\n    if (!eventPos) return;\n    let $mouse = view.state.doc.resolve(eventPos.pos);\n    let slice = dragging && dragging.slice;\n    if (slice) {\n        view.someProp(\"transformPasted\", (f)=>{\n            slice = f(slice, view);\n        });\n    } else {\n        slice = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData(\"text/html\"), false, $mouse);\n    }\n    let move = !!(dragging && !event[dragCopyModifier]);\n    if (view.someProp(\"handleDrop\", (f)=>f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, move))) {\n        event.preventDefault();\n        return;\n    }\n    if (!slice) return;\n    event.preventDefault();\n    let insertPos = slice ? (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__.dropPoint)(view.state.doc, $mouse.pos, slice) : $mouse.pos;\n    if (insertPos == null) insertPos = $mouse.pos;\n    let tr = view.state.tr;\n    if (move) {\n        let { node } = dragging;\n        if (node) node.replace(tr);\n        else tr.deleteSelection();\n    }\n    let pos = tr.mapping.map(insertPos);\n    let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;\n    let beforeInsert = tr.doc;\n    if (isNode) tr.replaceRangeWith(pos, pos, slice.content.firstChild);\n    else tr.replaceRange(pos, pos, slice);\n    if (tr.doc.eq(beforeInsert)) return;\n    let $pos = tr.doc.resolve(pos);\n    if (isNode && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n        tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos));\n    } else {\n        let end = tr.mapping.map(insertPos);\n        tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo)=>end = newTo);\n        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n    }\n    view.focus();\n    view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n};\nhandlers.focus = (view)=>{\n    view.input.lastFocus = Date.now();\n    if (!view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.add(\"ProseMirror-focused\");\n        view.domObserver.start();\n        view.focused = true;\n        setTimeout(()=>{\n            if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange())) selectionToDOM(view);\n        }, 20);\n    }\n};\nhandlers.blur = (view, _event)=>{\n    let event = _event;\n    if (view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.remove(\"ProseMirror-focused\");\n        view.domObserver.start();\n        if (event.relatedTarget && view.dom.contains(event.relatedTarget)) view.domObserver.currentSelection.clear();\n        view.focused = false;\n    }\n};\nhandlers.beforeinput = (view, _event)=>{\n    let event = _event;\n    // We should probably do more with beforeinput events, but support\n    // is so spotty that I'm still waiting to see where they are going.\n    // Very specific hack to deal with backspace sometimes failing on\n    // Chrome Android when after an uneditable node.\n    if (chrome && android && event.inputType == \"deleteContentBackward\") {\n        view.domObserver.flushSoon();\n        let { domChangeCount } = view.input;\n        setTimeout(()=>{\n            if (view.input.domChangeCount != domChangeCount) return; // Event already had some effect\n            // This bug tends to close the virtual keyboard, so we refocus\n            view.dom.blur();\n            view.focus();\n            if (view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(8, \"Backspace\")))) return;\n            let { $cursor } = view.state.selection;\n            // Crude approximation of backspace behavior when no command handled it\n            if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());\n        }, 50);\n    }\n};\n// Make sure all handlers get registered\nfor(let prop in editHandlers)handlers[prop] = editHandlers[prop];\nfunction compareObjs(a, b) {\n    if (a == b) return true;\n    for(let p in a)if (a[p] !== b[p]) return false;\n    for(let p in b)if (!(p in a)) return false;\n    return true;\n}\nclass WidgetType {\n    constructor(toDOM, spec){\n        this.toDOM = toDOM;\n        this.spec = spec || noSpec;\n        this.side = this.spec.side || 0;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n        return deleted ? null : new Decoration(pos - offset, pos - offset, this);\n    }\n    valid() {\n        return true;\n    }\n    eq(other) {\n        return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));\n    }\n    destroy(node) {\n        if (this.spec.destroy) this.spec.destroy(node);\n    }\n}\nclass InlineType {\n    constructor(attrs, spec){\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n        let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n        return from >= to ? null : new Decoration(from, to, this);\n    }\n    valid(_, span) {\n        return span.from < span.to;\n    }\n    eq(other) {\n        return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n    static is(span) {\n        return span.type instanceof InlineType;\n    }\n    destroy() {}\n}\nclass NodeType {\n    constructor(attrs, spec){\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.mapResult(span.from + oldOffset, 1);\n        if (from.deleted) return null;\n        let to = mapping.mapResult(span.to + oldOffset, -1);\n        if (to.deleted || to.pos <= from.pos) return null;\n        return new Decoration(from.pos - offset, to.pos - offset, this);\n    }\n    valid(node, span) {\n        let { index, offset } = node.content.findIndex(span.from), child;\n        return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;\n    }\n    eq(other) {\n        return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n    destroy() {}\n}\n/**\nDecoration objects can be provided to the view through the\n[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in\nseveral variantssee the static members of this class for details.\n*/ class Decoration {\n    /**\n    @internal\n    */ constructor(/**\n    The start position of the decoration.\n    */ from, /**\n    The end position. Will be the same as `from` for [widget\n    decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).\n    */ to, /**\n    @internal\n    */ type){\n        this.from = from;\n        this.to = to;\n        this.type = type;\n    }\n    /**\n    @internal\n    */ copy(from, to) {\n        return new Decoration(from, to, this.type);\n    }\n    /**\n    @internal\n    */ eq(other, offset = 0) {\n        return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;\n    }\n    /**\n    @internal\n    */ map(mapping, offset, oldOffset) {\n        return this.type.map(mapping, this, offset, oldOffset);\n    }\n    /**\n    Creates a widget decoration, which is a DOM node that's shown in\n    the document at the given position. It is recommended that you\n    delay rendering the widget by passing a function that will be\n    called when the widget is actually drawn in a view, but you can\n    also directly pass a DOM node. `getPos` can be used to find the\n    widget's current document position.\n    */ static widget(pos, toDOM, spec) {\n        return new Decoration(pos, pos, new WidgetType(toDOM, spec));\n    }\n    /**\n    Creates an inline decoration, which adds the given attributes to\n    each inline node between `from` and `to`.\n    */ static inline(from, to, attrs, spec) {\n        return new Decoration(from, to, new InlineType(attrs, spec));\n    }\n    /**\n    Creates a node decoration. `from` and `to` should point precisely\n    before and after a node in the document. That node, and only that\n    node, will receive the given attributes.\n    */ static node(from, to, attrs, spec) {\n        return new Decoration(from, to, new NodeType(attrs, spec));\n    }\n    /**\n    The spec provided when creating this decoration. Can be useful\n    if you've stored extra information in that object.\n    */ get spec() {\n        return this.type.spec;\n    }\n    /**\n    @internal\n    */ get inline() {\n        return this.type instanceof InlineType;\n    }\n    /**\n    @internal\n    */ get widget() {\n        return this.type instanceof WidgetType;\n    }\n}\nconst none = [], noSpec = {};\n/**\nA collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such\na way that the drawing algorithm can efficiently use and compare\nthem. This is a persistent data structureit is not modified,\nupdates create a new value.\n*/ class DecorationSet {\n    /**\n    @internal\n    */ constructor(local, children){\n        this.local = local.length ? local : none;\n        this.children = children.length ? children : none;\n    }\n    /**\n    Create a set of decorations, using the structure of the given\n    document. This will consume (modify) the `decorations` array, so\n    you must make a copy if you want need to preserve that.\n    */ static create(doc, decorations) {\n        return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;\n    }\n    /**\n    Find all decorations in this set which touch the given range\n    (including decorations that start or end directly at the\n    boundaries) and match the given predicate on their spec. When\n    `start` and `end` are omitted, all decorations in the set are\n    considered. When `predicate` isn't given, all decorations are\n    assumed to match.\n    */ find(start, end, predicate) {\n        let result = [];\n        this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n        return result;\n    }\n    findInner(start, end, result, offset, predicate) {\n        for(let i = 0; i < this.local.length; i++){\n            let span = this.local[i];\n            if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec))) result.push(span.copy(span.from + offset, span.to + offset));\n        }\n        for(let i = 0; i < this.children.length; i += 3){\n            if (this.children[i] < end && this.children[i + 1] > start) {\n                let childOff = this.children[i] + 1;\n                this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n            }\n        }\n    }\n    /**\n    Map the set of decorations in response to a change in the\n    document.\n    */ map(mapping, doc, options) {\n        if (this == empty || mapping.maps.length == 0) return this;\n        return this.mapInner(mapping, doc, 0, 0, options || noSpec);\n    }\n    /**\n    @internal\n    */ mapInner(mapping, node, offset, oldOffset, options) {\n        let newLocal;\n        for(let i = 0; i < this.local.length; i++){\n            let mapped = this.local[i].map(mapping, offset, oldOffset);\n            if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped);\n            else if (options.onRemove) options.onRemove(this.local[i].spec);\n        }\n        if (this.children.length) return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);\n        else return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;\n    }\n    /**\n    Add the given array of decorations to the ones in the set,\n    producing a new set. Consumes the `decorations` array. Needs\n    access to the current document to create the appropriate tree\n    structure.\n    */ add(doc, decorations) {\n        if (!decorations.length) return this;\n        if (this == empty) return DecorationSet.create(doc, decorations);\n        return this.addInner(doc, decorations, 0);\n    }\n    addInner(doc, decorations, offset) {\n        let children, childIndex = 0;\n        doc.forEach((childNode, childOffset)=>{\n            let baseOffset = childOffset + offset, found;\n            if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) return;\n            if (!children) children = this.children.slice();\n            while(childIndex < children.length && children[childIndex] < childOffset)childIndex += 3;\n            if (children[childIndex] == childOffset) children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);\n            else children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));\n            childIndex += 3;\n        });\n        let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n        for(let i = 0; i < local.length; i++)if (!local[i].type.valid(doc, local[i])) local.splice(i--, 1);\n        return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);\n    }\n    /**\n    Create a new set that contains the decorations in this set, minus\n    the ones in the given array.\n    */ remove(decorations) {\n        if (decorations.length == 0 || this == empty) return this;\n        return this.removeInner(decorations, 0);\n    }\n    removeInner(decorations, offset) {\n        let children = this.children, local = this.local;\n        for(let i = 0; i < children.length; i += 3){\n            let found;\n            let from = children[i] + offset, to = children[i + 1] + offset;\n            for(let j = 0, span; j < decorations.length; j++)if (span = decorations[j]) {\n                if (span.from > from && span.to < to) {\n                    decorations[j] = null;\n                    (found || (found = [])).push(span);\n                }\n            }\n            if (!found) continue;\n            if (children == this.children) children = this.children.slice();\n            let removed = children[i + 2].removeInner(found, from + 1);\n            if (removed != empty) {\n                children[i + 2] = removed;\n            } else {\n                children.splice(i, 3);\n                i -= 3;\n            }\n        }\n        if (local.length) {\n            for(let i = 0, span; i < decorations.length; i++)if (span = decorations[i]) {\n                for(let j = 0; j < local.length; j++)if (local[j].eq(span, offset)) {\n                    if (local == this.local) local = this.local.slice();\n                    local.splice(j--, 1);\n                }\n            }\n        }\n        if (children == this.children && local == this.local) return this;\n        return local.length || children.length ? new DecorationSet(local, children) : empty;\n    }\n    /**\n    @internal\n    */ forChild(offset, node) {\n        if (this == empty) return this;\n        if (node.isLeaf) return DecorationSet.empty;\n        let child, local;\n        for(let i = 0; i < this.children.length; i += 3)if (this.children[i] >= offset) {\n            if (this.children[i] == offset) child = this.children[i + 2];\n            break;\n        }\n        let start = offset + 1, end = start + node.content.size;\n        for(let i = 0; i < this.local.length; i++){\n            let dec = this.local[i];\n            if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {\n                let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n                if (from < to) (local || (local = [])).push(dec.copy(from, to));\n            }\n        }\n        if (local) {\n            let localSet = new DecorationSet(local.sort(byPos), none);\n            return child ? new DecorationGroup([\n                localSet,\n                child\n            ]) : localSet;\n        }\n        return child || empty;\n    }\n    /**\n    @internal\n    */ eq(other) {\n        if (this == other) return true;\n        if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) return false;\n        for(let i = 0; i < this.local.length; i++)if (!this.local[i].eq(other.local[i])) return false;\n        for(let i = 0; i < this.children.length; i += 3)if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2])) return false;\n        return true;\n    }\n    /**\n    @internal\n    */ locals(node) {\n        return removeOverlap(this.localsInner(node));\n    }\n    /**\n    @internal\n    */ localsInner(node) {\n        if (this == empty) return none;\n        if (node.inlineContent || !this.local.some(InlineType.is)) return this.local;\n        let result = [];\n        for(let i = 0; i < this.local.length; i++){\n            if (!(this.local[i].type instanceof InlineType)) result.push(this.local[i]);\n        }\n        return result;\n    }\n}\n/**\nThe empty set of decorations.\n*/ DecorationSet.empty = new DecorationSet([], []);\n/**\n@internal\n*/ DecorationSet.removeOverlap = removeOverlap;\nconst empty = DecorationSet.empty;\n// An abstraction that allows the code dealing with decorations to\n// treat multiple DecorationSet objects as if it were a single object\n// with (a subset of) the same interface.\nclass DecorationGroup {\n    constructor(members){\n        this.members = members;\n    }\n    map(mapping, doc) {\n        const mappedDecos = this.members.map((member)=>member.map(mapping, doc, noSpec));\n        return DecorationGroup.from(mappedDecos);\n    }\n    forChild(offset, child) {\n        if (child.isLeaf) return DecorationSet.empty;\n        let found = [];\n        for(let i = 0; i < this.members.length; i++){\n            let result = this.members[i].forChild(offset, child);\n            if (result == empty) continue;\n            if (result instanceof DecorationGroup) found = found.concat(result.members);\n            else found.push(result);\n        }\n        return DecorationGroup.from(found);\n    }\n    eq(other) {\n        if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) return false;\n        for(let i = 0; i < this.members.length; i++)if (!this.members[i].eq(other.members[i])) return false;\n        return true;\n    }\n    locals(node) {\n        let result, sorted = true;\n        for(let i = 0; i < this.members.length; i++){\n            let locals = this.members[i].localsInner(node);\n            if (!locals.length) continue;\n            if (!result) {\n                result = locals;\n            } else {\n                if (sorted) {\n                    result = result.slice();\n                    sorted = false;\n                }\n                for(let j = 0; j < locals.length; j++)result.push(locals[j]);\n            }\n        }\n        return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;\n    }\n    // Create a group for the given array of decoration sets, or return\n    // a single set when possible.\n    static from(members) {\n        switch(members.length){\n            case 0:\n                return empty;\n            case 1:\n                return members[0];\n            default:\n                return new DecorationGroup(members.every((m)=>m instanceof DecorationSet) ? members : members.reduce((r, m)=>r.concat(m instanceof DecorationSet ? m : m.members), []));\n        }\n    }\n}\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n    let children = oldChildren.slice();\n    // Mark the children that are directly touched by changes, and\n    // move those that are after the changes.\n    for(let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++){\n        let moved = 0;\n        mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd)=>{\n            let dSize = newEnd - newStart - (oldEnd - oldStart);\n            for(let i = 0; i < children.length; i += 3){\n                let end = children[i + 1];\n                if (end < 0 || oldStart > end + baseOffset - moved) continue;\n                let start = children[i] + baseOffset - moved;\n                if (oldEnd >= start) {\n                    children[i + 1] = oldStart <= start ? -2 : -1;\n                } else if (oldStart >= baseOffset && dSize) {\n                    children[i] += dSize;\n                    children[i + 1] += dSize;\n                }\n            }\n            moved += dSize;\n        });\n        baseOffset = mapping.maps[i].map(baseOffset, -1);\n    }\n    // Find the child nodes that still correspond to a single node,\n    // recursively call mapInner on them and update their positions.\n    let mustRebuild = false;\n    for(let i = 0; i < children.length; i += 3)if (children[i + 1] < 0) {\n        if (children[i + 1] == -2) {\n            mustRebuild = true;\n            children[i + 1] = -1;\n            continue;\n        }\n        let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset;\n        if (fromLocal < 0 || fromLocal >= node.content.size) {\n            mustRebuild = true;\n            continue;\n        }\n        // Must read oldChildren because children was tagged with -1\n        let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;\n        let { index, offset: childOffset } = node.content.findIndex(fromLocal);\n        let childNode = node.maybeChild(index);\n        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n            let mapped = children[i + 2].mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options);\n            if (mapped != empty) {\n                children[i] = fromLocal;\n                children[i + 1] = toLocal;\n                children[i + 2] = mapped;\n            } else {\n                children[i + 1] = -2;\n                mustRebuild = true;\n            }\n        } else {\n            mustRebuild = true;\n        }\n    }\n    // Remaining children must be collected and rebuilt into the appropriate structure\n    if (mustRebuild) {\n        let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);\n        let built = buildTree(decorations, node, 0, options);\n        newLocal = built.local;\n        for(let i = 0; i < children.length; i += 3)if (children[i + 1] < 0) {\n            children.splice(i, 3);\n            i -= 3;\n        }\n        for(let i = 0, j = 0; i < built.children.length; i += 3){\n            let from = built.children[i];\n            while(j < children.length && children[j] < from)j += 3;\n            children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);\n        }\n    }\n    return new DecorationSet(newLocal.sort(byPos), children);\n}\nfunction moveSpans(spans, offset) {\n    if (!offset || !spans.length) return spans;\n    let result = [];\n    for(let i = 0; i < spans.length; i++){\n        let span = spans[i];\n        result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n    }\n    return result;\n}\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n    // Gather all decorations from the remaining marked children\n    function gather(set, oldOffset) {\n        for(let i = 0; i < set.local.length; i++){\n            let mapped = set.local[i].map(mapping, offset, oldOffset);\n            if (mapped) decorations.push(mapped);\n            else if (options.onRemove) options.onRemove(set.local[i].spec);\n        }\n        for(let i = 0; i < set.children.length; i += 3)gather(set.children[i + 2], set.children[i] + oldOffset + 1);\n    }\n    for(let i = 0; i < children.length; i += 3)if (children[i + 1] == -1) gather(children[i + 2], oldChildren[i] + oldOffset + 1);\n    return decorations;\n}\nfunction takeSpansForNode(spans, node, offset) {\n    if (node.isLeaf) return null;\n    let end = offset + node.nodeSize, found = null;\n    for(let i = 0, span; i < spans.length; i++){\n        if ((span = spans[i]) && span.from > offset && span.to < end) {\n            (found || (found = [])).push(span);\n            spans[i] = null;\n        }\n    }\n    return found;\n}\nfunction withoutNulls(array) {\n    let result = [];\n    for(let i = 0; i < array.length; i++)if (array[i] != null) result.push(array[i]);\n    return result;\n}\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtracted from the `from` and `to`\n// positions in the spans (so that we don't have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n    let children = [], hasNulls = false;\n    node.forEach((childNode, localStart)=>{\n        let found = takeSpansForNode(spans, childNode, localStart + offset);\n        if (found) {\n            hasNulls = true;\n            let subtree = buildTree(found, childNode, offset + localStart + 1, options);\n            if (subtree != empty) children.push(localStart, localStart + childNode.nodeSize, subtree);\n        }\n    });\n    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n    for(let i = 0; i < locals.length; i++)if (!locals[i].type.valid(node, locals[i])) {\n        if (options.onRemove) options.onRemove(locals[i].spec);\n        locals.splice(i--, 1);\n    }\n    return locals.length || children.length ? new DecorationSet(locals, children) : empty;\n}\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n    return a.from - b.from || a.to - b.to;\n}\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n    let working = spans;\n    for(let i = 0; i < working.length - 1; i++){\n        let span = working[i];\n        if (span.from != span.to) for(let j = i + 1; j < working.length; j++){\n            let next = working[j];\n            if (next.from == span.from) {\n                if (next.to != span.to) {\n                    if (working == spans) working = spans.slice();\n                    // Followed by a partially overlapping larger span. Split that\n                    // span.\n                    working[j] = next.copy(next.from, span.to);\n                    insertAhead(working, j + 1, next.copy(span.to, next.to));\n                }\n                continue;\n            } else {\n                if (next.from < span.to) {\n                    if (working == spans) working = spans.slice();\n                    // The end of this one overlaps with a subsequent span. Split\n                    // this one.\n                    working[i] = span.copy(span.from, next.from);\n                    insertAhead(working, j, span.copy(next.from, span.to));\n                }\n                break;\n            }\n        }\n    }\n    return working;\n}\nfunction insertAhead(array, i, deco) {\n    while(i < array.length && byPos(deco, array[i]) > 0)i++;\n    array.splice(i, 0, deco);\n}\n// Get the decorations associated with the current props of a view.\nfunction viewDecorations(view) {\n    let found = [];\n    view.someProp(\"decorations\", (f)=>{\n        let result = f(view.state);\n        if (result && result != empty) found.push(result);\n    });\n    if (view.cursorWrapper) found.push(DecorationSet.create(view.state.doc, [\n        view.cursorWrapper.deco\n    ]));\n    return DecorationGroup.from(found);\n}\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true,\n    attributes: true,\n    attributeOldValue: true,\n    subtree: true\n};\n// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified\nconst useCharData = ie && ie_version <= 11;\nclass SelectionState {\n    constructor(){\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    set(sel) {\n        this.anchorNode = sel.anchorNode;\n        this.anchorOffset = sel.anchorOffset;\n        this.focusNode = sel.focusNode;\n        this.focusOffset = sel.focusOffset;\n    }\n    clear() {\n        this.anchorNode = this.focusNode = null;\n    }\n    eq(sel) {\n        return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;\n    }\n}\nclass DOMObserver {\n    constructor(view, handleDOMChange){\n        this.view = view;\n        this.handleDOMChange = handleDOMChange;\n        this.queue = [];\n        this.flushingSoon = -1;\n        this.observer = null;\n        this.currentSelection = new SelectionState;\n        this.onCharData = null;\n        this.suppressingSelectionUpdates = false;\n        this.observer = window.MutationObserver && new window.MutationObserver((mutations)=>{\n            for(let i = 0; i < mutations.length; i++)this.queue.push(mutations[i]);\n            // IE11 will sometimes (on backspacing out a single character\n            // text node after a BR node) call the observer callback\n            // before actually updating the DOM, which will cause\n            // ProseMirror to miss the change (see #930)\n            if (ie && ie_version <= 11 && mutations.some((m)=>m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();\n            else this.flush();\n        });\n        if (useCharData) {\n            this.onCharData = (e)=>{\n                this.queue.push({\n                    target: e.target,\n                    type: \"characterData\",\n                    oldValue: e.prevValue\n                });\n                this.flushSoon();\n            };\n        }\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    flushSoon() {\n        if (this.flushingSoon < 0) this.flushingSoon = window.setTimeout(()=>{\n            this.flushingSoon = -1;\n            this.flush();\n        }, 20);\n    }\n    forceFlush() {\n        if (this.flushingSoon > -1) {\n            window.clearTimeout(this.flushingSoon);\n            this.flushingSoon = -1;\n            this.flush();\n        }\n    }\n    start() {\n        if (this.observer) {\n            this.observer.takeRecords();\n            this.observer.observe(this.view.dom, observeOptions);\n        }\n        if (this.onCharData) this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.connectSelection();\n    }\n    stop() {\n        if (this.observer) {\n            let take = this.observer.takeRecords();\n            if (take.length) {\n                for(let i = 0; i < take.length; i++)this.queue.push(take[i]);\n                window.setTimeout(()=>this.flush(), 20);\n            }\n            this.observer.disconnect();\n        }\n        if (this.onCharData) this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.disconnectSelection();\n    }\n    connectSelection() {\n        this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    disconnectSelection() {\n        this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    suppressSelectionUpdates() {\n        this.suppressingSelectionUpdates = true;\n        setTimeout(()=>this.suppressingSelectionUpdates = false, 50);\n    }\n    onSelectionChange() {\n        if (!hasFocusAndSelection(this.view)) return;\n        if (this.suppressingSelectionUpdates) return selectionToDOM(this.view);\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        if (ie && ie_version <= 11 && !this.view.state.selection.empty) {\n            let sel = this.view.domSelectionRange();\n            // Selection.isCollapsed isn't reliable on IE\n            if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) return this.flushSoon();\n        }\n        this.flush();\n    }\n    setCurSelection() {\n        this.currentSelection.set(this.view.domSelectionRange());\n    }\n    ignoreSelectionChange(sel) {\n        if (!sel.focusNode) return true;\n        let ancestors = new Set, container;\n        for(let scan = sel.focusNode; scan; scan = parentNode(scan))ancestors.add(scan);\n        for(let scan = sel.anchorNode; scan; scan = parentNode(scan))if (ancestors.has(scan)) {\n            container = scan;\n            break;\n        }\n        let desc = container && this.view.docView.nearestDesc(container);\n        if (desc && desc.ignoreMutation({\n            type: \"selection\",\n            target: container.nodeType == 3 ? container.parentNode : container\n        })) {\n            this.setCurSelection();\n            return true;\n        }\n    }\n    pendingRecords() {\n        if (this.observer) for (let mut of this.observer.takeRecords())this.queue.push(mut);\n        return this.queue;\n    }\n    flush() {\n        let { view } = this;\n        if (!view.docView || this.flushingSoon > -1) return;\n        let mutations = this.pendingRecords();\n        if (mutations.length) this.queue = [];\n        let sel = view.domSelectionRange();\n        let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);\n        let from = -1, to = -1, typeOver = false, added = [];\n        if (view.editable) {\n            for(let i = 0; i < mutations.length; i++){\n                let result = this.registerMutation(mutations[i], added);\n                if (result) {\n                    from = from < 0 ? result.from : Math.min(result.from, from);\n                    to = to < 0 ? result.to : Math.max(result.to, to);\n                    if (result.typeOver) typeOver = true;\n                }\n            }\n        }\n        if (gecko && added.length > 1) {\n            let brs = added.filter((n)=>n.nodeName == \"BR\");\n            if (brs.length == 2) {\n                let a = brs[0], b = brs[1];\n                if (a.parentNode && a.parentNode.parentNode == b.parentNode) b.remove();\n                else a.remove();\n            }\n        }\n        let readSel = null;\n        // If it looks like the browser has reset the selection to the\n        // start of the document after focus, restore the selection from\n        // the state\n        if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(view.state.doc.resolve(0), 1))) {\n            view.input.lastFocus = 0;\n            selectionToDOM(view);\n            this.currentSelection.set(sel);\n            view.scrollToSelection();\n        } else if (from > -1 || newSel) {\n            if (from > -1) {\n                view.docView.markDirty(from, to);\n                checkCSS(view);\n            }\n            this.handleDOMChange(from, to, typeOver, added);\n            if (view.docView && view.docView.dirty) view.updateState(view.state);\n            else if (!this.currentSelection.eq(sel)) selectionToDOM(view);\n            this.currentSelection.set(sel);\n        }\n    }\n    registerMutation(mut, added) {\n        // Ignore mutations inside nodes that were already noted as inserted\n        if (added.indexOf(mut.target) > -1) return null;\n        let desc = this.view.docView.nearestDesc(mut.target);\n        if (mut.type == \"attributes\" && (desc == this.view.docView || mut.attributeName == \"contenteditable\" || // Firefox sometimes fires spurious events for null/empty styles\n        mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\"))) return null;\n        if (!desc || desc.ignoreMutation(mut)) return null;\n        if (mut.type == \"childList\") {\n            for(let i = 0; i < mut.addedNodes.length; i++)added.push(mut.addedNodes[i]);\n            if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) return {\n                from: desc.posBefore,\n                to: desc.posAfter\n            };\n            let prev = mut.previousSibling, next = mut.nextSibling;\n            if (ie && ie_version <= 11 && mut.addedNodes.length) {\n                // IE11 gives us incorrect next/prev siblings for some\n                // insertions, so if there are added nodes, recompute those\n                for(let i = 0; i < mut.addedNodes.length; i++){\n                    let { previousSibling, nextSibling } = mut.addedNodes[i];\n                    if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) prev = previousSibling;\n                    if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) next = nextSibling;\n                }\n            }\n            let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;\n            let from = desc.localPosFromDOM(mut.target, fromOffset, -1);\n            let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;\n            let to = desc.localPosFromDOM(mut.target, toOffset, 1);\n            return {\n                from,\n                to\n            };\n        } else if (mut.type == \"attributes\") {\n            return {\n                from: desc.posAtStart - desc.border,\n                to: desc.posAtEnd + desc.border\n            };\n        } else {\n            return {\n                from: desc.posAtStart,\n                to: desc.posAtEnd,\n                // An event was generated for a text change that didn't change\n                // any text. Mark the dom change to fall back to assuming the\n                // selection was typed over with an identical value if it can't\n                // find another change.\n                typeOver: mut.target.nodeValue == mut.oldValue\n            };\n        }\n    }\n}\nlet cssChecked = new WeakMap();\nlet cssCheckWarned = false;\nfunction checkCSS(view) {\n    if (cssChecked.has(view)) return;\n    cssChecked.set(view, null);\n    if ([\n        \"normal\",\n        \"nowrap\",\n        \"pre-line\"\n    ].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {\n        view.requiresGeckoHackNode = gecko;\n        if (cssCheckWarned) return;\n        console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\");\n        cssCheckWarned = true;\n    }\n}\n// Used to work around a Safari Selection/shadow DOM bug\n// Based on https://github.com/codemirror/dev/issues/414 fix\nfunction safariShadowSelectionRange(view) {\n    let found;\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    // Because Safari (at least in 2018-2022) doesn't provide regular\n    // access to the selection inside a shadowRoot, we have to perform a\n    // ridiculous hack to get at itusing `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    view.dom.addEventListener(\"beforeinput\", read, true);\n    document.execCommand(\"indent\");\n    view.dom.removeEventListener(\"beforeinput\", read, true);\n    let anchorNode = found.startContainer, anchorOffset = found.startOffset;\n    let focusNode = found.endContainer, focusOffset = found.endOffset;\n    let currentAnchor = view.domAtPos(view.state.selection.anchor);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [\n        focusNode,\n        focusOffset,\n        anchorNode,\n        anchorOffset\n    ];\n    return {\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset\n    };\n}\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\nfunction parseBetween(view, from_, to_) {\n    let { node: parent, fromOffset, toOffset, from, to } = view.docView.parseRange(from_, to_);\n    let domSel = view.domSelectionRange();\n    let find;\n    let anchor = domSel.anchorNode;\n    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n        find = [\n            {\n                node: anchor,\n                offset: domSel.anchorOffset\n            }\n        ];\n        if (!selectionCollapsed(domSel)) find.push({\n            node: domSel.focusNode,\n            offset: domSel.focusOffset\n        });\n    }\n    // Work around issue in Chrome where backspacing sometimes replaces\n    // the deleted content with a random BR node (issues #799, #831)\n    if (chrome && view.input.lastKeyCode === 8) {\n        for(let off = toOffset; off > fromOffset; off--){\n            let node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n            if (node.nodeName == \"BR\" && !desc) {\n                toOffset = off;\n                break;\n            }\n            if (!desc || desc.size) break;\n        }\n    }\n    let startDoc = view.state.doc;\n    let parser = view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n    let $from = startDoc.resolve(from);\n    let sel = null, doc = parser.parse(parent, {\n        topNode: $from.parent,\n        topMatch: $from.parent.contentMatchAt($from.index()),\n        topOpen: true,\n        from: fromOffset,\n        to: toOffset,\n        preserveWhitespace: $from.parent.type.whitespace == \"pre\" ? \"full\" : true,\n        findPositions: find,\n        ruleFromNode,\n        context: $from\n    });\n    if (find && find[0].pos != null) {\n        let anchor = find[0].pos, head = find[1] && find[1].pos;\n        if (head == null) head = anchor;\n        sel = {\n            anchor: anchor + from,\n            head: head + from\n        };\n    }\n    return {\n        doc,\n        sel,\n        from,\n        to\n    };\n}\nfunction ruleFromNode(dom) {\n    let desc = dom.pmViewDesc;\n    if (desc) {\n        return desc.parseRule();\n    } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n        // Safari replaces the list item or table cell with a BR\n        // directly in the list node (?!) if you delete the last\n        // character in a list item or table cell (#708, #862)\n        if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n            let skip = document.createElement(\"div\");\n            skip.appendChild(document.createElement(\"li\"));\n            return {\n                skip\n            };\n        } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n            return {\n                ignore: true\n            };\n        }\n    } else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n        return {\n            ignore: true\n        };\n    }\n    return null;\n}\nconst isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;\nfunction readDOMChange(view, from, to, typeOver, addedNodes) {\n    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);\n    view.input.compositionPendingChanges = 0;\n    if (from < 0) {\n        let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;\n        let newSel = selectionFromDOM(view, origin);\n        if (newSel && !view.state.selection.eq(newSel)) {\n            if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")))) return;\n            let tr = view.state.tr.setSelection(newSel);\n            if (origin == \"pointer\") tr.setMeta(\"pointer\", true);\n            else if (origin == \"key\") tr.scrollIntoView();\n            if (compositionID) tr.setMeta(\"composition\", compositionID);\n            view.dispatch(tr);\n        }\n        return;\n    }\n    let $before = view.state.doc.resolve(from);\n    let shared = $before.sharedDepth(to);\n    from = $before.before(shared + 1);\n    to = view.state.doc.resolve(to).after(shared + 1);\n    let sel = view.state.selection;\n    let parse = parseBetween(view, from, to);\n    let doc = view.state.doc, compare = doc.slice(parse.from, parse.to);\n    let preferredPos, preferredSide;\n    // Prefer anchoring to end when Backspace is pressed\n    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {\n        preferredPos = view.state.selection.to;\n        preferredSide = \"end\";\n    } else {\n        preferredPos = view.state.selection.from;\n        preferredSide = \"start\";\n    }\n    view.input.lastKeyCode = null;\n    let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n)=>n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    if (!change) {\n        if (typeOver && sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n            change = {\n                start: sel.from,\n                endA: sel.to,\n                endB: sel.to\n            };\n        } else {\n            if (parse.sel) {\n                let sel = resolveSelection(view, view.state.doc, parse.sel);\n                if (sel && !sel.eq(view.state.selection)) {\n                    let tr = view.state.tr.setSelection(sel);\n                    if (compositionID) tr.setMeta(\"composition\", compositionID);\n                    view.dispatch(tr);\n                }\n            }\n            return;\n        }\n    }\n    // Chrome sometimes leaves the cursor before the inserted text when\n    // composing after a cursor wrapper. This moves it forward.\n    if (chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from && parse.sel.head == parse.sel.anchor) {\n        let size = change.endB - change.start;\n        parse.sel = {\n            anchor: parse.sel.anchor + size,\n            head: parse.sel.anchor + size\n        };\n    }\n    view.input.domChangeCount++;\n    // Handle the case where overwriting a selection by typing matches\n    // the start or end of the selected content, creating a change\n    // that's smaller than what was actually overwritten.\n    if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {\n            change.start = view.state.selection.from;\n        } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {\n            change.endB += view.state.selection.to - change.endA;\n            change.endA = view.state.selection.to;\n        }\n    }\n    // IE11 will insert a non-breaking space _ahead_ of the space after\n    // the cursor space when adding a space before another space. When\n    // that happened, adjust the change to cover the space instead.\n    if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\xa0\") {\n        change.start--;\n        change.endA--;\n        change.endB--;\n    }\n    let $from = parse.doc.resolveNoCache(change.start - parse.from);\n    let $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    let $fromA = doc.resolve(change.start);\n    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;\n    let nextSel;\n    // If this looks like the effect of pressing Enter (or was recorded\n    // as being an iOS enter press), just dispatch an Enter key instead.\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n)=>n.nodeName == \"DIV\" || n.nodeName == \"P\")) || !inlineChange && $from.pos < parse.doc.content.size && !$from.sameParent($to) && (nextSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    // Same for backspace\n    if (view.state.selection.anchor > change.start && looksLikeJoin(doc, change.start, change.endA, $from, $to) && view.someProp(\"handleKeyDown\", (f)=>f(view, keyEvent(8, \"Backspace\")))) {\n        if (android && chrome) view.domObserver.suppressSelectionUpdates(); // #820\n        return;\n    }\n    // Chrome Android will occasionally, during composition, delete the\n    // entire composition and then immediately insert it again. This is\n    // used to detect that situation.\n    if (chrome && android && change.endB == change.start) view.input.lastAndroidDelete = Date.now();\n    // This tries to detect Android virtual keyboard\n    // enter-and-pick-suggestion action. That sometimes (see issue\n    // #1059) first fires a DOM mutation, before moving the selection to\n    // the newly created block. And then, because ProseMirror cleans up\n    // the DOM selection, it gives up moving the selection entirely,\n    // leaving the cursor in the wrong place. When that happens, we drop\n    // the new paragraph from the initial change, and fire a simulated\n    // enter key afterwards.\n    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n        change.endB -= 2;\n        $to = parse.doc.resolveNoCache(change.endB - parse.from);\n        setTimeout(()=>{\n            view.someProp(\"handleKeyDown\", function(f) {\n                return f(view, keyEvent(13, \"Enter\"));\n            });\n        }, 20);\n    }\n    let chFrom = change.start, chTo = change.endA;\n    let tr, storedMarks, markChange;\n    if (inlineChange) {\n        if ($from.pos == $to.pos) {\n            // IE11 sometimes weirdly moves the DOM selection around after\n            // backspacing out the first element in a textblock\n            if (ie && ie_version <= 11 && $from.parentOffset == 0) {\n                view.domObserver.suppressSelectionUpdates();\n                setTimeout(()=>selectionToDOM(view), 20);\n            }\n            tr = view.state.tr.delete(chFrom, chTo);\n            storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));\n        } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {\n            tr = view.state.tr;\n            if (markChange.type == \"add\") tr.addMark(chFrom, chTo, markChange.mark);\n            else tr.removeMark(chFrom, chTo, markChange.mark);\n        } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n            // Both positions in the same text node -- simply insert text\n            let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n            if (view.someProp(\"handleTextInput\", (f)=>f(view, chFrom, chTo, text))) return;\n            tr = view.state.tr.insertText(text, chFrom, chTo);\n        }\n    }\n    if (!tr) tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));\n    if (parse.sel) {\n        let sel = resolveSelection(view, tr.doc, parse.sel);\n        // Chrome Android will sometimes, during composition, report the\n        // selection in the wrong place. If it looks like that is\n        // happening, don't update the selection.\n        // Edge just doesn't move the cursor forward when you start typing\n        // in an empty block or between br nodes.\n        if (sel && !(chrome && android && view.composing && sel.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (sel.head == chFrom || sel.head == tr.mapping.map(chTo) - 1) || ie && sel.empty && sel.head == chFrom)) tr.setSelection(sel);\n    }\n    if (storedMarks) tr.ensureMarks(storedMarks);\n    if (compositionID) tr.setMeta(\"composition\", compositionID);\n    view.dispatch(tr.scrollIntoView());\n}\nfunction resolveSelection(view, doc, parsedSel) {\n    if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) return null;\n    return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));\n}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n    let added = curMarks, removed = prevMarks, type, mark, update;\n    for(let i = 0; i < prevMarks.length; i++)added = prevMarks[i].removeFromSet(added);\n    for(let i = 0; i < curMarks.length; i++)removed = curMarks[i].removeFromSet(removed);\n    if (added.length == 1 && removed.length == 0) {\n        mark = added[0];\n        type = \"add\";\n        update = (node)=>node.mark(mark.addToSet(node.marks));\n    } else if (added.length == 0 && removed.length == 1) {\n        mark = removed[0];\n        type = \"remove\";\n        update = (node)=>node.mark(mark.removeFromSet(node.marks));\n    } else {\n        return null;\n    }\n    let updated = [];\n    for(let i = 0; i < prev.childCount; i++)updated.push(update(prev.child(i)));\n    if (prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated).eq(cur)) return {\n        mark,\n        type\n    };\n}\nfunction looksLikeJoin(old, start, end, $newStart, $newEnd) {\n    if (!$newStart.parent.isTextblock || // The content must have shrunk\n    end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into\n    skipClosingAndOpening($newStart, true, false) < $newEnd.pos) return false;\n    let $start = old.resolve(start);\n    // Start must be at the end of a block\n    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) return false;\n    let $next = old.resolve(skipClosingAndOpening($start, true, true));\n    // The next textblock must start before end and end near it\n    if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end) return false;\n    // The fragments after the join point must match\n    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);\n}\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n    let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n    while(depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)){\n        depth--;\n        end++;\n        fromEnd = false;\n    }\n    if (mayOpen) {\n        let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n        while(next && !next.isLeaf){\n            next = next.firstChild;\n            end++;\n        }\n    }\n    return end;\n}\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n    let start = a.findDiffStart(b, pos);\n    if (start == null) return null;\n    let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, start - Math.min(endA, endB));\n        preferredPos -= endA + adjust - start;\n    }\n    if (endA < start && a.size < b.size) {\n        let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n        start -= move;\n        if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1))) start += move ? 1 : -1;\n        endB = start + (endB - endA);\n        endA = start;\n    } else if (endB < start) {\n        let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n        start -= move;\n        if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1))) start += move ? 1 : -1;\n        endA = start + (endA - endB);\n        endB = start;\n    }\n    return {\n        start,\n        endA,\n        endB\n    };\n}\nfunction isSurrogatePair(str) {\n    if (str.length != 2) return false;\n    let a = str.charCodeAt(0), b = str.charCodeAt(1);\n    return a >= 0xDC00 && a <= 0xDFFF && b >= 0xD800 && b <= 0xDBFF;\n}\n/**\n@internal\n*/ const __serializeForClipboard = serializeForClipboard;\n/**\n@internal\n*/ const __parseFromClipboard = parseFromClipboard;\n/**\n@internal\n*/ const __endComposition = endComposition;\n/**\nAn editor view manages the DOM structure that represents an\neditable document. Its state and behavior are determined by its\n[props](https://prosemirror.net/docs/ref/#view.DirectEditorProps).\n*/ class EditorView {\n    /**\n    Create a view. `place` may be a DOM node that the editor should\n    be appended to, a function that will place it into the document,\n    or an object whose `mount` property holds the node to use as the\n    document container. If it is `null`, the editor will not be\n    added to the document.\n    */ constructor(place, props){\n        this._root = null;\n        /**\n        @internal\n        */ this.focused = false;\n        /**\n        Kludge used to work around a Chrome bug @internal\n        */ this.trackWrites = null;\n        this.mounted = false;\n        /**\n        @internal\n        */ this.markCursor = null;\n        /**\n        @internal\n        */ this.cursorWrapper = null;\n        /**\n        @internal\n        */ this.lastSelectedViewDesc = undefined;\n        /**\n        @internal\n        */ this.input = new InputState;\n        this.prevDirectPlugins = [];\n        this.pluginViews = [];\n        /**\n        Holds `true` when a hack node is needed in Firefox to prevent the\n        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)\n        @internal\n        */ this.requiresGeckoHackNode = false;\n        /**\n        When editor content is being dragged, this object contains\n        information about the dragged slice and whether it is being\n        copied or moved. At any other time, it is null.\n        */ this.dragging = null;\n        this._props = props;\n        this.state = props.state;\n        this.directPlugins = props.plugins || [];\n        this.directPlugins.forEach(checkStateComponent);\n        this.dispatch = this.dispatch.bind(this);\n        this.dom = place && place.mount || document.createElement(\"div\");\n        if (place) {\n            if (place.appendChild) place.appendChild(this.dom);\n            else if (typeof place == \"function\") place(this.dom);\n            else if (place.mount) this.mounted = true;\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        this.nodeViews = buildNodeViews(this);\n        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n        this.domObserver = new DOMObserver(this, (from, to, typeOver, added)=>readDOMChange(this, from, to, typeOver, added));\n        this.domObserver.start();\n        initInput(this);\n        this.updatePluginViews();\n    }\n    /**\n    Holds `true` when a\n    [composition](https://w3c.github.io/uievents/#events-compositionevents)\n    is active.\n    */ get composing() {\n        return this.input.composing;\n    }\n    /**\n    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).\n    */ get props() {\n        if (this._props.state != this.state) {\n            let prev = this._props;\n            this._props = {};\n            for(let name in prev)this._props[name] = prev[name];\n            this._props.state = this.state;\n        }\n        return this._props;\n    }\n    /**\n    Update the view's props. Will immediately cause an update to\n    the DOM.\n    */ update(props) {\n        if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this);\n        let prevProps = this._props;\n        this._props = props;\n        if (props.plugins) {\n            props.plugins.forEach(checkStateComponent);\n            this.directPlugins = props.plugins;\n        }\n        this.updateStateInner(props.state, prevProps);\n    }\n    /**\n    Update the view by updating existing props object with the object\n    given as argument. Equivalent to `view.update(Object.assign({},\n    view.props, props))`.\n    */ setProps(props) {\n        let updated = {};\n        for(let name in this._props)updated[name] = this._props[name];\n        updated.state = this.state;\n        for(let name in props)updated[name] = props[name];\n        this.update(updated);\n    }\n    /**\n    Update the editor's `state` prop, without touching any of the\n    other props.\n    */ updateState(state) {\n        this.updateStateInner(state, this._props);\n    }\n    updateStateInner(state, prevProps) {\n        var _a;\n        let prev = this.state, redraw = false, updateSel = false;\n        // When stored marks are added, stop composition, so that they can\n        // be displayed.\n        if (state.storedMarks && this.composing) {\n            clearComposition(this);\n            updateSel = true;\n        }\n        this.state = state;\n        let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;\n        if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {\n            let nodeViews = buildNodeViews(this);\n            if (changedNodeViews(nodeViews, this.nodeViews)) {\n                this.nodeViews = nodeViews;\n                redraw = true;\n            }\n        }\n        if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {\n            ensureListeners(this);\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n        let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? \"reset\" : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n        let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n        if (updateDoc || !state.selection.eq(prev.selection)) updateSel = true;\n        let oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n        if (updateSel) {\n            this.domObserver.stop();\n            // Work around an issue in Chrome, IE, and Edge where changing\n            // the DOM around an active selection puts it into a broken\n            // state where the thing the user sees differs from the\n            // selection reported by the Selection object (#710, #973,\n            // #1011, #1013, #1035).\n            let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n            if (updateDoc) {\n                // If the node that the selection points into is written to,\n                // Chrome sometimes starts misreporting the selection, so this\n                // tracks that and forces a selection reset when our update\n                // did write to the node.\n                let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;\n                if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n                    this.docView.updateOuterDeco([]);\n                    this.docView.destroy();\n                    this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n                }\n                if (chromeKludge && !this.trackWrites) forceSelUpdate = true;\n            }\n            // Work around for an issue where an update arriving right between\n            // a DOM selection change and the \"selectionchange\" event for it\n            // can cause a spurious DOM selection update, disrupting mouse\n            // drag selection.\n            if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {\n                selectionToDOM(this, forceSelUpdate);\n            } else {\n                syncNodeSelection(this, state.selection);\n                this.domObserver.setCurSelection();\n            }\n            this.domObserver.start();\n        }\n        this.updatePluginViews(prev);\n        if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc)) this.updateDraggedNode(this.dragging, prev);\n        if (scroll == \"reset\") {\n            this.dom.scrollTop = 0;\n        } else if (scroll == \"to selection\") {\n            this.scrollToSelection();\n        } else if (oldScrollPos) {\n            resetScrollPos(oldScrollPos);\n        }\n    }\n    /**\n    @internal\n    */ scrollToSelection() {\n        let startDOM = this.domSelectionRange().focusNode;\n        if (this.someProp(\"handleScrollToSelection\", (f)=>f(this))) ;\n        else if (this.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n            let target = this.docView.domAfterPos(this.state.selection.from);\n            if (target.nodeType == 1) scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);\n        } else {\n            scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);\n        }\n    }\n    destroyPluginViews() {\n        let view;\n        while(view = this.pluginViews.pop())if (view.destroy) view.destroy();\n    }\n    updatePluginViews(prevState) {\n        if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n            this.prevDirectPlugins = this.directPlugins;\n            this.destroyPluginViews();\n            for(let i = 0; i < this.directPlugins.length; i++){\n                let plugin = this.directPlugins[i];\n                if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));\n            }\n            for(let i = 0; i < this.state.plugins.length; i++){\n                let plugin = this.state.plugins[i];\n                if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));\n            }\n        } else {\n            for(let i = 0; i < this.pluginViews.length; i++){\n                let pluginView = this.pluginViews[i];\n                if (pluginView.update) pluginView.update(this, prevState);\n            }\n        }\n    }\n    updateDraggedNode(dragging, prev) {\n        let sel = dragging.node, found = -1;\n        if (this.state.doc.nodeAt(sel.from) == sel.node) {\n            found = sel.from;\n        } else {\n            let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);\n            let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);\n            if (moved == sel.node) found = movedPos;\n        }\n        this.dragging = new Dragging(dragging.slice, dragging.move, found < 0 ? undefined : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(this.state.doc, found));\n    }\n    someProp(propName, f) {\n        let prop = this._props && this._props[propName], value;\n        if (prop != null && (value = f ? f(prop) : prop)) return value;\n        for(let i = 0; i < this.directPlugins.length; i++){\n            let prop = this.directPlugins[i].props[propName];\n            if (prop != null && (value = f ? f(prop) : prop)) return value;\n        }\n        let plugins = this.state.plugins;\n        if (plugins) for(let i = 0; i < plugins.length; i++){\n            let prop = plugins[i].props[propName];\n            if (prop != null && (value = f ? f(prop) : prop)) return value;\n        }\n    }\n    /**\n    Query whether the view has focus.\n    */ hasFocus() {\n        // Work around IE not handling focus correctly if resize handles are shown.\n        // If the cursor is inside an element with resize handles, activeElement\n        // will be that element instead of this.dom.\n        if (ie) {\n            // If activeElement is within this.dom, and there are no other elements\n            // setting `contenteditable` to false in between, treat it as focused.\n            let node = this.root.activeElement;\n            if (node == this.dom) return true;\n            if (!node || !this.dom.contains(node)) return false;\n            while(node && this.dom != node && this.dom.contains(node)){\n                if (node.contentEditable == \"false\") return false;\n                node = node.parentElement;\n            }\n            return true;\n        }\n        return this.root.activeElement == this.dom;\n    }\n    /**\n    Focus the editor.\n    */ focus() {\n        this.domObserver.stop();\n        if (this.editable) focusPreventScroll(this.dom);\n        selectionToDOM(this);\n        this.domObserver.start();\n    }\n    /**\n    Get the document root in which the editor exists. This will\n    usually be the top-level `document`, but might be a [shadow\n    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n    root if the editor is inside one.\n    */ get root() {\n        let cached = this._root;\n        if (cached == null) for(let search = this.dom.parentNode; search; search = search.parentNode){\n            if (search.nodeType == 9 || search.nodeType == 11 && search.host) {\n                if (!search.getSelection) Object.getPrototypeOf(search).getSelection = ()=>search.ownerDocument.getSelection();\n                return this._root = search;\n            }\n        }\n        return cached || document;\n    }\n    /**\n    When an existing editor view is moved to a new document or\n    shadow tree, call this to make it recompute its root.\n    */ updateRoot() {\n        this._root = null;\n    }\n    /**\n    Given a pair of viewport coordinates, return the document\n    position that corresponds to them. May return null if the given\n    coordinates aren't inside of the editor. When an object is\n    returned, its `pos` property is the position nearest to the\n    coordinates, and its `inside` property holds the position of the\n    inner node that the position falls inside of, or -1 if it is at\n    the top level, not in any node.\n    */ posAtCoords(coords) {\n        return posAtCoords(this, coords);\n    }\n    /**\n    Returns the viewport rectangle at a given document position.\n    `left` and `right` will be the same number, as this returns a\n    flat cursor-ish rectangle. If the position is between two things\n    that aren't directly adjacent, `side` determines which element\n    is used. When < 0, the element before the position is used,\n    otherwise the element after.\n    */ coordsAtPos(pos, side = 1) {\n        return coordsAtPos(this, pos, side);\n    }\n    /**\n    Find the DOM position that corresponds to the given document\n    position. When `side` is negative, find the position as close as\n    possible to the content before the position. When positive,\n    prefer positions close to the content after the position. When\n    zero, prefer as shallow a position as possible.\n    \n    Note that you should **not** mutate the editor's internal DOM,\n    only inspect it (and even that is usually not necessary).\n    */ domAtPos(pos, side = 0) {\n        return this.docView.domFromPos(pos, side);\n    }\n    /**\n    Find the DOM node that represents the document node after the\n    given position. May return `null` when the position doesn't point\n    in front of a node or if the node is inside an opaque node view.\n    \n    This is intended to be able to call things like\n    `getBoundingClientRect` on that DOM node. Do **not** mutate the\n    editor DOM directly, or add styling this way, since that will be\n    immediately overriden by the editor as it redraws the node.\n    */ nodeDOM(pos) {\n        let desc = this.docView.descAt(pos);\n        return desc ? desc.nodeDOM : null;\n    }\n    /**\n    Find the document position that corresponds to a given DOM\n    position. (Whenever possible, it is preferable to inspect the\n    document structure directly, rather than poking around in the\n    DOM, but sometimesfor example when interpreting an event\n    targetyou don't have a choice.)\n    \n    The `bias` parameter can be used to influence which side of a DOM\n    node to use when the position is inside a leaf node.\n    */ posAtDOM(node, offset, bias = -1) {\n        let pos = this.docView.posFromDOM(node, offset, bias);\n        if (pos == null) throw new RangeError(\"DOM position not inside the editor\");\n        return pos;\n    }\n    /**\n    Find out whether the selection is at the end of a textblock when\n    moving in a given direction. When, for example, given `\"left\"`,\n    it will return true if moving left from the current cursor\n    position would leave that position's parent textblock. Will apply\n    to the view's current state by default, but it is possible to\n    pass a different state.\n    */ endOfTextblock(dir, state) {\n        return endOfTextblock(this, state || this.state, dir);\n    }\n    /**\n    Run the editor's paste logic with the given HTML string. The\n    `event`, if given, will be passed to the\n    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.\n    */ pasteHTML(html, event) {\n        return doPaste(this, \"\", html, false, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Run the editor's paste logic with the given plain-text input.\n    */ pasteText(text, event) {\n        return doPaste(this, text, null, true, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Removes the editor from the DOM and destroys all [node\n    views](https://prosemirror.net/docs/ref/#view.NodeView).\n    */ destroy() {\n        if (!this.docView) return;\n        destroyInput(this);\n        this.destroyPluginViews();\n        if (this.mounted) {\n            this.docView.update(this.state.doc, [], viewDecorations(this), this);\n            this.dom.textContent = \"\";\n        } else if (this.dom.parentNode) {\n            this.dom.parentNode.removeChild(this.dom);\n        }\n        this.docView.destroy();\n        this.docView = null;\n    }\n    /**\n    This is true when the view has been\n    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be\n    used anymore).\n    */ get isDestroyed() {\n        return this.docView == null;\n    }\n    /**\n    Used for testing.\n    */ dispatchEvent(event) {\n        return dispatchEvent(this, event);\n    }\n    /**\n    Dispatch a transaction. Will call\n    [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)\n    when given, and otherwise defaults to applying the transaction to\n    the current state and calling\n    [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.\n    This method is bound to the view instance, so that it can be\n    easily passed around.\n    */ dispatch(tr) {\n        let dispatchTransaction = this._props.dispatchTransaction;\n        if (dispatchTransaction) dispatchTransaction.call(this, tr);\n        else this.updateState(this.state.apply(tr));\n    }\n    /**\n    @internal\n    */ domSelectionRange() {\n        return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom ? safariShadowSelectionRange(this) : this.domSelection();\n    }\n    /**\n    @internal\n    */ domSelection() {\n        return this.root.getSelection();\n    }\n}\nfunction computeDocDeco(view) {\n    let attrs = Object.create(null);\n    attrs.class = \"ProseMirror\";\n    attrs.contenteditable = String(view.editable);\n    view.someProp(\"attributes\", (value)=>{\n        if (typeof value == \"function\") value = value(view.state);\n        if (value) for(let attr in value){\n            if (attr == \"class\") attrs.class += \" \" + value[attr];\n            else if (attr == \"style\") attrs.style = (attrs.style ? attrs.style + \";\" : \"\") + value[attr];\n            else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\") attrs[attr] = String(value[attr]);\n        }\n    });\n    if (!attrs.translate) attrs.translate = \"no\";\n    return [\n        Decoration.node(0, view.state.doc.content.size, attrs)\n    ];\n}\nfunction updateCursorWrapper(view) {\n    if (view.markCursor) {\n        let dom = document.createElement(\"img\");\n        dom.className = \"ProseMirror-separator\";\n        dom.setAttribute(\"mark-placeholder\", \"true\");\n        dom.setAttribute(\"alt\", \"\");\n        view.cursorWrapper = {\n            dom,\n            deco: Decoration.widget(view.state.selection.head, dom, {\n                raw: true,\n                marks: view.markCursor\n            })\n        };\n    } else {\n        view.cursorWrapper = null;\n    }\n}\nfunction getEditable(view) {\n    return !view.someProp(\"editable\", (value)=>value(view.state) === false);\n}\nfunction selectionContextChanged(sel1, sel2) {\n    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);\n}\nfunction buildNodeViews(view) {\n    let result = Object.create(null);\n    function add(obj) {\n        for(let prop in obj)if (!Object.prototype.hasOwnProperty.call(result, prop)) result[prop] = obj[prop];\n    }\n    view.someProp(\"nodeViews\", add);\n    view.someProp(\"markViews\", add);\n    return result;\n}\nfunction changedNodeViews(a, b) {\n    let nA = 0, nB = 0;\n    for(let prop in a){\n        if (a[prop] != b[prop]) return true;\n        nA++;\n    }\n    for(let _ in b)nB++;\n    return nA != nB;\n}\nfunction checkStateComponent(plugin) {\n    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) throw new RangeError(\"Plugins passed directly to the view must not have a state component\");\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itdmlldy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUEwRjtBQUNOO0FBQ2xDO0FBRWxELE1BQU1VLFdBQVcsU0FBVUMsSUFBSTtJQUMzQixJQUFLLElBQUlDLFFBQVEsSUFBSUEsUUFBUztRQUMxQkQsT0FBT0EsS0FBS0UsZUFBZTtRQUMzQixJQUFJLENBQUNGLE1BQ0QsT0FBT0M7SUFDZjtBQUNKO0FBQ0EsTUFBTUUsYUFBYSxTQUFVSCxJQUFJO0lBQzdCLElBQUlJLFNBQVNKLEtBQUtLLFlBQVksSUFBSUwsS0FBS0csVUFBVTtJQUNqRCxPQUFPQyxVQUFVQSxPQUFPRSxRQUFRLElBQUksS0FBS0YsT0FBT0csSUFBSSxHQUFHSDtBQUMzRDtBQUNBLElBQUlJLGNBQWM7QUFDbEIsc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSw0QkFBNEI7QUFDNUIsTUFBTUMsWUFBWSxTQUFVVCxJQUFJLEVBQUVVLElBQUksRUFBRUMsRUFBRTtJQUN0QyxJQUFJQyxRQUFRSixlQUFnQkEsQ0FBQUEsY0FBY0ssU0FBU0MsV0FBVyxFQUFDO0lBQy9ERixNQUFNRyxNQUFNLENBQUNmLE1BQU1XLE1BQU0sT0FBT1gsS0FBS2dCLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHTjtJQUN4REMsTUFBTU0sUUFBUSxDQUFDbEIsTUFBTVUsUUFBUTtJQUM3QixPQUFPRTtBQUNYO0FBQ0EscUVBQXFFO0FBQ3JFLGtFQUFrRTtBQUNsRSw2Q0FBNkM7QUFDN0MsTUFBTU8sdUJBQXVCLFNBQVVuQixJQUFJLEVBQUVvQixHQUFHLEVBQUVDLFVBQVUsRUFBRUMsU0FBUztJQUNuRSxPQUFPRCxjQUFlRSxDQUFBQSxRQUFRdkIsTUFBTW9CLEtBQUtDLFlBQVlDLFdBQVcsQ0FBQyxNQUM3REMsUUFBUXZCLE1BQU1vQixLQUFLQyxZQUFZQyxXQUFXLEVBQUM7QUFDbkQ7QUFDQSxNQUFNRSxlQUFlO0FBQ3JCLFNBQVNELFFBQVF2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R0FBRztRQUNaLElBQUssSUFBSTltQixRQUFROG1CLElBQ2IsSUFBSSxDQUFDam9CLE9BQU9wTyxTQUFTLENBQUNzMkIsY0FBYyxDQUFDcDJCLElBQUksQ0FBQytDLFFBQVFzTSxPQUM5Q3RNLE1BQU0sQ0FBQ3NNLEtBQUssR0FBRzhtQixHQUFHLENBQUM5bUIsS0FBSztJQUNwQztJQUNBN1YsS0FBS0csUUFBUSxDQUFDLGFBQWFvTztJQUMzQnZPLEtBQUtHLFFBQVEsQ0FBQyxhQUFhb087SUFDM0IsT0FBT2hGO0FBQ1g7QUFDQSxTQUFTdXhCLGlCQUFpQjdrQixDQUFDLEVBQUVDLENBQUM7SUFDMUIsSUFBSTJtQixLQUFLLEdBQUdDLEtBQUs7SUFDakIsSUFBSyxJQUFJam5CLFFBQVFJLEVBQUc7UUFDaEIsSUFBSUEsQ0FBQyxDQUFDSixLQUFLLElBQUlLLENBQUMsQ0FBQ0wsS0FBSyxFQUNsQixPQUFPO1FBQ1hnbkI7SUFDSjtJQUNBLElBQUssSUFBSWhnQyxLQUFLcVosRUFDVjRtQjtJQUNKLE9BQU9ELE1BQU1DO0FBQ2pCO0FBQ0EsU0FBUy9DLG9CQUFvQjBCLE1BQU07SUFDL0IsSUFBSUEsT0FBT3h0QixJQUFJLENBQUNySSxLQUFLLElBQUk2MUIsT0FBT3h0QixJQUFJLENBQUM4dUIsaUJBQWlCLElBQUl0QixPQUFPeHRCLElBQUksQ0FBQyt1QixpQkFBaUIsRUFDbkYsTUFBTSxJQUFJdndCLFdBQVc7QUFDN0I7QUFFa0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmFsb2d1ZXNoaWZ0cy8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci12aWV3L2Rpc3QvaW5kZXguanM/NGUzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uLCBOb2RlU2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24sIFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBNYXJrLCBTbGljZSwgRE9NUGFyc2VyIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgZHJvcFBvaW50IH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcblxuY29uc3QgZG9tSW5kZXggPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDs7IGluZGV4KyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufTtcbmNvbnN0IHBhcmVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGxldCBwYXJlbnQgPSBub2RlLmFzc2lnbmVkU2xvdCB8fCBub2RlLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMTEgPyBwYXJlbnQuaG9zdCA6IHBhcmVudDtcbn07XG5sZXQgcmV1c2VkUmFuZ2UgPSBudWxsO1xuLy8gTm90ZSB0aGF0IHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIHJhbmdlLCBiZWNhdXNlIERPTSByYW5nZVxuLy8gb2JqZWN0cyBhcmUgZXZlcnkgZXhwZW5zaXZlLCBhbmQga2VlcCBzbG93aW5nIGRvd24gc3Vic2VxdWVudCBET01cbi8vIHVwZGF0ZXMsIGZvciBzb21lIHJlYXNvbi5cbmNvbnN0IHRleHRSYW5nZSA9IGZ1bmN0aW9uIChub2RlLCBmcm9tLCB0bykge1xuICAgIGxldCByYW5nZSA9IHJldXNlZFJhbmdlIHx8IChyZXVzZWRSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkpO1xuICAgIHJhbmdlLnNldEVuZChub2RlLCB0byA9PSBudWxsID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogdG8pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGZyb20gfHwgMCk7XG4gICAgcmV0dXJuIHJhbmdlO1xufTtcbi8vIFNjYW5zIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRocm91Z2ggRE9NIHBvc2l0aW9ucyBlcXVpdmFsZW50IHRvIHRoZVxuLy8gZ2l2ZW4gb25lIHRvIHNlZSBpZiB0aGUgdHdvIGFyZSBpbiB0aGUgc2FtZSBwbGFjZSAoaS5lLiBhZnRlciBhXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcbmNvbnN0IGlzRXF1aXZhbGVudFBvc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gICAgcmV0dXJuIHRhcmdldE5vZGUgJiYgKHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIC0xKSB8fFxuICAgICAgICBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAxKSk7XG59O1xuY29uc3QgYXRvbUVsZW1lbnRzID0gL14oaW1nfGJyfGlucHV0fHRleHRhcmVhfGhyKSQvaTtcbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvZmYgPT0gKGRpciA8IDAgPyAwIDogbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEgfHwgaGFzQmxvY2tEZXNjKG5vZGUpIHx8IGF0b21FbGVtZW50cy50ZXN0KG5vZGUubm9kZU5hbWUpIHx8XG4gICAgICAgICAgICAgICAgbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRvbUluZGV4KG5vZGUpICsgKGRpciA8IDAgPyAwIDogMSk7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmYgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkaXIgPCAwID8gbm9kZVNpemUobm9kZSkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbm9kZVNpemUobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNPbkVkZ2Uobm9kZSwgb2Zmc2V0LCBwYXJlbnQpIHtcbiAgICBmb3IgKGxldCBhdFN0YXJ0ID0gb2Zmc2V0ID09IDAsIGF0RW5kID0gb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpOyBhdFN0YXJ0IHx8IGF0RW5kOykge1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IGluZGV4ID0gZG9tSW5kZXgobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYXRTdGFydCA9IGF0U3RhcnQgJiYgaW5kZXggPT0gMDtcbiAgICAgICAgYXRFbmQgPSBhdEVuZCAmJiBpbmRleCA9PSBub2RlU2l6ZShub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNCbG9ja0Rlc2MoZG9tKSB7XG4gICAgbGV0IGRlc2M7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoZGVzYyA9IGN1ci5wbVZpZXdEZXNjKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgcmV0dXJuIGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrICYmIChkZXNjLmRvbSA9PSBkb20gfHwgZGVzYy5jb250ZW50RE9NID09IGRvbSk7XG59XG4vLyBXb3JrIGFyb3VuZCBDaHJvbWUgaXNzdWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ3NTIzXG4vLyAoaXNDb2xsYXBzZWQgaW5hcHByb3ByaWF0ZWx5IHJldHVybnMgdHJ1ZSBpbiBzaGFkb3cgZG9tKVxuY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gZnVuY3Rpb24gKGRvbVNlbCkge1xuICAgIHJldHVybiBkb21TZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xufTtcbmZ1bmN0aW9uIGtleUV2ZW50KGtleUNvZGUsIGtleSkge1xuICAgIGxldCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgZXZlbnQuaW5pdEV2ZW50KFwia2V5ZG93blwiLCB0cnVlLCB0cnVlKTtcbiAgICBldmVudC5rZXlDb2RlID0ga2V5Q29kZTtcbiAgICBldmVudC5rZXkgPSBldmVudC5jb2RlID0ga2V5O1xuICAgIHJldHVybiBldmVudDtcbn1cbmZ1bmN0aW9uIGRlZXBBY3RpdmVFbGVtZW50KGRvYykge1xuICAgIGxldCBlbHQgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICB3aGlsZSAoZWx0ICYmIGVsdC5zaGFkb3dSb290KVxuICAgICAgICBlbHQgPSBlbHQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgIHJldHVybiBlbHQ7XG59XG5mdW5jdGlvbiBjYXJldEZyb21Qb2ludChkb2MsIHgsIHkpIHtcbiAgICBpZiAoZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQpIHtcbiAgICAgICAgdHJ5IHsgLy8gRmlyZWZveCB0aHJvd3MgZm9yIHRoaXMgY2FsbCBpbiBoYXJkLXRvLXByZWRpY3QgY2lyY3Vtc3RhbmNlcyAoIzk5NClcbiAgICAgICAgICAgIGxldCBwb3MgPSBkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgIGlmIChwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogcG9zLm9mZnNldE5vZGUsIG9mZnNldDogcG9zLm9mZnNldCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICB9XG4gICAgaWYgKGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KSB7XG4gICAgICAgIGxldCByYW5nZSA9IGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiByYW5nZS5zdGFydENvbnRhaW5lciwgb2Zmc2V0OiByYW5nZS5zdGFydE9mZnNldCB9O1xuICAgIH1cbn1cblxuY29uc3QgbmF2ID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gbmF2aWdhdG9yIDogbnVsbDtcbmNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiBudWxsO1xuY29uc3QgYWdlbnQgPSAobmF2ICYmIG5hdi51c2VyQWdlbnQpIHx8IFwiXCI7XG5jb25zdCBpZV9lZGdlID0gL0VkZ2VcXC8oXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWVfdXB0bzEwID0gL01TSUUgXFxkLy5leGVjKGFnZW50KTtcbmNvbnN0IGllXzExdXAgPSAvVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWUgPSAhIShpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBpZV9lZGdlKTtcbmNvbnN0IGllX3ZlcnNpb24gPSBpZV91cHRvMTAgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBpZV8xMXVwID8gK2llXzExdXBbMV0gOiBpZV9lZGdlID8gK2llX2VkZ2VbMV0gOiAwO1xuY29uc3QgZ2Vja28gPSAhaWUgJiYgL2dlY2tvXFwvKFxcZCspL2kudGVzdChhZ2VudCk7XG5nZWNrbyAmJiArKC9GaXJlZm94XFwvKFxcZCspLy5leGVjKGFnZW50KSB8fCBbMCwgMF0pWzFdO1xuY29uc3QgX2Nocm9tZSA9ICFpZSAmJiAvQ2hyb21lXFwvKFxcZCspLy5leGVjKGFnZW50KTtcbmNvbnN0IGNocm9tZSA9ICEhX2Nocm9tZTtcbmNvbnN0IGNocm9tZV92ZXJzaW9uID0gX2Nocm9tZSA/ICtfY2hyb21lWzFdIDogMDtcbmNvbnN0IHNhZmFyaSA9ICFpZSAmJiAhIW5hdiAmJiAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2LnZlbmRvcik7XG4vLyBJcyB0cnVlIGZvciBib3RoIGlPUyBhbmQgaVBhZE9TIGZvciBjb252ZW5pZW5jZVxuY29uc3QgaW9zID0gc2FmYXJpICYmICgvTW9iaWxlXFwvXFx3Ky8udGVzdChhZ2VudCkgfHwgISFuYXYgJiYgbmF2Lm1heFRvdWNoUG9pbnRzID4gMik7XG5jb25zdCBtYWMgPSBpb3MgfHwgKG5hdiA/IC9NYWMvLnRlc3QobmF2LnBsYXRmb3JtKSA6IGZhbHNlKTtcbmNvbnN0IHdpbmRvd3MgPSBuYXYgPyAvV2luLy50ZXN0KG5hdi5wbGF0Zm9ybSkgOiBmYWxzZTtcbmNvbnN0IGFuZHJvaWQgPSAvQW5kcm9pZCBcXGQvLnRlc3QoYWdlbnQpO1xuY29uc3Qgd2Via2l0ID0gISFkb2MgJiYgXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmNvbnN0IHdlYmtpdF92ZXJzaW9uID0gd2Via2l0ID8gKygvXFxiQXBwbGVXZWJLaXRcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDA7XG5cbmZ1bmN0aW9uIHdpbmRvd1JlY3QoZG9jKSB7XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgIHRvcDogMCwgYm90dG9tOiBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB9O1xufVxuZnVuY3Rpb24gZ2V0U2lkZSh2YWx1ZSwgc2lkZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IHZhbHVlIDogdmFsdWVbc2lkZV07XG59XG5mdW5jdGlvbiBjbGllbnRSZWN0KG5vZGUpIHtcbiAgICBsZXQgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gQWRqdXN0IGZvciBlbGVtZW50cyB3aXRoIHN0eWxlIFwidHJhbnNmb3JtOiBzY2FsZSgpXCJcbiAgICBsZXQgc2NhbGVYID0gKHJlY3Qud2lkdGggLyBub2RlLm9mZnNldFdpZHRoKSB8fCAxO1xuICAgIGxldCBzY2FsZVkgPSAocmVjdC5oZWlnaHQgLyBub2RlLm9mZnNldEhlaWdodCkgfHwgMTtcbiAgICAvLyBNYWtlIHN1cmUgc2Nyb2xsYmFyIHdpZHRoIGlzbid0IGluY2x1ZGVkIGluIHRoZSByZWN0YW5nbGVcbiAgICByZXR1cm4geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBub2RlLmNsaWVudFdpZHRoICogc2NhbGVYLFxuICAgICAgICB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QudG9wICsgbm9kZS5jbGllbnRIZWlnaHQgKiBzY2FsZVkgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFJlY3RJbnRvVmlldyh2aWV3LCByZWN0LCBzdGFydERPTSkge1xuICAgIGxldCBzY3JvbGxUaHJlc2hvbGQgPSB2aWV3LnNvbWVQcm9wKFwic2Nyb2xsVGhyZXNob2xkXCIpIHx8IDAsIHNjcm9sbE1hcmdpbiA9IHZpZXcuc29tZVByb3AoXCJzY3JvbGxNYXJnaW5cIikgfHwgNTtcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBzdGFydERPTSB8fCB2aWV3LmRvbTs7IHBhcmVudCA9IHBhcmVudE5vZGUocGFyZW50KSkge1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IGVsdCA9IHBhcmVudDtcbiAgICAgICAgbGV0IGF0VG9wID0gZWx0ID09IGRvYy5ib2R5O1xuICAgICAgICBsZXQgYm91bmRpbmcgPSBhdFRvcCA/IHdpbmRvd1JlY3QoZG9jKSA6IGNsaWVudFJlY3QoZWx0KTtcbiAgICAgICAgbGV0IG1vdmVYID0gMCwgbW92ZVkgPSAwO1xuICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3AgKyBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJ0b3BcIikpXG4gICAgICAgICAgICBtb3ZlWSA9IC0oYm91bmRpbmcudG9wIC0gcmVjdC50b3AgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJ0b3BcIikpO1xuICAgICAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcImJvdHRvbVwiKSlcbiAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcCA+IGJvdW5kaW5nLmJvdHRvbSAtIGJvdW5kaW5nLnRvcFxuICAgICAgICAgICAgICAgID8gcmVjdC50b3AgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJ0b3BcIikgLSBib3VuZGluZy50b3BcbiAgICAgICAgICAgICAgICA6IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwiYm90dG9tXCIpO1xuICAgICAgICBpZiAocmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCArIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcImxlZnRcIikpXG4gICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCAtIHJlY3QubGVmdCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcImxlZnRcIikpO1xuICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQgLSBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJyaWdodFwiKSlcbiAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwicmlnaHRcIik7XG4gICAgICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgICAgICAgaWYgKGF0VG9wKSB7XG4gICAgICAgICAgICAgICAgZG9jLmRlZmF1bHRWaWV3LnNjcm9sbEJ5KG1vdmVYLCBtb3ZlWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRYID0gZWx0LnNjcm9sbExlZnQsIHN0YXJ0WSA9IGVsdC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVZKVxuICAgICAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsVG9wICs9IG1vdmVZO1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgZWx0LnNjcm9sbExlZnQgKz0gbW92ZVg7XG4gICAgICAgICAgICAgICAgbGV0IGRYID0gZWx0LnNjcm9sbExlZnQgLSBzdGFydFgsIGRZID0gZWx0LnNjcm9sbFRvcCAtIHN0YXJ0WTtcbiAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiByZWN0LmxlZnQgLSBkWCwgdG9wOiByZWN0LnRvcCAtIGRZLCByaWdodDogcmVjdC5yaWdodCAtIGRYLCBib3R0b206IHJlY3QuYm90dG9tIC0gZFkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRUb3AgfHwgL14oZml4ZWR8c3RpY2t5KSQvLnRlc3QoZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpLnBvc2l0aW9uKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbi8vIFN0b3JlIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGVkaXRvcidzIHBhcmVudCBub2RlcywgYWxvbmcgd2l0aFxuLy8gdGhlIHRvcCBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IG5lYXIgdGhlIHRvcCBvZiB0aGUgZWRpdG9yLCB3aGljaFxuLy8gd2lsbCBiZSB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgdmlzaWJsZSB2aWV3cG9ydCByZW1haW5zIHN0YWJsZSBldmVuXG4vLyB3aGVuIHRoZSBzaXplIG9mIHRoZSBjb250ZW50IGFib3ZlIGNoYW5nZXMuXG5mdW5jdGlvbiBzdG9yZVNjcm9sbFBvcyh2aWV3KSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc3RhcnRZID0gTWF0aC5tYXgoMCwgcmVjdC50b3ApO1xuICAgIGxldCByZWZET00sIHJlZlRvcDtcbiAgICBmb3IgKGxldCB4ID0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiwgeSA9IHN0YXJ0WSArIDE7IHkgPCBNYXRoLm1pbihpbm5lckhlaWdodCwgcmVjdC5ib3R0b20pOyB5ICs9IDUpIHtcbiAgICAgICAgbGV0IGRvbSA9IHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgICBpZiAoIWRvbSB8fCBkb20gPT0gdmlldy5kb20gfHwgIXZpZXcuZG9tLmNvbnRhaW5zKGRvbSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IGxvY2FsUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGxvY2FsUmVjdC50b3AgPj0gc3RhcnRZIC0gMjApIHtcbiAgICAgICAgICAgIHJlZkRPTSA9IGRvbTtcbiAgICAgICAgICAgIHJlZlRvcCA9IGxvY2FsUmVjdC50b3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWZET006IHJlZkRPTSwgcmVmVG9wOiByZWZUb3AsIHN0YWNrOiBzY3JvbGxTdGFjayh2aWV3LmRvbSkgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFN0YWNrKGRvbSkge1xuICAgIGxldCBzdGFjayA9IFtdLCBkb2MgPSBkb20ub3duZXJEb2N1bWVudDtcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gcGFyZW50Tm9kZShjdXIpKSB7XG4gICAgICAgIHN0YWNrLnB1c2goeyBkb206IGN1ciwgdG9wOiBjdXIuc2Nyb2xsVG9wLCBsZWZ0OiBjdXIuc2Nyb2xsTGVmdCB9KTtcbiAgICAgICAgaWYgKGRvbSA9PSBkb2MpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuLy8gUmVzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWRpdG9yJ3MgcGFyZW50IG5vZGVzIHRvIHRoYXQgd2hhdFxuLy8gaXQgd2FzIGJlZm9yZSwgd2hlbiBzdG9yZVNjcm9sbFBvcyB3YXMgY2FsbGVkLlxuZnVuY3Rpb24gcmVzZXRTY3JvbGxQb3MoeyByZWZET00sIHJlZlRvcCwgc3RhY2sgfSkge1xuICAgIGxldCBuZXdSZWZUb3AgPSByZWZET00gPyByZWZET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDogMDtcbiAgICByZXN0b3JlU2Nyb2xsU3RhY2soc3RhY2ssIG5ld1JlZlRvcCA9PSAwID8gMCA6IG5ld1JlZlRvcCAtIHJlZlRvcCk7XG59XG5mdW5jdGlvbiByZXN0b3JlU2Nyb2xsU3RhY2soc3RhY2ssIGRUb3ApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB7IGRvbSwgdG9wLCBsZWZ0IH0gPSBzdGFja1tpXTtcbiAgICAgICAgaWYgKGRvbS5zY3JvbGxUb3AgIT0gdG9wICsgZFRvcClcbiAgICAgICAgICAgIGRvbS5zY3JvbGxUb3AgPSB0b3AgKyBkVG9wO1xuICAgICAgICBpZiAoZG9tLnNjcm9sbExlZnQgIT0gbGVmdClcbiAgICAgICAgICAgIGRvbS5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICB9XG59XG5sZXQgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IG51bGw7XG4vLyBGZWF0dXJlLWRldGVjdHMgc3VwcG9ydCBmb3IgLmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiB0cnVlfSksIGFuZCB1c2VzXG4vLyBhIGZhbGxiYWNrIGtsdWRnZSB3aGVuIG5vdCBzdXBwb3J0ZWQuXG5mdW5jdGlvbiBmb2N1c1ByZXZlbnRTY3JvbGwoZG9tKSB7XG4gICAgaWYgKGRvbS5zZXRBY3RpdmUpXG4gICAgICAgIHJldHVybiBkb20uc2V0QWN0aXZlKCk7IC8vIGluIElFXG4gICAgaWYgKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCk7XG4gICAgbGV0IHN0b3JlZCA9IHNjcm9sbFN0YWNrKGRvbSk7XG4gICAgZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPT0gbnVsbCA/IHtcbiAgICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0geyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gOiB1bmRlZmluZWQpO1xuICAgIGlmICghcHJldmVudFNjcm9sbFN1cHBvcnRlZCkge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIHJlc3RvcmVTY3JvbGxTdGFjayhzdG9yZWQsIDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXRJbk5vZGUobm9kZSwgY29vcmRzKSB7XG4gICAgbGV0IGNsb3Nlc3QsIGR4Q2xvc2VzdCA9IDJlOCwgY29vcmRzQ2xvc2VzdCwgb2Zmc2V0ID0gMDtcbiAgICBsZXQgcm93Qm90ID0gY29vcmRzLnRvcCwgcm93VG9wID0gY29vcmRzLnRvcDtcbiAgICBsZXQgZmlyc3RCZWxvdywgY29vcmRzQmVsb3c7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQsIGNoaWxkSW5kZXggPSAwOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZywgY2hpbGRJbmRleCsrKSB7XG4gICAgICAgIGxldCByZWN0cztcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICByZWN0cyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZWN0cyA9IHRleHRSYW5nZShjaGlsZCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPD0gcm93Qm90ICYmIHJlY3QuYm90dG9tID49IHJvd1RvcCkge1xuICAgICAgICAgICAgICAgIHJvd0JvdCA9IE1hdGgubWF4KHJlY3QuYm90dG9tLCByb3dCb3QpO1xuICAgICAgICAgICAgICAgIHJvd1RvcCA9IE1hdGgubWluKHJlY3QudG9wLCByb3dUb3ApO1xuICAgICAgICAgICAgICAgIGxldCBkeCA9IHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0ID8gcmVjdC5sZWZ0IC0gY29vcmRzLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgOiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyBjb29yZHMubGVmdCAtIHJlY3QucmlnaHQgOiAwO1xuICAgICAgICAgICAgICAgIGlmIChkeCA8IGR4Q2xvc2VzdCkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGR4Q2xvc2VzdCA9IGR4O1xuICAgICAgICAgICAgICAgICAgICBjb29yZHNDbG9zZXN0ID0gZHggJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAzID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcmVjdC5yaWdodCA8IGNvb3Jkcy5sZWZ0ID8gcmVjdC5yaWdodCA6IHJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogY29vcmRzLnRvcFxuICAgICAgICAgICAgICAgICAgICB9IDogY29vcmRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSAmJiBkeClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGNoaWxkSW5kZXggKyAoY29vcmRzLmxlZnQgPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVjdC50b3AgPiBjb29yZHMudG9wICYmICFmaXJzdEJlbG93ICYmIHJlY3QubGVmdCA8PSBjb29yZHMubGVmdCAmJiByZWN0LnJpZ2h0ID49IGNvb3Jkcy5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RCZWxvdyA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGNvb3Jkc0JlbG93ID0geyBsZWZ0OiBNYXRoLm1heChyZWN0LmxlZnQsIE1hdGgubWluKHJlY3QucmlnaHQsIGNvb3Jkcy5sZWZ0KSksIHRvcDogcmVjdC50b3AgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2xvc2VzdCAmJiAoY29vcmRzLmxlZnQgPj0gcmVjdC5yaWdodCAmJiBjb29yZHMudG9wID49IHJlY3QudG9wIHx8XG4gICAgICAgICAgICAgICAgY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0ICYmIGNvb3Jkcy50b3AgPj0gcmVjdC5ib3R0b20pKVxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGNoaWxkSW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2xvc2VzdCAmJiBmaXJzdEJlbG93KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBmaXJzdEJlbG93O1xuICAgICAgICBjb29yZHNDbG9zZXN0ID0gY29vcmRzQmVsb3c7XG4gICAgICAgIGR4Q2xvc2VzdCA9IDA7XG4gICAgfVxuICAgIGlmIChjbG9zZXN0ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIGZpbmRPZmZzZXRJblRleHQoY2xvc2VzdCwgY29vcmRzQ2xvc2VzdCk7XG4gICAgaWYgKCFjbG9zZXN0IHx8IChkeENsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAxKSlcbiAgICAgICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0IH07XG4gICAgcmV0dXJuIGZpbmRPZmZzZXRJbk5vZGUoY2xvc2VzdCwgY29vcmRzQ2xvc2VzdCk7XG59XG5mdW5jdGlvbiBmaW5kT2Zmc2V0SW5UZXh0KG5vZGUsIGNvb3Jkcykge1xuICAgIGxldCBsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJhbmdlLnNldEVuZChub2RlLCBpICsgMSk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGkpO1xuICAgICAgICBsZXQgcmVjdCA9IHNpbmdsZVJlY3QocmFuZ2UsIDEpO1xuICAgICAgICBpZiAocmVjdC50b3AgPT0gcmVjdC5ib3R0b20pXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGluUmVjdChjb29yZHMsIHJlY3QpKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiBpICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiAwIH07XG59XG5mdW5jdGlvbiBpblJlY3QoY29vcmRzLCByZWN0KSB7XG4gICAgcmV0dXJuIGNvb3Jkcy5sZWZ0ID49IHJlY3QubGVmdCAtIDEgJiYgY29vcmRzLmxlZnQgPD0gcmVjdC5yaWdodCArIDEgJiZcbiAgICAgICAgY29vcmRzLnRvcCA+PSByZWN0LnRvcCAtIDEgJiYgY29vcmRzLnRvcCA8PSByZWN0LmJvdHRvbSArIDE7XG59XG5mdW5jdGlvbiB0YXJnZXRLbHVkZ2UoZG9tLCBjb29yZHMpIHtcbiAgICBsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCAmJiAvXmxpJC9pLnRlc3QocGFyZW50Lm5vZGVOYW1lKSAmJiBjb29yZHMubGVmdCA8IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KVxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIHJldHVybiBkb207XG59XG5mdW5jdGlvbiBwb3NGcm9tRWxlbWVudCh2aWV3LCBlbHQsIGNvb3Jkcykge1xuICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gZmluZE9mZnNldEluTm9kZShlbHQsIGNvb3JkcyksIGJpYXMgPSAtMTtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmICFub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbGV0IHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBiaWFzID0gcmVjdC5sZWZ0ICE9IHJlY3QucmlnaHQgJiYgY29vcmRzLmxlZnQgPiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IC0xO1xuICAgIH1cbiAgICByZXR1cm4gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCBiaWFzKTtcbn1cbmZ1bmN0aW9uIHBvc0Zyb21DYXJldCh2aWV3LCBub2RlLCBvZmZzZXQsIGNvb3Jkcykge1xuICAgIC8vIEJyb3dzZXIgKGluIGNhcmV0UG9zaXRpb24vUmFuZ2VGcm9tUG9pbnQpIHdpbGwgYWdyZXNzaXZlbHlcbiAgICAvLyBub3JtYWxpemUgdG93YXJkcyBuZWFyYnkgaW5saW5lIG5vZGVzLiBTaW5jZSB3ZSBhcmUgaW50ZXJlc3RlZCBpblxuICAgIC8vIHBvc2l0aW9ucyBiZXR3ZWVuIGJsb2NrIG5vZGVzIHRvbywgd2UgZmlyc3Qgd2FsayB1cCB0aGUgaGllcmFyY2h5XG4gICAgLy8gb2Ygbm9kZXMgdG8gc2VlIGlmIHRoZXJlIGFyZSBibG9jayBub2RlcyB0aGF0IHRoZSBjb29yZGluYXRlc1xuICAgIC8vIGZhbGwgb3V0c2lkZSBvZi4gSWYgc28sIHdlIHRha2UgdGhlIHBvc2l0aW9uIGJlZm9yZS9hZnRlciB0aGF0XG4gICAgLy8gYmxvY2suIElmIG5vdCwgd2UgY2FsbCBgcG9zRnJvbURPTWAgb24gdGhlIHJhdyBub2RlL29mZnNldC5cbiAgICBsZXQgb3V0c2lkZUJsb2NrID0gLTE7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZSwgc2F3QmxvY2sgPSBmYWxzZTs7KSB7XG4gICAgICAgIGlmIChjdXIgPT0gdmlldy5kb20pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoY3VyLCB0cnVlKTtcbiAgICAgICAgaWYgKCFkZXNjKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChkZXNjLmRvbS5ub2RlVHlwZSA9PSAxICYmIChkZXNjLm5vZGUuaXNCbG9jayAmJiBkZXNjLnBhcmVudCAmJiAhc2F3QmxvY2sgfHwgIWRlc2MuY29udGVudERPTSkpIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gZGVzYy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBpZiAoZGVzYy5ub2RlLmlzQmxvY2sgJiYgZGVzYy5wYXJlbnQgJiYgIXNhd0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgc2F3QmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgPiBjb29yZHMubGVmdCB8fCByZWN0LnRvcCA+IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG91dHNpZGVCbG9jayA9IGRlc2MucG9zQmVmb3JlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCB8fCByZWN0LmJvdHRvbSA8IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG91dHNpZGVCbG9jayA9IGRlc2MucG9zQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRlc2MuY29udGVudERPTSAmJiBvdXRzaWRlQmxvY2sgPCAwICYmICFkZXNjLm5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGluc2lkZSBhIGxlYWYsIHJldHVybiB0aGUgc2lkZSBvZiB0aGUgbGVhZiBjbG9zZXIgdG8gdGhlIGNvb3Jkc1xuICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBkZXNjLm5vZGUuaXNCbG9jayA/IGNvb3Jkcy50b3AgPCAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyXG4gICAgICAgICAgICAgICAgICAgIDogY29vcmRzLmxlZnQgPCAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBiZWZvcmUgPyBkZXNjLnBvc0JlZm9yZSA6IGRlc2MucG9zQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VyID0gZGVzYy5kb20ucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHNpZGVCbG9jayA+IC0xID8gb3V0c2lkZUJsb2NrIDogdmlldy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCAtMSk7XG59XG5mdW5jdGlvbiBlbGVtZW50RnJvbVBvaW50KGVsZW1lbnQsIGNvb3JkcywgYm94KSB7XG4gICAgbGV0IGxlbiA9IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgaWYgKGxlbiAmJiBib3gudG9wIDwgYm94LmJvdHRvbSkge1xuICAgICAgICBmb3IgKGxldCBzdGFydEkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsZW4gLSAxLCBNYXRoLmZsb29yKGxlbiAqIChjb29yZHMudG9wIC0gYm94LnRvcCkgLyAoYm94LmJvdHRvbSAtIGJveC50b3ApKSAtIDIpKSwgaSA9IHN0YXJ0STs7KSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGxldCByZWN0cyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZWN0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudEZyb21Qb2ludChjaGlsZCwgY29vcmRzLCByZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgPSAoaSArIDEpICUgbGVuKSA9PSBzdGFydEkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vLyBHaXZlbiBhbiB4LHkgcG9zaXRpb24gb24gdGhlIGVkaXRvciwgZ2V0IHRoZSBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQuXG5mdW5jdGlvbiBwb3NBdENvb3Jkcyh2aWV3LCBjb29yZHMpIHtcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudCwgbm9kZSwgb2Zmc2V0ID0gMDtcbiAgICBsZXQgY2FyZXQgPSBjYXJldEZyb21Qb2ludChkb2MsIGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKTtcbiAgICBpZiAoY2FyZXQpXG4gICAgICAgICh7IG5vZGUsIG9mZnNldCB9ID0gY2FyZXQpO1xuICAgIGxldCBlbHQgPSAodmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQgPyB2aWV3LnJvb3QgOiBkb2MpXG4gICAgICAgIC5lbGVtZW50RnJvbVBvaW50KGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKTtcbiAgICBsZXQgcG9zO1xuICAgIGlmICghZWx0IHx8ICF2aWV3LmRvbS5jb250YWlucyhlbHQubm9kZVR5cGUgIT0gMSA/IGVsdC5wYXJlbnROb2RlIDogZWx0KSkge1xuICAgICAgICBsZXQgYm94ID0gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmICghaW5SZWN0KGNvb3JkcywgYm94KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBlbHQgPSBlbGVtZW50RnJvbVBvaW50KHZpZXcuZG9tLCBjb29yZHMsIGJveCk7XG4gICAgICAgIGlmICghZWx0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNhZmFyaSdzIGNhcmV0UmFuZ2VGcm9tUG9pbnQgcmV0dXJucyBub25zZW5zZSB3aGVuIG9uIGEgZHJhZ2dhYmxlIGVsZW1lbnRcbiAgICBpZiAoc2FmYXJpKSB7XG4gICAgICAgIGZvciAobGV0IHAgPSBlbHQ7IG5vZGUgJiYgcDsgcCA9IHBhcmVudE5vZGUocCkpXG4gICAgICAgICAgICBpZiAocC5kcmFnZ2FibGUpXG4gICAgICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWx0ID0gdGFyZ2V0S2x1ZGdlKGVsdCwgY29vcmRzKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgICBpZiAoZ2Vja28gJiYgbm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IHdpbGwgc29tZXRpbWVzIHJldHVybiBvZmZzZXRzIGludG8gPGlucHV0PiBub2Rlcywgd2hpY2hcbiAgICAgICAgICAgIC8vIGhhdmUgbm8gYWN0dWFsIGNoaWxkcmVuLCBmcm9tIGNhcmV0UG9zaXRpb25Gcm9tUG9pbnQgKCM5NTMpXG4gICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1pbihvZmZzZXQsIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgLy8gSXQnbGwgYWxzbyBtb3ZlIHRoZSByZXR1cm5lZCBwb3NpdGlvbiBiZWZvcmUgaW1hZ2Ugbm9kZXMsXG4gICAgICAgICAgICAvLyBldmVuIGlmIHRob3NlIGFyZSBiZWhpbmQgaXQuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF0sIGJveDtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5ub2RlTmFtZSA9PSBcIklNR1wiICYmIChib3ggPSBuZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKS5yaWdodCA8PSBjb29yZHMubGVmdCAmJlxuICAgICAgICAgICAgICAgICAgICBib3guYm90dG9tID4gY29vcmRzLnRvcClcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXY7XG4gICAgICAgIC8vIFdoZW4gY2xpY2tpbmcgYWJvdmUgdGhlIHJpZ2h0IHNpZGUgb2YgYW4gdW5lZGl0YWJsZSBub2RlLCBDaHJvbWUgd2lsbCByZXBvcnQgYSBjdXJzb3IgcG9zaXRpb24gYWZ0ZXIgdGhhdCBub2RlLlxuICAgICAgICBpZiAod2Via2l0ICYmIG9mZnNldCAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgKHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0pLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgICAgIHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiAmJiBwcmV2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA+PSBjb29yZHMudG9wKVxuICAgICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgIC8vIFN1c3BpY2lvdXNseSBzcGVjaWZpYyBrbHVkZ2UgdG8gd29yayBhcm91bmQgY2FyZXQqRnJvbVBvaW50XG4gICAgICAgIC8vIG5ldmVyIHJldHVybmluZyBhIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tICYmIG9mZnNldCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSAmJiBub2RlLmxhc3RDaGlsZC5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICBjb29yZHMudG9wID4gbm9kZS5sYXN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tKVxuICAgICAgICAgICAgcG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplO1xuICAgICAgICAvLyBJZ25vcmUgcG9zaXRpb25zIGRpcmVjdGx5IGFmdGVyIGEgQlIsIHNpbmNlIGNhcmV0KkZyb21Qb2ludFxuICAgICAgICAvLyAncm91bmQgdXAnIHBvc2l0aW9ucyB0aGF0IHdvdWxkIGJlIG1vcmUgYWNjdXJhdGVseSBwbGFjZWRcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBCUiBub2RlLlxuICAgICAgICBlbHNlIGlmIChvZmZzZXQgPT0gMCB8fCBub2RlLm5vZGVUeXBlICE9IDEgfHwgbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdLm5vZGVOYW1lICE9IFwiQlJcIilcbiAgICAgICAgICAgIHBvcyA9IHBvc0Zyb21DYXJldCh2aWV3LCBub2RlLCBvZmZzZXQsIGNvb3Jkcyk7XG4gICAgfVxuICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgcG9zID0gcG9zRnJvbUVsZW1lbnQodmlldywgZWx0LCBjb29yZHMpO1xuICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGVsdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHsgcG9zLCBpbnNpZGU6IGRlc2MgPyBkZXNjLnBvc0F0U3RhcnQgLSBkZXNjLmJvcmRlciA6IC0xIH07XG59XG5mdW5jdGlvbiBub25aZXJvKHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC50b3AgPCByZWN0LmJvdHRvbSB8fCByZWN0LmxlZnQgPCByZWN0LnJpZ2h0O1xufVxuZnVuY3Rpb24gc2luZ2xlUmVjdCh0YXJnZXQsIGJpYXMpIHtcbiAgICBsZXQgcmVjdHMgPSB0YXJnZXQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBpZiAocmVjdHMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IHJlY3RzW2JpYXMgPCAwID8gMCA6IHJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobm9uWmVybyhmaXJzdCkpXG4gICAgICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKHJlY3RzLCBub25aZXJvKSB8fCB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5jb25zdCBCSURJID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLztcbi8vIEdpdmVuIGEgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50IG1vZGVsLCBnZXQgYSBib3VuZGluZyBib3ggb2YgdGhlXG4vLyBjaGFyYWN0ZXIgYXQgdGhhdCBwb3NpdGlvbiwgcmVsYXRpdmUgdG8gdGhlIHdpbmRvdy5cbmZ1bmN0aW9uIGNvb3Jkc0F0UG9zKHZpZXcsIHBvcywgc2lkZSkge1xuICAgIGxldCB7IG5vZGUsIG9mZnNldCwgYXRvbSB9ID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCBzaWRlIDwgMCA/IC0xIDogMSk7XG4gICAgbGV0IHN1cHBvcnRFbXB0eVJhbmdlID0gd2Via2l0IHx8IGdlY2tvO1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgLy8gVGhlc2UgYnJvd3NlcnMgc3VwcG9ydCBxdWVyeWluZyBlbXB0eSB0ZXh0IHJhbmdlcy4gUHJlZmVyIHRoYXQgaW5cbiAgICAgICAgLy8gYmlkaSBjb250ZXh0IG9yIHdoZW4gYXQgdGhlIGVuZCBvZiBhIG5vZGUuXG4gICAgICAgIGlmIChzdXBwb3J0RW1wdHlSYW5nZSAmJiAoQklESS50ZXN0KG5vZGUubm9kZVZhbHVlKSB8fCAoc2lkZSA8IDAgPyAhb2Zmc2V0IDogb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkpKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCwgb2Zmc2V0KSwgc2lkZSk7XG4gICAgICAgICAgICAvLyBGaXJlZm94IHJldHVybnMgYmFkIHJlc3VsdHMgKHRoZSBwb3NpdGlvbiBiZWZvcmUgdGhlIHNwYWNlKVxuICAgICAgICAgICAgLy8gd2hlbiBxdWVyeWluZyBhIHBvc2l0aW9uIGRpcmVjdGx5IGFmdGVyIGxpbmUtYnJva2VuXG4gICAgICAgICAgICAvLyB3aGl0ZXNwYWNlLiBEZXRlY3QgdGhpcyBzaXR1YXRpb24gYW5kIGFuZCBrbHVkZ2UgYXJvdW5kIGl0XG4gICAgICAgICAgICBpZiAoZ2Vja28gJiYgb2Zmc2V0ICYmIC9cXHMvLnRlc3Qobm9kZS5ub2RlVmFsdWVbb2Zmc2V0IC0gMV0pICYmIG9mZnNldCA8IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCByZWN0QmVmb3JlID0gc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgb2Zmc2V0IC0gMSwgb2Zmc2V0IC0gMSksIC0xKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdEJlZm9yZS50b3AgPT0gcmVjdC50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RBZnRlciA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCwgb2Zmc2V0ICsgMSksIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RBZnRlci50b3AgIT0gcmVjdC50b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlblYocmVjdEFmdGVyLCByZWN0QWZ0ZXIubGVmdCA8IHJlY3RCZWZvcmUubGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IG9mZnNldCwgdG8gPSBvZmZzZXQsIHRha2VTaWRlID0gc2lkZSA8IDAgPyAxIDogLTE7XG4gICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgIW9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgdGFrZVNpZGUgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpZGUgPj0gMCAmJiBvZmZzZXQgPT0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgICAgIHRha2VTaWRlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpZGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBmcm9tLCB0byksIHRha2VTaWRlKSwgdGFrZVNpZGUgPCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgJGRvbSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zIC0gKGF0b20gfHwgMCkpO1xuICAgIC8vIFJldHVybiBhIGhvcml6b250YWwgbGluZSBpbiBibG9jayBjb250ZXh0XG4gICAgaWYgKCEkZG9tLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0ICYmIChzaWRlIDwgMCB8fCBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuSChiZWZvcmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCA8IG5vZGVTaXplKG5vZGUpKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChhZnRlci5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuSChhZnRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5IKG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHNpZGUgPj0gMCk7XG4gICAgfVxuICAgIC8vIElubGluZSwgbm90IGluIHRleHQgbm9kZSAodGhpcyBpcyBub3QgQmlkaS1zYWZlKVxuICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0ICYmIChzaWRlIDwgMCB8fCBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgIGxldCBiZWZvcmUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgIGxldCB0YXJnZXQgPSBiZWZvcmUubm9kZVR5cGUgPT0gMyA/IHRleHRSYW5nZShiZWZvcmUsIG5vZGVTaXplKGJlZm9yZSkgLSAoc3VwcG9ydEVtcHR5UmFuZ2UgPyAwIDogMSkpXG4gICAgICAgICAgICAvLyBCUiBub2RlcyB0ZW5kIHRvIG9ubHkgcmV0dXJuIHRoZSByZWN0YW5nbGUgYmVmb3JlIHRoZW0uXG4gICAgICAgICAgICAvLyBPbmx5IHVzZSB0aGVtIGlmIHRoZXkgYXJlIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlaXIgcGFyZW50XG4gICAgICAgICAgICA6IGJlZm9yZS5ub2RlVHlwZSA9PSAxICYmIChiZWZvcmUubm9kZU5hbWUgIT0gXCJCUlwiIHx8ICFiZWZvcmUubmV4dFNpYmxpbmcpID8gYmVmb3JlIDogbnVsbDtcbiAgICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KHRhcmdldCwgMSksIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgd2hpbGUgKGFmdGVyLnBtVmlld0Rlc2MgJiYgYWZ0ZXIucG1WaWV3RGVzYy5pZ25vcmVGb3JDb29yZHMpXG4gICAgICAgICAgICBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gIWFmdGVyID8gbnVsbCA6IGFmdGVyLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoYWZ0ZXIsIDAsIChzdXBwb3J0RW1wdHlSYW5nZSA/IDAgOiAxKSlcbiAgICAgICAgICAgIDogYWZ0ZXIubm9kZVR5cGUgPT0gMSA/IGFmdGVyIDogbnVsbDtcbiAgICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KHRhcmdldCwgLTEpLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gQWxsIGVsc2UgZmFpbGVkLCBqdXN0IHRyeSB0byBnZXQgYSByZWN0YW5nbGUgZm9yIHRoZSB0YXJnZXQgbm9kZVxuICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KG5vZGUubm9kZVR5cGUgPT0gMyA/IHRleHRSYW5nZShub2RlKSA6IG5vZGUsIC1zaWRlKSwgc2lkZSA+PSAwKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5WKHJlY3QsIGxlZnQpIHtcbiAgICBpZiAocmVjdC53aWR0aCA9PSAwKVxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICBsZXQgeCA9IGxlZnQgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0O1xuICAgIHJldHVybiB7IHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC5ib3R0b20sIGxlZnQ6IHgsIHJpZ2h0OiB4IH07XG59XG5mdW5jdGlvbiBmbGF0dGVuSChyZWN0LCB0b3ApIHtcbiAgICBpZiAocmVjdC5oZWlnaHQgPT0gMClcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgbGV0IHkgPSB0b3AgPyByZWN0LnRvcCA6IHJlY3QuYm90dG9tO1xuICAgIHJldHVybiB7IHRvcDogeSwgYm90dG9tOiB5LCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0IH07XG59XG5mdW5jdGlvbiB3aXRoRmx1c2hlZFN0YXRlKHZpZXcsIHN0YXRlLCBmKSB7XG4gICAgbGV0IHZpZXdTdGF0ZSA9IHZpZXcuc3RhdGUsIGFjdGl2ZSA9IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50O1xuICAgIGlmICh2aWV3U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgIHZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgIGlmIChhY3RpdmUgIT0gdmlldy5kb20pXG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZigpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHZpZXdTdGF0ZSAhPSBzdGF0ZSlcbiAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlld1N0YXRlKTtcbiAgICAgICAgaWYgKGFjdGl2ZSAhPSB2aWV3LmRvbSAmJiBhY3RpdmUpXG4gICAgICAgICAgICBhY3RpdmUuZm9jdXMoKTtcbiAgICB9XG59XG4vLyBXaGV0aGVyIHZlcnRpY2FsIHBvc2l0aW9uIG1vdGlvbiBpbiBhIGdpdmVuIGRpcmVjdGlvblxuLy8gZnJvbSBhIHBvc2l0aW9uIHdvdWxkIGxlYXZlIGEgdGV4dCBibG9jay5cbmZ1bmN0aW9uIGVuZE9mVGV4dGJsb2NrVmVydGljYWwodmlldywgc3RhdGUsIGRpcikge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0ICRwb3MgPSBkaXIgPT0gXCJ1cFwiID8gc2VsLiRmcm9tIDogc2VsLiR0bztcbiAgICByZXR1cm4gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgKCkgPT4ge1xuICAgICAgICBsZXQgeyBub2RlOiBkb20gfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKCRwb3MucG9zLCBkaXIgPT0gXCJ1cFwiID8gLTEgOiAxKTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5lYXJlc3QgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghbmVhcmVzdClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChuZWFyZXN0Lm5vZGUuaXNCbG9jaykge1xuICAgICAgICAgICAgICAgIGRvbSA9IG5lYXJlc3QuY29udGVudERPTSB8fCBuZWFyZXN0LmRvbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbSA9IG5lYXJlc3QuZG9tLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvb3JkcyA9IGNvb3Jkc0F0UG9zKHZpZXcsICRwb3MucG9zLCAxKTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgPSBkb20uZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGxldCBib3hlcztcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIGJveGVzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAgYm94ZXMgPSB0ZXh0UmFuZ2UoY2hpbGQsIDAsIGNoaWxkLm5vZGVWYWx1ZS5sZW5ndGgpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJveCA9IGJveGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChib3guYm90dG9tID4gYm94LnRvcCArIDEgJiZcbiAgICAgICAgICAgICAgICAgICAgKGRpciA9PSBcInVwXCIgPyBjb29yZHMudG9wIC0gYm94LnRvcCA+IChib3guYm90dG9tIC0gY29vcmRzLnRvcCkgKiAyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGJveC5ib3R0b20gLSBjb29yZHMuYm90dG9tID4gKGNvb3Jkcy5ib3R0b20gLSBib3gudG9wKSAqIDIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG59XG5jb25zdCBtYXliZVJUTCA9IC9bXFx1MDU5MC1cXHUwOGFjXS87XG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja0hvcml6b250YWwodmlldywgc3RhdGUsIGRpcikge1xuICAgIGxldCB7ICRoZWFkIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gJGhlYWQucGFyZW50T2Zmc2V0LCBhdFN0YXJ0ID0gIW9mZnNldCwgYXRFbmQgPSBvZmZzZXQgPT0gJGhlYWQucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgICAvLyBJZiB0aGUgdGV4dGJsb2NrIGlzIGFsbCBMVFIsIG9yIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydFxuICAgIC8vIFNlbGVjdGlvbi5tb2RpZnkgKEVkZ2UpLCBmYWxsIGJhY2sgdG8gYSBwcmltaXRpdmUgYXBwcm9hY2hcbiAgICBpZiAoIW1heWJlUlRMLnRlc3QoJGhlYWQucGFyZW50LnRleHRDb250ZW50KSB8fCAhc2VsLm1vZGlmeSlcbiAgICAgICAgcmV0dXJuIGRpciA9PSBcImxlZnRcIiB8fCBkaXIgPT0gXCJiYWNrd2FyZFwiID8gYXRTdGFydCA6IGF0RW5kO1xuICAgIHJldHVybiB3aXRoRmx1c2hlZFN0YXRlKHZpZXcsIHN0YXRlLCAoKSA9PiB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBodWdlIGhhY2ssIGJ1dCBhcHBlYXJzIHRvIGJlIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBjdXJyZW50bHkgZG86IHVzZSBgU2VsZWN0aW9uLm1vZGlmeWAgdG8gbW92ZSB0aGUgc2VsZWN0aW9uIGJ5XG4gICAgICAgIC8vIG9uZSBjaGFyYWN0ZXIsIGFuZCBzZWUgaWYgdGhhdCBtb3ZlcyB0aGUgY3Vyc29yIG91dCBvZiB0aGVcbiAgICAgICAgLy8gdGV4dGJsb2NrIChvciBkb2Vzbid0IG1vdmUgaXQgYXQgYWxsLCB3aGVuIGF0IHRoZSBzdGFydC9lbmQgb2ZcbiAgICAgICAgLy8gdGhlIGRvY3VtZW50KS5cbiAgICAgICAgbGV0IHsgZm9jdXNOb2RlOiBvbGROb2RlLCBmb2N1c09mZnNldDogb2xkT2ZmLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG9sZEJpZGlMZXZlbCA9IHNlbC5jYXJldEJpZGlMZXZlbCAvLyBPbmx5IGZvciBGaXJlZm94XG4gICAgICAgIDtcbiAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgZGlyLCBcImNoYXJhY3RlclwiKTtcbiAgICAgICAgbGV0IHBhcmVudERPTSA9ICRoZWFkLmRlcHRoID8gdmlldy5kb2NWaWV3LmRvbUFmdGVyUG9zKCRoZWFkLmJlZm9yZSgpKSA6IHZpZXcuZG9tO1xuICAgICAgICBsZXQgeyBmb2N1c05vZGU6IG5ld05vZGUsIGZvY3VzT2Zmc2V0OiBuZXdPZmYgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ld05vZGUgJiYgIXBhcmVudERPTS5jb250YWlucyhuZXdOb2RlLm5vZGVUeXBlID09IDEgPyBuZXdOb2RlIDogbmV3Tm9kZS5wYXJlbnROb2RlKSB8fFxuICAgICAgICAgICAgKG9sZE5vZGUgPT0gbmV3Tm9kZSAmJiBvbGRPZmYgPT0gbmV3T2ZmKTtcbiAgICAgICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZWwuY29sbGFwc2UoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChvbGROb2RlICYmIChvbGROb2RlICE9IGFuY2hvck5vZGUgfHwgb2xkT2ZmICE9IGFuY2hvck9mZnNldCkgJiYgc2VsLmV4dGVuZClcbiAgICAgICAgICAgICAgICBzZWwuZXh0ZW5kKG9sZE5vZGUsIG9sZE9mZik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICBpZiAob2xkQmlkaUxldmVsICE9IG51bGwpXG4gICAgICAgICAgICBzZWwuY2FyZXRCaWRpTGV2ZWwgPSBvbGRCaWRpTGV2ZWw7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG59XG5sZXQgY2FjaGVkU3RhdGUgPSBudWxsO1xubGV0IGNhY2hlZERpciA9IG51bGw7XG5sZXQgY2FjaGVkUmVzdWx0ID0gZmFsc2U7XG5mdW5jdGlvbiBlbmRPZlRleHRibG9jayh2aWV3LCBzdGF0ZSwgZGlyKSB7XG4gICAgaWYgKGNhY2hlZFN0YXRlID09IHN0YXRlICYmIGNhY2hlZERpciA9PSBkaXIpXG4gICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgY2FjaGVkU3RhdGUgPSBzdGF0ZTtcbiAgICBjYWNoZWREaXIgPSBkaXI7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdCA9IGRpciA9PSBcInVwXCIgfHwgZGlyID09IFwiZG93blwiXG4gICAgICAgID8gZW5kT2ZUZXh0YmxvY2tWZXJ0aWNhbCh2aWV3LCBzdGF0ZSwgZGlyKVxuICAgICAgICA6IGVuZE9mVGV4dGJsb2NrSG9yaXpvbnRhbCh2aWV3LCBzdGF0ZSwgZGlyKTtcbn1cblxuLy8gVmlldyBkZXNjcmlwdGlvbnMgYXJlIGRhdGEgc3RydWN0dXJlcyB0aGF0IGRlc2NyaWJlIHRoZSBET00gdGhhdCBpc1xuLy8gdXNlZCB0byByZXByZXNlbnQgdGhlIGVkaXRvcidzIGNvbnRlbnQuIFRoZXkgYXJlIHVzZWQgZm9yOlxuLy9cbi8vIC0gSW5jcmVtZW50YWwgcmVkcmF3aW5nIHdoZW4gdGhlIGRvY3VtZW50IGNoYW5nZXNcbi8vXG4vLyAtIEZpZ3VyaW5nIG91dCB3aGF0IHBhcnQgb2YgdGhlIGRvY3VtZW50IGEgZ2l2ZW4gRE9NIHBvc2l0aW9uXG4vLyAgIGNvcnJlc3BvbmRzIHRvXG4vL1xuLy8gLSBXaXJpbmcgaW4gY3VzdG9tIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgZWRpdGluZyBpbnRlcmZhY2UgZm9yIGFcbi8vICAgZ2l2ZW4gbm9kZVxuLy9cbi8vIFRoZXkgZm9ybSBhIGRvdWJseS1saW5rZWQgbXV0YWJsZSB0cmVlLCBzdGFydGluZyBhdCBgdmlldy5kb2NWaWV3YC5cbmNvbnN0IE5PVF9ESVJUWSA9IDAsIENISUxEX0RJUlRZID0gMSwgQ09OVEVOVF9ESVJUWSA9IDIsIE5PREVfRElSVFkgPSAzO1xuLy8gU3VwZXJjbGFzcyBmb3IgdGhlIHZhcmlvdXMga2luZHMgb2YgZGVzY3JpcHRpb25zLiBEZWZpbmVzIHRoZWlyXG4vLyBiYXNpYyBzdHJ1Y3R1cmUgYW5kIHNoYXJlZCBtZXRob2RzLlxuY2xhc3MgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgY2hpbGRyZW4sIGRvbSwgXG4gICAgLy8gVGhpcyBpcyB0aGUgbm9kZSB0aGF0IGhvbGRzIHRoZSBjaGlsZCB2aWV3cy4gSXQgbWF5IGJlIG51bGwgZm9yXG4gICAgLy8gZGVzY3MgdGhhdCBkb24ndCBoYXZlIGNoaWxkcmVuLlxuICAgIGNvbnRlbnRET00pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIHRoaXMuY29udGVudERPTSA9IGNvbnRlbnRET007XG4gICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgIC8vIEFuIGV4cGFuZG8gcHJvcGVydHkgb24gdGhlIERPTSBub2RlIHByb3ZpZGVzIGEgbGluayBiYWNrIHRvIGl0c1xuICAgICAgICAvLyBkZXNjcmlwdGlvbi5cbiAgICAgICAgZG9tLnBtVmlld0Rlc2MgPSB0aGlzO1xuICAgIH1cbiAgICAvLyBVc2VkIHRvIGNoZWNrIHdoZXRoZXIgYSBnaXZlbiBkZXNjcmlwdGlvbiBjb3JyZXNwb25kcyB0byBhXG4gICAgLy8gd2lkZ2V0L21hcmsvbm9kZS5cbiAgICBtYXRjaGVzV2lkZ2V0KHdpZGdldCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzTWFyayhtYXJrKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1hdGNoZXNIYWNrKG5vZGVOYW1lKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIFdoZW4gcGFyc2luZyBpbi1lZGl0b3IgY29udGVudCAoaW4gZG9tY2hhbmdlLmpzKSwgd2UgYWxsb3dcbiAgICAvLyBkZXNjcmlwdGlvbnMgdG8gZGV0ZXJtaW5lIHRoZSBwYXJzZSBydWxlcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvXG4gICAgLy8gcGFyc2UgdGhlbS5cbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiBudWxsOyB9XG4gICAgLy8gVXNlZCBieSB0aGUgZWRpdG9yJ3MgZXZlbnQgaGFuZGxlciB0byBpZ25vcmUgZXZlbnRzIHRoYXQgY29tZVxuICAgIC8vIGZyb20gY2VydGFpbiBkZXNjcy5cbiAgICBzdG9wRXZlbnQoZXZlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLy8gVGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgcmVwcmVzZW50ZWQgYnkgdGhpcyBkZXNjLlxuICAgIGdldCBzaXplKCkge1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHNpemUgKz0gdGhpcy5jaGlsZHJlbltpXS5zaXplO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgLy8gRm9yIGJsb2NrIG5vZGVzLCB0aGlzIHJlcHJlc2VudHMgdGhlIHNwYWNlIHRha2VuIHVwIGJ5IHRoZWlyXG4gICAgLy8gc3RhcnQvZW5kIHRva2Vucy5cbiAgICBnZXQgYm9yZGVyKCkgeyByZXR1cm4gMDsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5kb20ucG1WaWV3RGVzYyA9PSB0aGlzKVxuICAgICAgICAgICAgdGhpcy5kb20ucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHBvc0JlZm9yZUNoaWxkKGNoaWxkKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSB0aGlzLnBvc0F0U3RhcnQ7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGN1ciA9PSBjaGlsZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGN1ci5zaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwb3NCZWZvcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHBvc0F0U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBvc0JlZm9yZUNoaWxkKHRoaXMpICsgdGhpcy5ib3JkZXIgOiAwO1xuICAgIH1cbiAgICBnZXQgcG9zQWZ0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0JlZm9yZSArIHRoaXMuc2l6ZTtcbiAgICB9XG4gICAgZ2V0IHBvc0F0RW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5zaXplIC0gMiAqIHRoaXMuYm9yZGVyO1xuICAgIH1cbiAgICBsb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICAgICAgLy8gSWYgdGhlIERPTSBwb3NpdGlvbiBpcyBpbiB0aGUgY29udGVudCwgdXNlIHRoZSBjaGlsZCBkZXNjIGFmdGVyXG4gICAgICAgIC8vIGl0IHRvIGZpZ3VyZSBvdXQgYSBwb3NpdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00uY29udGFpbnMoZG9tLm5vZGVUeXBlID09IDEgPyBkb20gOiBkb20ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChiaWFzIDwgMCkge1xuICAgICAgICAgICAgICAgIGxldCBkb21CZWZvcmUsIGRlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tQmVmb3JlID0gZG9tLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChkb21CZWZvcmUgJiYgISgoZGVzYyA9IGRvbUJlZm9yZS5wbVZpZXdEZXNjKSAmJiBkZXNjLnBhcmVudCA9PSB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgZG9tQmVmb3JlID0gZG9tQmVmb3JlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQmVmb3JlID8gdGhpcy5wb3NCZWZvcmVDaGlsZChkZXNjKSArIGRlc2Muc2l6ZSA6IHRoaXMucG9zQXRTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBkb21BZnRlciwgZGVzYztcbiAgICAgICAgICAgICAgICBpZiAoZG9tID09IHRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRvbUFmdGVyID0gZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tQWZ0ZXIgJiYgISgoZGVzYyA9IGRvbUFmdGVyLnBtVmlld0Rlc2MpICYmIGRlc2MucGFyZW50ID09IHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbUFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb21BZnRlciA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYykgOiB0aGlzLnBvc0F0RW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIHZhcmlvdXMgaGV1cmlzdGljcywgZmFsbGluZyBiYWNrIG9uIHRoZSBiaWFzXG4gICAgICAgIC8vIHBhcmFtZXRlciwgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmV0dXJuIHRoZSBwb3NpdGlvbiBhdCB0aGVcbiAgICAgICAgLy8gc3RhcnQgb3IgYXQgdGhlIGVuZCBvZiB0aGlzIHZpZXcgZGVzYy5cbiAgICAgICAgbGV0IGF0RW5kO1xuICAgICAgICBpZiAoZG9tID09IHRoaXMuZG9tICYmIHRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgYXRFbmQgPSBvZmZzZXQgPiBkb21JbmRleCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgdGhpcy5kb20uY29udGFpbnModGhpcy5jb250ZW50RE9NKSkge1xuICAgICAgICAgICAgYXRFbmQgPSBkb20uY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcy5jb250ZW50RE9NKSAmIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb20uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSAwKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IGRvbTs7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0RW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoLnByZXZpb3VzU2libGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdEVuZCA9PSBudWxsICYmIG9mZnNldCA9PSBkb20uY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2VhcmNoID0gZG9tOzsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaCA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGF0RW5kID09IG51bGwgPyBiaWFzID4gMCA6IGF0RW5kKSA/IHRoaXMucG9zQXRFbmQgOiB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgfVxuICAgIG5lYXJlc3REZXNjKGRvbSwgb25seU5vZGVzID0gZmFsc2UpIHtcbiAgICAgICAgZm9yIChsZXQgZmlyc3QgPSB0cnVlLCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gdGhpcy5nZXREZXNjKGN1ciksIG5vZGVET007XG4gICAgICAgICAgICBpZiAoZGVzYyAmJiAoIW9ubHlOb2RlcyB8fCBkZXNjLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgZG9tIGlzIG91dHNpZGUgb2YgdGhpcyBkZXNjJ3Mgbm9kZURPTSwgZG9uJ3QgY291bnQgaXQuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0ICYmIChub2RlRE9NID0gZGVzYy5ub2RlRE9NKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKG5vZGVET00ubm9kZVR5cGUgPT0gMSA/IG5vZGVET00uY29udGFpbnMoZG9tLm5vZGVUeXBlID09IDEgPyBkb20gOiBkb20ucGFyZW50Tm9kZSkgOiBub2RlRE9NID09IGRvbSkpXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREZXNjKGRvbSkge1xuICAgICAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBkZXNjOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgICAgICBpZiAoY3VyID09IHRoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxuICAgIHBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IGRvbTsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbGV0IGRlc2MgPSB0aGlzLmdldERlc2Moc2Nhbik7XG4gICAgICAgICAgICBpZiAoZGVzYylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgZGVzYyBmb3IgdGhlIG5vZGUgYWZ0ZXIgdGhlIGdpdmVuIHBvcywgaWYgYW55LiAoV2hlbiBhXG4gICAgLy8gcGFyZW50IG5vZGUgb3ZlcnJvZGUgcmVuZGVyaW5nLCB0aGVyZSBtaWdodCBub3QgYmUgb25lLilcbiAgICBkZXNjQXQocG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gcG9zICYmIGVuZCAhPSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWNoaWxkLmJvcmRlciAmJiBjaGlsZC5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuZGVzY0F0KHBvcyAtIG9mZnNldCAtIGNoaWxkLmJvcmRlcik7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9tRnJvbVBvcyhwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmRvbSwgb2Zmc2V0OiAwLCBhdG9tOiBwb3MgKyAxIH07XG4gICAgICAgIC8vIEZpcnN0IGZpbmQgdGhlIHBvc2l0aW9uIGluIHRoZSBjaGlsZCBhcnJheVxuICAgICAgICBsZXQgaSA9IDAsIG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGN1clBvcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBjdXJQb3MgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHBvcyB8fCBjaGlsZCBpbnN0YW5jZW9mIFRyYWlsaW5nSGFja1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcG9zIC0gY3VyUG9zO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgcG9pbnRzIGludG8gdGhlIG1pZGRsZSBvZiBhIGNoaWxkLCBjYWxsIHRocm91Z2hcbiAgICAgICAgaWYgKG9mZnNldClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldLmRvbUZyb21Qb3Mob2Zmc2V0IC0gdGhpcy5jaGlsZHJlbltpXS5ib3JkZXIsIHNpZGUpO1xuICAgICAgICAvLyBHbyBiYWNrIGlmIHRoZXJlIHdlcmUgYW55IHplcm8tbGVuZ3RoIHdpZGdldHMgd2l0aCBzaWRlID49IDAgYmVmb3JlIHRoaXMgcG9pbnRcbiAgICAgICAgZm9yIChsZXQgcHJldjsgaSAmJiAhKHByZXYgPSB0aGlzLmNoaWxkcmVuW2kgLSAxXSkuc2l6ZSAmJiBwcmV2IGluc3RhbmNlb2YgV2lkZ2V0Vmlld0Rlc2MgJiYgcHJldi5zaWRlID49IDA7IGktLSkgeyB9XG4gICAgICAgIC8vIFNjYW4gdG93YXJkcyB0aGUgZmlyc3QgdXNlYWJsZSBub2RlXG4gICAgICAgIGlmIChzaWRlIDw9IDApIHtcbiAgICAgICAgICAgIGxldCBwcmV2LCBlbnRlciA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKDs7IGktLSwgZW50ZXIgPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBpID8gdGhpcy5jaGlsZHJlbltpIC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghcHJldiB8fCBwcmV2LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldiAmJiBzaWRlICYmIGVudGVyICYmICFwcmV2LmJvcmRlciAmJiAhcHJldi5kb21BdG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2LmRvbUZyb21Qb3MocHJldi5zaXplLCBzaWRlKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgb2Zmc2V0OiBwcmV2ID8gZG9tSW5kZXgocHJldi5kb20pICsgMSA6IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXh0LCBlbnRlciA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKDs7IGkrKywgZW50ZXIgPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggPyB0aGlzLmNoaWxkcmVuW2ldIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgJiYgZW50ZXIgJiYgIW5leHQuYm9yZGVyICYmICFuZXh0LmRvbUF0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQuZG9tRnJvbVBvcygwLCBzaWRlKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgb2Zmc2V0OiBuZXh0ID8gZG9tSW5kZXgobmV4dC5kb20pIDogdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlZCB0byBmaW5kIGEgRE9NIHJhbmdlIGluIGEgc2luZ2xlIHBhcmVudCBmb3IgYSBnaXZlbiBjaGFuZ2VkXG4gICAgLy8gcmFuZ2UuXG4gICAgcGFyc2VSYW5nZShmcm9tLCB0bywgYmFzZSA9IDApIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIGZyb20sIHRvLCBmcm9tT2Zmc2V0OiAwLCB0b09mZnNldDogdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoIH07XG4gICAgICAgIGxldCBmcm9tT2Zmc2V0ID0gLTEsIHRvT2Zmc2V0ID0gLTE7XG4gICAgICAgIGZvciAobGV0IG9mZnNldCA9IGJhc2UsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGZyb21PZmZzZXQgPT0gLTEgJiYgZnJvbSA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRCYXNlID0gb2Zmc2V0ICsgY2hpbGQuYm9yZGVyO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIG1heWJlIGRlc2NlbmQgbWFyayB2aWV3cyB0byBwYXJzZSBhIG5hcnJvd2VyIHJhbmdlP1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGNoaWxkQmFzZSAmJiB0byA8PSBlbmQgLSBjaGlsZC5ib3JkZXIgJiYgY2hpbGQubm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTS5jb250YWlucyhjaGlsZC5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnBhcnNlUmFuZ2UoZnJvbSwgdG8sIGNoaWxkQmFzZSk7XG4gICAgICAgICAgICAgICAgZnJvbSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldiA9IHRoaXMuY2hpbGRyZW5baiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldi5zaXplICYmIHByZXYuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFwcmV2LmVtcHR5Q2hpbGRBdCgxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbU9mZnNldCA9IGRvbUluZGV4KHByZXYuZG9tKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmcm9tIC09IHByZXYuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZyb21PZmZzZXQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGZyb21PZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb21PZmZzZXQgPiAtMSAmJiAoZW5kID4gdG8gfHwgaSA9PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgdG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LnNpemUgJiYgbmV4dC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIW5leHQuZW1wdHlDaGlsZEF0KC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9PZmZzZXQgPSBkb21JbmRleChuZXh0LmRvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0byArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b09mZnNldCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdG9PZmZzZXQgPSB0aGlzLmNvbnRlbnRET00uY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tLCB0bywgZnJvbU9mZnNldCwgdG9PZmZzZXQgfTtcbiAgICB9XG4gICAgZW1wdHlDaGlsZEF0KHNpZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYm9yZGVyIHx8ICF0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW3NpZGUgPCAwID8gMCA6IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBjaGlsZC5zaXplID09IDAgfHwgY2hpbGQuZW1wdHlDaGlsZEF0KHNpZGUpO1xuICAgIH1cbiAgICBkb21BZnRlclBvcyhwb3MpIHtcbiAgICAgICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSB0aGlzLmRvbUZyb21Qb3MocG9zLCAwKTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSB8fCBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhZnRlciBwb3MgXCIgKyBwb3MpO1xuICAgICAgICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgfVxuICAgIC8vIFZpZXcgZGVzY3MgYXJlIHJlc3BvbnNpYmxlIGZvciBzZXR0aW5nIGFueSBzZWxlY3Rpb24gdGhhdCBmYWxsc1xuICAgIC8vIGVudGlyZWx5IGluc2lkZSBvZiB0aGVtLCBzbyB0aGF0IGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgY2FuIGRvXG4gICAgLy8gY3VzdG9tIHRoaW5ncyB3aXRoIHRoZSBzZWxlY3Rpb24uIE5vdGUgdGhhdCB0aGlzIGZhbGxzIGFwYXJ0IHdoZW5cbiAgICAvLyBhIHNlbGVjdGlvbiBzdGFydHMgaW4gc3VjaCBhIG5vZGUgYW5kIGVuZHMgaW4gYW5vdGhlciwgaW4gd2hpY2hcbiAgICAvLyBjYXNlIHdlIGp1c3QgdXNlIHdoYXRldmVyIGRvbUZyb21Qb3MgcHJvZHVjZXMgYXMgYSBiZXN0IGVmZm9ydC5cbiAgICBzZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290LCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gZmFsbHMgZW50aXJlbHkgaW4gYSBjaGlsZCwgZ2l2ZSBpdCB0byB0aGF0IGNoaWxkXG4gICAgICAgIGxldCBmcm9tID0gTWF0aC5taW4oYW5jaG9yLCBoZWFkKSwgdG8gPSBNYXRoLm1heChhbmNob3IsIGhlYWQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IG9mZnNldCAmJiB0byA8IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuc2V0U2VsZWN0aW9uKGFuY2hvciAtIG9mZnNldCAtIGNoaWxkLmJvcmRlciwgaGVhZCAtIG9mZnNldCAtIGNoaWxkLmJvcmRlciwgcm9vdCwgZm9yY2UpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbmNob3JET00gPSB0aGlzLmRvbUZyb21Qb3MoYW5jaG9yLCBhbmNob3IgPyAtMSA6IDEpO1xuICAgICAgICBsZXQgaGVhZERPTSA9IGhlYWQgPT0gYW5jaG9yID8gYW5jaG9yRE9NIDogdGhpcy5kb21Gcm9tUG9zKGhlYWQsIGhlYWQgPyAtMSA6IDEpO1xuICAgICAgICBsZXQgZG9tU2VsID0gcm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IGJyS2x1ZGdlID0gZmFsc2U7XG4gICAgICAgIC8vIE9uIEZpcmVmb3gsIHVzaW5nIFNlbGVjdGlvbi5jb2xsYXBzZSB0byBwdXQgdGhlIGN1cnNvciBhZnRlciBhXG4gICAgICAgIC8vIEJSIG5vZGUgZm9yIHNvbWUgcmVhc29uIGRvZXNuJ3QgYWx3YXlzIHdvcmsgKCMxMDczKS4gT24gU2FmYXJpLFxuICAgICAgICAvLyB0aGUgY3Vyc29yIHNvbWV0aW1lcyBpbmV4cGxpY2FibGUgdmlzdWFsbHkgbGFncyBiZWhpbmQgaXRzXG4gICAgICAgIC8vIHJlcG9ydGVkIHBvc2l0aW9uIGluIHN1Y2ggc2l0dWF0aW9ucyAoIzEwOTIpLlxuICAgICAgICBpZiAoKGdlY2tvIHx8IHNhZmFyaSkgJiYgYW5jaG9yID09IGhlYWQpIHtcbiAgICAgICAgICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gYW5jaG9yRE9NO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgIGJyS2x1ZGdlID0gISEob2Zmc2V0ICYmIG5vZGUubm9kZVZhbHVlW29mZnNldCAtIDFdID09IFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIC8vIElzc3VlICMxMTI4XG4gICAgICAgICAgICAgICAgaWYgKGJyS2x1ZGdlICYmIG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc2NhbiA9IG5vZGUsIGFmdGVyOyBzY2FuOyBzY2FuID0gc2Nhbi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIgPSBzY2FuLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFmdGVyLm5vZGVOYW1lID09IFwiQlJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yRE9NID0gaGVhZERPTSA9IHsgbm9kZTogYWZ0ZXIucGFyZW50Tm9kZSwgb2Zmc2V0OiBkb21JbmRleChhZnRlcikgKyAxIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVzYyA9IHNjYW4ucG1WaWV3RGVzYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIGJyS2x1ZGdlID0gcHJldiAmJiAocHJldi5ub2RlTmFtZSA9PSBcIkJSXCIgfHwgcHJldi5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJlZm94IGNhbiBhY3Qgc3RyYW5nZWx5IHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBpbiBmcm9udCBvZiBhblxuICAgICAgICAvLyB1bmVkaXRhYmxlIG5vZGUuIFNlZSAjMTE2MyBhbmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTcwOTUzNlxuICAgICAgICBpZiAoZ2Vja28gJiYgZG9tU2VsLmZvY3VzTm9kZSAmJiBkb21TZWwuZm9jdXNOb2RlICE9IGhlYWRET00ubm9kZSAmJiBkb21TZWwuZm9jdXNOb2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGRvbVNlbC5mb2N1c05vZGUuY2hpbGROb2Rlc1tkb21TZWwuZm9jdXNPZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGFmdGVyICYmIGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGZvcmNlIHx8IGJyS2x1ZGdlICYmIHNhZmFyaSkgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCkgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQsIGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFNlbGVjdGlvbi5leHRlbmQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuICdpbnZlcnRlZCcgc2VsZWN0aW9uXG4gICAgICAgIC8vIChvbmUgd2hlcmUgdGhlIGZvY3VzIGlzIGJlZm9yZSB0aGUgYW5jaG9yKSwgYnV0IG5vdCBhbGxcbiAgICAgICAgLy8gYnJvd3NlcnMgc3VwcG9ydCBpdCB5ZXQuXG4gICAgICAgIGxldCBkb21TZWxFeHRlbmRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoKGRvbVNlbC5leHRlbmQgfHwgYW5jaG9yID09IGhlYWQpICYmICFicktsdWRnZSkge1xuICAgICAgICAgICAgZG9tU2VsLmNvbGxhcHNlKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvciAhPSBoZWFkKVxuICAgICAgICAgICAgICAgICAgICBkb21TZWwuZXh0ZW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGRvbVNlbEV4dGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcyB3aXRoIENocm9tZSB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFmdGVyIGNhbGxpbmdcbiAgICAgICAgICAgICAgICAvLyBjb2xsYXBzZSwgZXZlbiB3aGVuIGl0IHNob3VsZCBiZSB2YWxpZC4gVGhpcyBhcHBlYXJzIHRvIGJlIGEgYnVnLCBidXRcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyBkaWZmaWN1bHQgdG8gaXNvbGF0ZS4gSWYgdGhpcyBoYXBwZW5zIGZhbGxiYWNrIHRvIHRoZSBvbGQgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgdXNpbmcgZXh0ZW5kLlxuICAgICAgICAgICAgICAgIC8vIFNpbWlsYXJseSwgdGhpcyBjb3VsZCBjcmFzaCBvbiBTYWZhcmkgaWYgdGhlIGVkaXRvciBpcyBoaWRkZW4sIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIHdhcyBubyBzZWxlY3Rpb24uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb21TZWxFeHRlbmRlZCkge1xuICAgICAgICAgICAgaWYgKGFuY2hvciA+IGhlYWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG1wID0gYW5jaG9yRE9NO1xuICAgICAgICAgICAgICAgIGFuY2hvckRPTSA9IGhlYWRET007XG4gICAgICAgICAgICAgICAgaGVhZERPTSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQoaGVhZERPTS5ub2RlLCBoZWFkRE9NLm9mZnNldCk7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCk7XG4gICAgICAgICAgICBkb21TZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICBkb21TZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb250ZW50RE9NICYmIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIjtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRMb3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTSAhPSB0aGlzLmRvbSAmJiAhdGhpcy5kb20uY29udGFpbnModGhpcy5jb250ZW50RE9NKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGEgc3VidHJlZSBvZiB0aGUgZWxlbWVudCB0cmVlIHRoYXQgaGFzIGJlZW4gdG91Y2hlZFxuICAgIC8vIGJ5IGEgRE9NIGNoYW5nZSwgc28gdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCByZWRyYXcgaXQuXG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAobGV0IG9mZnNldCA9IDAsIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gZW5kID8gZnJvbSA8PSBlbmQgJiYgdG8gPj0gb2Zmc2V0IDogZnJvbSA8IGVuZCAmJiB0byA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluc2lkZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlciwgZW5kSW5zaWRlID0gZW5kIC0gY2hpbGQuYm9yZGVyO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHN0YXJ0SW5zaWRlICYmIHRvIDw9IGVuZEluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gZnJvbSA9PSBvZmZzZXQgfHwgdG8gPT0gZW5kID8gQ09OVEVOVF9ESVJUWSA6IENISUxEX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSBzdGFydEluc2lkZSAmJiB0byA9PSBlbmRJbnNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaGlsZC5jb250ZW50TG9zdCB8fCBjaGlsZC5kb20ucGFyZW50Tm9kZSAhPSB0aGlzLmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBOT0RFX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5tYXJrRGlydHkoZnJvbSAtIHN0YXJ0SW5zaWRlLCB0byAtIHN0YXJ0SW5zaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIWNoaWxkLmNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBDT05URU5UX0RJUlRZIDogTk9ERV9ESVJUWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJ0eSA9IENPTlRFTlRfRElSVFk7XG4gICAgfVxuICAgIG1hcmtQYXJlbnRzRGlydHkoKSB7XG4gICAgICAgIGxldCBsZXZlbCA9IDE7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSB0aGlzLnBhcmVudDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50LCBsZXZlbCsrKSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSBsZXZlbCA9PSAxID8gQ09OVEVOVF9ESVJUWSA6IENISUxEX0RJUlRZO1xuICAgICAgICAgICAgaWYgKG5vZGUuZGlydHkgPCBkaXJ0eSlcbiAgICAgICAgICAgICAgICBub2RlLmRpcnR5ID0gZGlydHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpZ25vcmVGb3JDb29yZHMoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuLy8gQSB3aWRnZXQgZGVzYyByZXByZXNlbnRzIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGlzIGEgRE9NIG5vZGVcbi8vIGRyYXduIGJldHdlZW4gdGhlIGRvY3VtZW50IG5vZGVzLlxuY2xhc3MgV2lkZ2V0Vmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB3aWRnZXQsIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgc2VsZiwgZG9tID0gd2lkZ2V0LnR5cGUudG9ET007XG4gICAgICAgIGlmICh0eXBlb2YgZG9tID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIGRvbSA9IGRvbSh2aWV3LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucGFyZW50LnBvc0JlZm9yZUNoaWxkKHNlbGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICghd2lkZ2V0LnR5cGUuc3BlYy5yYXcpIHtcbiAgICAgICAgICAgIGlmIChkb20ubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgICAgIGRvbSA9IHdyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci13aWRnZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICBzZWxmID0gdGhpcztcbiAgICB9XG4gICAgbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIHdpZGdldC50eXBlLmVxKHRoaXMud2lkZ2V0LnR5cGUpO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9OyB9XG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCBzdG9wID0gdGhpcy53aWRnZXQuc3BlYy5zdG9wRXZlbnQ7XG4gICAgICAgIHJldHVybiBzdG9wID8gc3RvcChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIiB8fCB0aGlzLndpZGdldC5zcGVjLmlnbm9yZVNlbGVjdGlvbjtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy53aWRnZXQudHlwZS5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgc2lkZSgpIHsgcmV0dXJuIHRoaXMud2lkZ2V0LnR5cGUuc2lkZTsgfVxufVxuY2xhc3MgQ29tcG9zaXRpb25WaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGRvbSwgdGV4dERPTSwgdGV4dCkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIFtdLCBkb20sIG51bGwpO1xuICAgICAgICB0aGlzLnRleHRET00gPSB0ZXh0RE9NO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKGRvbSAhPSB0aGlzLnRleHRET00pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgKG9mZnNldCA/IHRoaXMuc2l6ZSA6IDApO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgb2Zmc2V0O1xuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLnRleHRET00sIG9mZnNldDogcG9zIH07XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dCkge1xuICAgICAgICByZXR1cm4gbXV0LnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJyAmJiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWU7XG4gICAgfVxufVxuLy8gQSBtYXJrIGRlc2MgcmVwcmVzZW50cyBhIG1hcmsuIE1heSBoYXZlIG11bHRpcGxlIGNoaWxkcmVuLFxuLy8gZGVwZW5kaW5nIG9uIGhvdyB0aGUgbWFyayBpcyBzcGxpdC4gTm90ZSB0aGF0IG1hcmtzIGFyZSBkcmF3biB1c2luZ1xuLy8gYSBmaXhlZCBuZXN0aW5nIG9yZGVyLCBmb3Igc2ltcGxpY2l0eSBhbmQgcHJlZGljdGFiaWxpdHksIHNvIGluXG4vLyBzb21lIGNhc2VzIHRoZXkgd2lsbCBiZSBzcGxpdCBtb3JlIG9mdGVuIHRoYW4gd291bGQgYXBwZWFyXG4vLyBuZWNlc3NhcnkuXG5jbGFzcyBNYXJrVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBtYXJrLCBkb20sIGNvbnRlbnRET00pIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBjb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnQsIG1hcmssIGlubGluZSwgdmlldykge1xuICAgICAgICBsZXQgY3VzdG9tID0gdmlldy5ub2RlVmlld3NbbWFyay50eXBlLm5hbWVdO1xuICAgICAgICBsZXQgc3BlYyA9IGN1c3RvbSAmJiBjdXN0b20obWFyaywgdmlldywgaW5saW5lKTtcbiAgICAgICAgaWYgKCFzcGVjIHx8ICFzcGVjLmRvbSlcbiAgICAgICAgICAgIHNwZWMgPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jdW1lbnQsIG1hcmsudHlwZS5zcGVjLnRvRE9NKG1hcmssIGlubGluZSkpO1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtWaWV3RGVzYyhwYXJlbnQsIG1hcmssIHNwZWMuZG9tLCBzcGVjLmNvbnRlbnRET00gfHwgc3BlYy5kb20pO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7XG4gICAgICAgIGlmICgodGhpcy5kaXJ0eSAmIE5PREVfRElSVFkpIHx8IHRoaXMubWFyay50eXBlLnNwZWMucmVwYXJzZUluVmlldylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4geyBtYXJrOiB0aGlzLm1hcmsudHlwZS5uYW1lLCBhdHRyczogdGhpcy5tYXJrLmF0dHJzLCBjb250ZW50RWxlbWVudDogdGhpcy5jb250ZW50RE9NIH07XG4gICAgfVxuICAgIG1hdGNoZXNNYXJrKG1hcmspIHsgcmV0dXJuIHRoaXMuZGlydHkgIT0gTk9ERV9ESVJUWSAmJiB0aGlzLm1hcmsuZXEobWFyayk7IH1cbiAgICBtYXJrRGlydHkoZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIubWFya0RpcnR5KGZyb20sIHRvKTtcbiAgICAgICAgLy8gTW92ZSBkaXJ0eSBpbmZvIHRvIG5lYXJlc3Qgbm9kZSB2aWV3XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKCFwYXJlbnQubm9kZSlcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgaWYgKHBhcmVudC5kaXJ0eSA8IHRoaXMuZGlydHkpXG4gICAgICAgICAgICAgICAgcGFyZW50LmRpcnR5ID0gdGhpcy5kaXJ0eTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2xpY2UoZnJvbSwgdG8sIHZpZXcpIHtcbiAgICAgICAgbGV0IGNvcHkgPSBNYXJrVmlld0Rlc2MuY3JlYXRlKHRoaXMucGFyZW50LCB0aGlzLm1hcmssIHRydWUsIHZpZXcpO1xuICAgICAgICBsZXQgbm9kZXMgPSB0aGlzLmNoaWxkcmVuLCBzaXplID0gdGhpcy5zaXplO1xuICAgICAgICBpZiAodG8gPCBzaXplKVxuICAgICAgICAgICAgbm9kZXMgPSByZXBsYWNlTm9kZXMobm9kZXMsIHRvLCBzaXplLCB2aWV3KTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgbm9kZXMgPSByZXBsYWNlTm9kZXMobm9kZXMsIDAsIGZyb20sIHZpZXcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbm9kZXNbaV0ucGFyZW50ID0gY29weTtcbiAgICAgICAgY29weS5jaGlsZHJlbiA9IG5vZGVzO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG4vLyBOb2RlIHZpZXcgZGVzY3MgYXJlIHRoZSBtYWluLCBtb3N0IGNvbW1vbiB0eXBlIG9mIHZpZXcgZGVzYywgYW5kXG4vLyBjb3JyZXNwb25kIHRvIGFuIGFjdHVhbCBub2RlIGluIHRoZSBkb2N1bWVudC4gVW5saWtlIG1hcmsgZGVzY3MsXG4vLyB0aGV5IHBvcHVsYXRlIHRoZWlyIGNoaWxkIGFycmF5IHRoZW1zZWx2ZXMuXG5jbGFzcyBOb2RlVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBjb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5vdXRlckRlY28gPSBvdXRlckRlY287XG4gICAgICAgIHRoaXMuaW5uZXJEZWNvID0gaW5uZXJEZWNvO1xuICAgICAgICB0aGlzLm5vZGVET00gPSBub2RlRE9NO1xuICAgIH1cbiAgICAvLyBCeSBkZWZhdWx0LCBhIG5vZGUgaXMgcmVuZGVyZWQgdXNpbmcgdGhlIGB0b0RPTWAgbWV0aG9kIGZyb20gdGhlXG4gICAgLy8gbm9kZSB0eXBlIHNwZWMuIEJ1dCBjbGllbnQgY29kZSBjYW4gdXNlIHRoZSBgbm9kZVZpZXdzYCBzcGVjIHRvXG4gICAgLy8gc3VwcGx5IGEgY3VzdG9tIG5vZGUgdmlldywgd2hpY2ggY2FuIGluZmx1ZW5jZSB2YXJpb3VzIGFzcGVjdHMgb2ZcbiAgICAvLyB0aGUgd2F5IHRoZSBub2RlIHdvcmtzLlxuICAgIC8vXG4gICAgLy8gKFVzaW5nIHN1YmNsYXNzaW5nIGZvciB0aGlzIHdhcyBpbnRlbnRpb25hbGx5IGRlY2lkZWQgYWdhaW5zdCxcbiAgICAvLyBzaW5jZSBpdCdkIHJlcXVpcmUgZXhwb3NpbmcgYSB3aG9sZSBzbGV3IG9mIGZpbmlja3lcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIHRvIHRoZSB1c2VyIGNvZGUgdGhhdCB0aGV5IHByb2JhYmx5IHdpbGxcbiAgICAvLyBuZXZlciBuZWVkLilcbiAgICBzdGF0aWMgY3JlYXRlKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgY3VzdG9tID0gdmlldy5ub2RlVmlld3Nbbm9kZS50eXBlLm5hbWVdLCBkZXNjT2JqO1xuICAgICAgICBsZXQgc3BlYyA9IGN1c3RvbSAmJiBjdXN0b20obm9kZSwgdmlldywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gKFRoaXMgaXMgYSBmdW5jdGlvbiB0aGF0IGFsbG93cyB0aGUgY3VzdG9tIHZpZXcgdG8gZmluZCBpdHNcbiAgICAgICAgICAgIC8vIG93biBwb3NpdGlvbilcbiAgICAgICAgICAgIGlmICghZGVzY09iailcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgaWYgKGRlc2NPYmoucGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjT2JqLnBhcmVudC5wb3NCZWZvcmVDaGlsZChkZXNjT2JqKTtcbiAgICAgICAgfSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgICBsZXQgZG9tID0gc3BlYyAmJiBzcGVjLmRvbSwgY29udGVudERPTSA9IHNwZWMgJiYgc3BlYy5jb250ZW50RE9NO1xuICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgIGlmICghZG9tKVxuICAgICAgICAgICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgIT0gMylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRleHQgbXVzdCBiZSByZW5kZXJlZCBhcyBhIERPTSB0ZXh0IG5vZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRvbSkge1xuICAgICAgICAgICAgKHsgZG9tLCBjb250ZW50RE9NIH0gPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jdW1lbnQsIG5vZGUudHlwZS5zcGVjLnRvRE9NKG5vZGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250ZW50RE9NICYmICFub2RlLmlzVGV4dCAmJiBkb20ubm9kZU5hbWUgIT0gXCJCUlwiKSB7IC8vIENocm9tZSBnZXRzIGNvbmZ1c2VkIGJ5IDxiciBjb250ZW50ZWRpdGFibGU9ZmFsc2U+XG4gICAgICAgICAgICBpZiAoIWRvbS5oYXNBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikpXG4gICAgICAgICAgICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUpXG4gICAgICAgICAgICAgICAgZG9tLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGVET00gPSBkb207XG4gICAgICAgIGRvbSA9IGFwcGx5T3V0ZXJEZWNvKGRvbSwgb3V0ZXJEZWNvLCBub2RlKTtcbiAgICAgICAgaWYgKHNwZWMpXG4gICAgICAgICAgICByZXR1cm4gZGVzY09iaiA9IG5ldyBDdXN0b21Ob2RlVmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NIHx8IG51bGwsIG5vZGVET00sIHNwZWMsIHZpZXcsIHBvcyArIDEpO1xuICAgICAgICBlbHNlIGlmIChub2RlLmlzVGV4dClcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbm9kZURPTSwgdmlldyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSB8fCBudWxsLCBub2RlRE9NLCB2aWV3LCBwb3MgKyAxKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICAvLyBFeHBlcmltZW50YWwga2x1ZGdlIHRvIGFsbG93IG9wdC1pbiByZS1wYXJzaW5nIG9mIG5vZGVzXG4gICAgICAgIGlmICh0aGlzLm5vZGUudHlwZS5zcGVjLnJlcGFyc2VJblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gRklYTUUgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGNhbiBhbHdheXMgcmV0dXJuIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIGF0dHJzIG1lYW5zIHRoYXQgaWYgdGhlIHVzZXIgc29tZWhvdyBtYW5hZ2VzIHRvIGNoYW5nZSB0aGVcbiAgICAgICAgLy8gYXR0cnMgaW4gdGhlIGRvbSwgdGhhdCB3b24ndCBiZSBwaWNrZWQgdXAuIE5vdCBlbnRpcmVseSBzdXJlXG4gICAgICAgIC8vIHdoZXRoZXIgdGhpcyBpcyBhIHByb2JsZW1cbiAgICAgICAgbGV0IHJ1bGUgPSB7IG5vZGU6IHRoaXMubm9kZS50eXBlLm5hbWUsIGF0dHJzOiB0aGlzLm5vZGUuYXR0cnMgfTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS50eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIilcbiAgICAgICAgICAgIHJ1bGUucHJlc2VydmVXaGl0ZXNwYWNlID0gXCJmdWxsXCI7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICBydWxlLmdldENvbnRlbnQgPSAoKSA9PiB0aGlzLm5vZGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZW50TG9zdCkge1xuICAgICAgICAgICAgcnVsZS5jb250ZW50RWxlbWVudCA9IHRoaXMuY29udGVudERPTTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENocm9tZSBsaWtlcyB0byByYW5kb21seSByZWNyZWF0ZSBwYXJlbnQgbm9kZXMgd2hlblxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgdGhpbmdzLiBXaGVuIHRoYXQgaGFwcGVucywgdGhpcyB0cmllcyB0byBmaW5kIHRoZVxuICAgICAgICAgICAgLy8gbmV3IHBhcmVudC5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb20uY29udGFpbnMoY2hpbGQuZG9tLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuY29udGVudEVsZW1lbnQgPSBjaGlsZC5kb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFydWxlLmNvbnRlbnRFbGVtZW50KVxuICAgICAgICAgICAgICAgIHJ1bGUuZ2V0Q29udGVudCA9ICgpID0+IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydWxlO1xuICAgIH1cbiAgICBtYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJ0eSA9PSBOT1RfRElSVFkgJiYgbm9kZS5lcSh0aGlzLm5vZGUpICYmXG4gICAgICAgICAgICBzYW1lT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5vdXRlckRlY28pICYmIGlubmVyRGVjby5lcSh0aGlzLmlubmVyRGVjbyk7XG4gICAgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5ub2RlLm5vZGVTaXplOyB9XG4gICAgZ2V0IGJvcmRlcigpIHsgcmV0dXJuIHRoaXMubm9kZS5pc0xlYWYgPyAwIDogMTsgfVxuICAgIC8vIFN5bmNzIGB0aGlzLmNoaWxkcmVuYCB0byBtYXRjaCBgdGhpcy5ub2RlLmNvbnRlbnRgIGFuZCB0aGUgbG9jYWxcbiAgICAvLyBkZWNvcmF0aW9ucywgcG9zc2libHkgaW50cm9kdWNpbmcgbmVzdGluZyBmb3IgbWFya3MuIFRoZW4sIGluIGFcbiAgICAvLyBzZXBhcmF0ZSBzdGVwLCBzeW5jcyB0aGUgRE9NIGluc2lkZSBgdGhpcy5jb250ZW50RE9NYCB0b1xuICAgIC8vIGB0aGlzLmNoaWxkcmVuYC5cbiAgICB1cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGlubGluZSA9IHRoaXMubm9kZS5pbmxpbmVDb250ZW50LCBvZmYgPSBwb3M7XG4gICAgICAgIGxldCBjb21wb3NpdGlvbiA9IHZpZXcuY29tcG9zaW5nID8gdGhpcy5sb2NhbENvbXBvc2l0aW9uSW5mbyh2aWV3LCBwb3MpIDogbnVsbDtcbiAgICAgICAgbGV0IGxvY2FsQ29tcG9zaXRpb24gPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5wb3MgPiAtMSA/IGNvbXBvc2l0aW9uIDogbnVsbDtcbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uSW5DaGlsZCA9IGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnBvcyA8IDA7XG4gICAgICAgIGxldCB1cGRhdGVyID0gbmV3IFZpZXdUcmVlVXBkYXRlcih0aGlzLCBsb2NhbENvbXBvc2l0aW9uICYmIGxvY2FsQ29tcG9zaXRpb24ubm9kZSwgdmlldyk7XG4gICAgICAgIGl0ZXJEZWNvKHRoaXMubm9kZSwgdGhpcy5pbm5lckRlY28sICh3aWRnZXQsIGksIGluc2lkZU5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmICh3aWRnZXQuc3BlYy5tYXJrcylcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKHdpZGdldC5zcGVjLm1hcmtzLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICAgICAgZWxzZSBpZiAod2lkZ2V0LnR5cGUuc2lkZSA+PSAwICYmICFpbnNpZGVOb2RlKVxuICAgICAgICAgICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoaSA9PSB0aGlzLm5vZGUuY2hpbGRDb3VudCA/IE1hcmsubm9uZSA6IHRoaXMubm9kZS5jaGlsZChpKS5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgYSBkZXNjIG1hdGNoaW5nIHRoaXMgd2lkZ2V0LCByZXVzZSBpdCxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpbnNlcnQgdGhlIHdpZGdldCBhcyBhIG5ldyB2aWV3IGRlc2MuXG4gICAgICAgICAgICB1cGRhdGVyLnBsYWNlV2lkZ2V0KHdpZGdldCwgdmlldywgb2ZmKTtcbiAgICAgICAgfSwgKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgaSkgPT4ge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB3cmFwcGluZyBtYXJrIGRlc2NzIG1hdGNoIHRoZSBub2RlJ3MgbWFya3MuXG4gICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKGNoaWxkLm1hcmtzLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICAgICAgLy8gVHJ5IHNldmVyYWwgc3RyYXRlZ2llcyBmb3IgZHJhd2luZyB0aGlzIG5vZGVcbiAgICAgICAgICAgIGxldCBjb21wSW5kZXg7XG4gICAgICAgICAgICBpZiAodXBkYXRlci5maW5kTm9kZU1hdGNoKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgaSkpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBvc2l0aW9uSW5DaGlsZCAmJiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tID4gb2ZmICYmXG4gICAgICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gPCBvZmYgKyBjaGlsZC5ub2RlU2l6ZSAmJlxuICAgICAgICAgICAgICAgIChjb21wSW5kZXggPSB1cGRhdGVyLmZpbmRJbmRleFdpdGhDaGlsZChjb21wb3NpdGlvbi5ub2RlKSkgPiAtMSAmJlxuICAgICAgICAgICAgICAgIHVwZGF0ZXIudXBkYXRlTm9kZUF0KGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgY29tcEluZGV4LCB2aWV3KSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAodXBkYXRlci51cGRhdGVOZXh0Tm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGksIG9mZikpIDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBpdCBhcyBhIG5ldyB2aWV3XG4gICAgICAgICAgICAgICAgdXBkYXRlci5hZGROb2RlKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgb2ZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERyb3AgYWxsIHJlbWFpbmluZyBkZXNjcyBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhbXSwgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHVwZGF0ZXIuYWRkVGV4dGJsb2NrSGFja3MoKTtcbiAgICAgICAgdXBkYXRlci5kZXN0cm95UmVzdCgpO1xuICAgICAgICAvLyBTeW5jIHRoZSBET00gaWYgYW55dGhpbmcgY2hhbmdlZFxuICAgICAgICBpZiAodXBkYXRlci5jaGFuZ2VkIHx8IHRoaXMuZGlydHkgPT0gQ09OVEVOVF9ESVJUWSkge1xuICAgICAgICAgICAgLy8gTWF5IGhhdmUgdG8gcHJvdGVjdCBmb2N1c2VkIERPTSBmcm9tIGJlaW5nIGNoYW5nZWQgaWYgYSBjb21wb3NpdGlvbiBpcyBhY3RpdmVcbiAgICAgICAgICAgIGlmIChsb2NhbENvbXBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvdGVjdExvY2FsQ29tcG9zaXRpb24odmlldywgbG9jYWxDb21wb3NpdGlvbik7XG4gICAgICAgICAgICByZW5kZXJEZXNjcyh0aGlzLmNvbnRlbnRET00sIHRoaXMuY2hpbGRyZW4sIHZpZXcpO1xuICAgICAgICAgICAgaWYgKGlvcylcbiAgICAgICAgICAgICAgICBpb3NIYWNrcyh0aGlzLmRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9jYWxDb21wb3NpdGlvbkluZm8odmlldywgcG9zKSB7XG4gICAgICAgIC8vIE9ubHkgZG8gc29tZXRoaW5nIGlmIGJvdGggdGhlIHNlbGVjdGlvbiBhbmQgYSBmb2N1c2VkIHRleHQgbm9kZVxuICAgICAgICAvLyBhcmUgaW5zaWRlIG9mIHRoaXMgbm9kZVxuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikgfHwgZnJvbSA8IHBvcyB8fCB0byA+IHBvcyArIHRoaXMubm9kZS5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IHRleHROb2RlID0gbmVhcmJ5VGV4dE5vZGUoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICAgICAgaWYgKCF0ZXh0Tm9kZSB8fCAhdGhpcy5kb20uY29udGFpbnModGV4dE5vZGUucGFyZW50Tm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSB0ZXh0IGluIHRoZSBmb2N1c2VkIG5vZGUgaW4gdGhlIG5vZGUsIHN0b3AgaWYgaXQncyBub3RcbiAgICAgICAgICAgIC8vIHRoZXJlIChtYXkgaGF2ZSBiZWVuIG1vZGlmaWVkIHRocm91Z2ggb3RoZXIgbWVhbnMsIGluIHdoaWNoXG4gICAgICAgICAgICAvLyBjYXNlIGl0IHNob3VsZCBvdmVyd3JpdHRlbilcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgbGV0IHRleHRQb3MgPSBmaW5kVGV4dEluRnJhZ21lbnQodGhpcy5ub2RlLmNvbnRlbnQsIHRleHQsIGZyb20gLSBwb3MsIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0UG9zIDwgMCA/IG51bGwgOiB7IG5vZGU6IHRleHROb2RlLCBwb3M6IHRleHRQb3MsIHRleHQgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRleHROb2RlLCBwb3M6IC0xLCB0ZXh0OiBcIlwiIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdGVjdExvY2FsQ29tcG9zaXRpb24odmlldywgeyBub2RlLCBwb3MsIHRleHQgfSkge1xuICAgICAgICAvLyBUaGUgbm9kZSBpcyBhbHJlYWR5IHBhcnQgb2YgYSBsb2NhbCB2aWV3IGRlc2MsIGxlYXZlIGl0IHRoZXJlXG4gICAgICAgIGlmICh0aGlzLmdldERlc2Mobm9kZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbXBvc2l0aW9uIHZpZXcgZm9yIHRoZSBvcnBoYW5lZCBub2Rlc1xuICAgICAgICBsZXQgdG9wTm9kZSA9IG5vZGU7XG4gICAgICAgIGZvciAoOzsgdG9wTm9kZSA9IHRvcE5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaWYgKHRvcE5vZGUucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB3aGlsZSAodG9wTm9kZS5wcmV2aW91c1NpYmxpbmcpXG4gICAgICAgICAgICAgICAgdG9wTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRvcE5vZGUucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgIHdoaWxlICh0b3BOb2RlLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b3BOb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIGlmICh0b3BOb2RlLnBtVmlld0Rlc2MpXG4gICAgICAgICAgICAgICAgdG9wTm9kZS5wbVZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZXNjID0gbmV3IENvbXBvc2l0aW9uVmlld0Rlc2ModGhpcywgdG9wTm9kZSwgbm9kZSwgdGV4dCk7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2Rlcy5wdXNoKGRlc2MpO1xuICAgICAgICAvLyBQYXRjaCB1cCB0aGlzLmNoaWxkcmVuIHRvIGNvbnRhaW4gdGhlIGNvbXBvc2l0aW9uIHZpZXdcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHJlcGxhY2VOb2Rlcyh0aGlzLmNoaWxkcmVuLCBwb3MsIHBvcyArIHRleHQubGVuZ3RoLCB2aWV3LCBkZXNjKTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyBkZXNjIG11c3QgYmUgdXBkYXRlZCB0byBtYXRjaCB0aGUgZ2l2ZW4gbm9kZSBkZWNvcmF0aW9uLFxuICAgIC8vIGRvIHNvIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICB1cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSB8fFxuICAgICAgICAgICAgIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHVwZGF0ZUlubmVyKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIHRoaXMudXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbyk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuaW5uZXJEZWNvID0gaW5uZXJEZWNvO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbih2aWV3LCB0aGlzLnBvc0F0U3RhcnQpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgIH1cbiAgICB1cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKSB7XG4gICAgICAgIGlmIChzYW1lT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5vdXRlckRlY28pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbmVlZHNXcmFwID0gdGhpcy5ub2RlRE9NLm5vZGVUeXBlICE9IDE7XG4gICAgICAgIGxldCBvbGRET00gPSB0aGlzLmRvbTtcbiAgICAgICAgdGhpcy5kb20gPSBwYXRjaE91dGVyRGVjbyh0aGlzLmRvbSwgdGhpcy5ub2RlRE9NLCBjb21wdXRlT3V0ZXJEZWNvKHRoaXMub3V0ZXJEZWNvLCB0aGlzLm5vZGUsIG5lZWRzV3JhcCksIGNvbXB1dGVPdXRlckRlY28ob3V0ZXJEZWNvLCB0aGlzLm5vZGUsIG5lZWRzV3JhcCkpO1xuICAgICAgICBpZiAodGhpcy5kb20gIT0gb2xkRE9NKSB7XG4gICAgICAgICAgICBvbGRET00ucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnBtVmlld0Rlc2MgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0ZXJEZWNvID0gb3V0ZXJEZWNvO1xuICAgIH1cbiAgICAvLyBNYXJrIHRoaXMgbm9kZSBhcyBiZWluZyB0aGUgc2VsZWN0ZWQgbm9kZS5cbiAgICBzZWxlY3ROb2RlKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlRE9NLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICB0aGlzLm5vZGVET00uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLXNlbGVjdGVkbm9kZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSB8fCAhdGhpcy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUpXG4gICAgICAgICAgICB0aGlzLmRvbS5kcmFnZ2FibGUgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgc2VsZWN0ZWQgbm9kZSBtYXJraW5nIGZyb20gdGhpcyBub2RlLlxuICAgIGRlc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZURPTS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlQXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpO1xuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIHRoaXMubm9kZS5pc0F0b207IH1cbn1cbi8vIENyZWF0ZSBhIHZpZXcgZGVzYyBmb3IgdGhlIHRvcC1sZXZlbCBkb2N1bWVudCBub2RlLCB0byBiZSBleHBvcnRlZFxuLy8gYW5kIHVzZWQgYnkgdGhlIHZpZXcgY2xhc3MuXG5mdW5jdGlvbiBkb2NWaWV3RGVzYyhkb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIHZpZXcpIHtcbiAgICBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgZG9jKTtcbiAgICBsZXQgZG9jVmlldyA9IG5ldyBOb2RlVmlld0Rlc2ModW5kZWZpbmVkLCBkb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGRvbSwgZG9tLCB2aWV3LCAwKTtcbiAgICBpZiAoZG9jVmlldy5jb250ZW50RE9NKVxuICAgICAgICBkb2NWaWV3LnVwZGF0ZUNoaWxkcmVuKHZpZXcsIDApO1xuICAgIHJldHVybiBkb2NWaWV3O1xufVxuY2xhc3MgVGV4dFZpZXdEZXNjIGV4dGVuZHMgTm9kZVZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG5vZGVET00sIHZpZXcpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBudWxsLCBub2RlRE9NLCB2aWV3LCAwKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICBsZXQgc2tpcCA9IHRoaXMubm9kZURPTS5wYXJlbnROb2RlO1xuICAgICAgICB3aGlsZSAoc2tpcCAmJiBza2lwICE9IHRoaXMuZG9tICYmICFza2lwLnBtSXNEZWNvKVxuICAgICAgICAgICAgc2tpcCA9IHNraXAucGFyZW50Tm9kZTtcbiAgICAgICAgcmV0dXJuIHsgc2tpcDogKHNraXAgfHwgdHJ1ZSkgfTtcbiAgICB9XG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkgfHwgKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZICYmICF0aGlzLmluUGFyZW50KCkpIHx8XG4gICAgICAgICAgICAhbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbyk7XG4gICAgICAgIGlmICgodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkgfHwgbm9kZS50ZXh0ICE9IHRoaXMubm9kZS50ZXh0KSAmJiBub2RlLnRleHQgIT0gdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZSA9IG5vZGUudGV4dDtcbiAgICAgICAgICAgIGlmICh2aWV3LnRyYWNrV3JpdGVzID09IHRoaXMubm9kZURPTSlcbiAgICAgICAgICAgICAgICB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5QYXJlbnQoKSB7XG4gICAgICAgIGxldCBwYXJlbnRET00gPSB0aGlzLnBhcmVudC5jb250ZW50RE9NO1xuICAgICAgICBmb3IgKGxldCBuID0gdGhpcy5ub2RlRE9NOyBuOyBuID0gbi5wYXJlbnROb2RlKVxuICAgICAgICAgICAgaWYgKG4gPT0gcGFyZW50RE9NKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRvbUZyb21Qb3MocG9zKSB7XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMubm9kZURPTSwgb2Zmc2V0OiBwb3MgfTtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIGlmIChkb20gPT0gdGhpcy5ub2RlRE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIE1hdGgubWluKG9mZnNldCwgdGhpcy5ub2RlLnRleHQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcyk7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlICE9IFwiY2hhcmFjdGVyRGF0YVwiICYmIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIjtcbiAgICB9XG4gICAgc2xpY2UoZnJvbSwgdG8sIHZpZXcpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLm5vZGUuY3V0KGZyb20sIHRvKSwgZG9tID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS50ZXh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Vmlld0Rlc2ModGhpcy5wYXJlbnQsIG5vZGUsIHRoaXMub3V0ZXJEZWNvLCB0aGlzLmlubmVyRGVjbywgZG9tLCBkb20sIHZpZXcpO1xuICAgIH1cbiAgICBtYXJrRGlydHkoZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIubWFya0RpcnR5KGZyb20sIHRvKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tICE9IHRoaXMubm9kZURPTSAmJiAoZnJvbSA9PSAwIHx8IHRvID09IHRoaXMubm9kZURPTS5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBOT0RFX0RJUlRZO1xuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG4vLyBBIGR1bW15IGRlc2MgdXNlZCB0byB0YWcgdHJhaWxpbmcgQlIgb3IgSU1HIG5vZGVzIGNyZWF0ZWQgdG8gd29ya1xuLy8gYXJvdW5kIGNvbnRlbnRFZGl0YWJsZSB0ZXJyaWJsZW5lc3MuXG5jbGFzcyBUcmFpbGluZ0hhY2tWaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9OyB9XG4gICAgbWF0Y2hlc0hhY2sobm9kZU5hbWUpIHsgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIHRoaXMuZG9tLm5vZGVOYW1lID09IG5vZGVOYW1lOyB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlnbm9yZUZvckNvb3JkcygpIHsgcmV0dXJuIHRoaXMuZG9tLm5vZGVOYW1lID09IFwiSU1HXCI7IH1cbn1cbi8vIEEgc2VwYXJhdGUgc3ViY2xhc3MgaXMgdXNlZCBmb3IgY3VzdG9taXplZCBub2RlIHZpZXdzLCBzbyB0aGF0IHRoZVxuLy8gZXh0cmEgY2hlY2tzIG9ubHkgaGF2ZSB0byBiZSBtYWRlIGZvciBub2RlcyB0aGF0IGFyZSBhY3R1YWxseVxuLy8gY3VzdG9taXplZC5cbmNsYXNzIEN1c3RvbU5vZGVWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MpO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICAvLyBBIGN1c3RvbSBgdXBkYXRlYCBtZXRob2QgZ2V0cyB0byBkZWNpZGUgd2hldGhlciB0aGUgdXBkYXRlIGdvZXNcbiAgICAvLyB0aHJvdWdoLiBJZiBpdCBkb2VzLCBhbmQgdGhlcmUncyBhIGBjb250ZW50RE9NYCBub2RlLCBvdXIgbG9naWNcbiAgICAvLyB1cGRhdGVzIHRoZSBjaGlsZHJlbi5cbiAgICB1cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy51cGRhdGUpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnNwZWMudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmNvbnRlbnRET00gJiYgIW5vZGUuaXNMZWFmKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3ROb2RlKCkge1xuICAgICAgICB0aGlzLnNwZWMuc2VsZWN0Tm9kZSA/IHRoaXMuc3BlYy5zZWxlY3ROb2RlKCkgOiBzdXBlci5zZWxlY3ROb2RlKCk7XG4gICAgfVxuICAgIGRlc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5zcGVjLmRlc2VsZWN0Tm9kZSA/IHRoaXMuc3BlYy5kZXNlbGVjdE5vZGUoKSA6IHN1cGVyLmRlc2VsZWN0Tm9kZSgpO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290LCBmb3JjZSkge1xuICAgICAgICB0aGlzLnNwZWMuc2V0U2VsZWN0aW9uID8gdGhpcy5zcGVjLnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHJvb3QpXG4gICAgICAgICAgICA6IHN1cGVyLnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHJvb3QsIGZvcmNlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5zcGVjLmRlc3Ryb3koKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5zdG9wRXZlbnQgPyB0aGlzLnNwZWMuc3RvcEV2ZW50KGV2ZW50KSA6IGZhbHNlO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLmlnbm9yZU11dGF0aW9uID8gdGhpcy5zcGVjLmlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSA6IHN1cGVyLmlnbm9yZU11dGF0aW9uKG11dGF0aW9uKTtcbiAgICB9XG59XG4vLyBTeW5jIHRoZSBjb250ZW50IG9mIHRoZSBnaXZlbiBET00gbm9kZSB3aXRoIHRoZSBub2RlcyBhc3NvY2lhdGVkXG4vLyB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiB2aWV3IGRlc2NzLCByZWN1cnNpbmcgaW50byBtYXJrIGRlc2NzXG4vLyBiZWNhdXNlIHRoaXMgc2hvdWxkIHN5bmMgdGhlIHN1YnRyZWUgZm9yIGEgd2hvbGUgbm9kZSBhdCBhIHRpbWUuXG5mdW5jdGlvbiByZW5kZXJEZXNjcyhwYXJlbnRET00sIGRlc2NzLCB2aWV3KSB7XG4gICAgbGV0IGRvbSA9IHBhcmVudERPTS5maXJzdENoaWxkLCB3cml0dGVuID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXNjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZGVzYyA9IGRlc2NzW2ldLCBjaGlsZERPTSA9IGRlc2MuZG9tO1xuICAgICAgICBpZiAoY2hpbGRET00ucGFyZW50Tm9kZSA9PSBwYXJlbnRET00pIHtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZERPTSAhPSBkb20pIHtcbiAgICAgICAgICAgICAgICBkb20gPSBybShkb20pO1xuICAgICAgICAgICAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tID0gZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICBwYXJlbnRET00uaW5zZXJ0QmVmb3JlKGNoaWxkRE9NLCBkb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXNjIGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gZG9tID8gZG9tLnByZXZpb3VzU2libGluZyA6IHBhcmVudERPTS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICByZW5kZXJEZXNjcyhkZXNjLmNvbnRlbnRET00sIGRlc2MuY2hpbGRyZW4sIHZpZXcpO1xuICAgICAgICAgICAgZG9tID0gcG9zID8gcG9zLm5leHRTaWJsaW5nIDogcGFyZW50RE9NLmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGRvbSkge1xuICAgICAgICBkb20gPSBybShkb20pO1xuICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHdyaXR0ZW4gJiYgdmlldy50cmFja1dyaXRlcyA9PSBwYXJlbnRET00pXG4gICAgICAgIHZpZXcudHJhY2tXcml0ZXMgPSBudWxsO1xufVxuY29uc3QgT3V0ZXJEZWNvTGV2ZWwgPSBmdW5jdGlvbiAobm9kZU5hbWUpIHtcbiAgICBpZiAobm9kZU5hbWUpXG4gICAgICAgIHRoaXMubm9kZU5hbWUgPSBub2RlTmFtZTtcbn07XG5PdXRlckRlY29MZXZlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3Qgbm9EZWNvID0gW25ldyBPdXRlckRlY29MZXZlbF07XG5mdW5jdGlvbiBjb21wdXRlT3V0ZXJEZWNvKG91dGVyRGVjbywgbm9kZSwgbmVlZHNXcmFwKSB7XG4gICAgaWYgKG91dGVyRGVjby5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIG5vRGVjbztcbiAgICBsZXQgdG9wID0gbmVlZHNXcmFwID8gbm9EZWNvWzBdIDogbmV3IE91dGVyRGVjb0xldmVsLCByZXN1bHQgPSBbdG9wXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dGVyRGVjby5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYXR0cnMgPSBvdXRlckRlY29baV0udHlwZS5hdHRycztcbiAgICAgICAgaWYgKCFhdHRycylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoYXR0cnMubm9kZU5hbWUpXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0b3AgPSBuZXcgT3V0ZXJEZWNvTGV2ZWwoYXR0cnMubm9kZU5hbWUpKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycykge1xuICAgICAgICAgICAgbGV0IHZhbCA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKG5lZWRzV3JhcCAmJiByZXN1bHQubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKG5vZGUuaXNJbmxpbmUgPyBcInNwYW5cIiA6IFwiZGl2XCIpKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwiY2xhc3NcIilcbiAgICAgICAgICAgICAgICB0b3AuY2xhc3MgPSAodG9wLmNsYXNzID8gdG9wLmNsYXNzICsgXCIgXCIgOiBcIlwiKSArIHZhbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgIHRvcC5zdHlsZSA9ICh0b3Auc3R5bGUgPyB0b3Auc3R5bGUgKyBcIjtcIiA6IFwiXCIpICsgdmFsO1xuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSAhPSBcIm5vZGVOYW1lXCIpXG4gICAgICAgICAgICAgICAgdG9wW25hbWVdID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXRjaE91dGVyRGVjbyhvdXRlckRPTSwgbm9kZURPTSwgcHJldkNvbXB1dGVkLCBjdXJDb21wdXRlZCkge1xuICAgIC8vIFNob3J0Y3V0IGZvciB0cml2aWFsIGNhc2VcbiAgICBpZiAocHJldkNvbXB1dGVkID09IG5vRGVjbyAmJiBjdXJDb21wdXRlZCA9PSBub0RlY28pXG4gICAgICAgIHJldHVybiBub2RlRE9NO1xuICAgIGxldCBjdXJET00gPSBub2RlRE9NO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyQ29tcHV0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlY28gPSBjdXJDb21wdXRlZFtpXSwgcHJldiA9IHByZXZDb21wdXRlZFtpXTtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQ7XG4gICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2Lm5vZGVOYW1lID09IGRlY28ubm9kZU5hbWUgJiYgY3VyRE9NICE9IG91dGVyRE9NICYmXG4gICAgICAgICAgICAgICAgKHBhcmVudCA9IGN1ckRPTS5wYXJlbnROb2RlKSAmJiBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSBkZWNvLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkZWNvLm5vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQucG1Jc0RlY28gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjdXJET00pO1xuICAgICAgICAgICAgICAgIHByZXYgPSBub0RlY29bMF07XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhdGNoQXR0cmlidXRlcyhjdXJET00sIHByZXYgfHwgbm9EZWNvWzBdLCBkZWNvKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1ckRPTTtcbn1cbmZ1bmN0aW9uIHBhdGNoQXR0cmlidXRlcyhkb20sIHByZXYsIGN1cikge1xuICAgIGZvciAobGV0IG5hbWUgaW4gcHJldilcbiAgICAgICAgaWYgKG5hbWUgIT0gXCJjbGFzc1wiICYmIG5hbWUgIT0gXCJzdHlsZVwiICYmIG5hbWUgIT0gXCJub2RlTmFtZVwiICYmICEobmFtZSBpbiBjdXIpKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBmb3IgKGxldCBuYW1lIGluIGN1cilcbiAgICAgICAgaWYgKG5hbWUgIT0gXCJjbGFzc1wiICYmIG5hbWUgIT0gXCJzdHlsZVwiICYmIG5hbWUgIT0gXCJub2RlTmFtZVwiICYmIGN1cltuYW1lXSAhPSBwcmV2W25hbWVdKVxuICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBjdXJbbmFtZV0pO1xuICAgIGlmIChwcmV2LmNsYXNzICE9IGN1ci5jbGFzcykge1xuICAgICAgICBsZXQgcHJldkxpc3QgPSBwcmV2LmNsYXNzID8gcHJldi5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGxldCBjdXJMaXN0ID0gY3VyLmNsYXNzID8gY3VyLmNsYXNzLnNwbGl0KFwiIFwiKS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2TGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjdXJMaXN0LmluZGV4T2YocHJldkxpc3RbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QucmVtb3ZlKHByZXZMaXN0W2ldKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJMaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHByZXZMaXN0LmluZGV4T2YoY3VyTGlzdFtpXSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoY3VyTGlzdFtpXSk7XG4gICAgICAgIGlmIChkb20uY2xhc3NMaXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgIH1cbiAgICBpZiAocHJldi5zdHlsZSAhPSBjdXIuc3R5bGUpIHtcbiAgICAgICAgaWYgKHByZXYuc3R5bGUpIHtcbiAgICAgICAgICAgIGxldCBwcm9wID0gL1xccyooW1xcd1xcLVxceGExLVxcdWZmZmZdKylcXHMqOig/OlwiKD86XFxcXC58W15cIl0pKlwifCcoPzpcXFxcLnxbXiddKSonfFxcKC4qP1xcKXxbXjtdKSovZywgbTtcbiAgICAgICAgICAgIHdoaWxlIChtID0gcHJvcC5leGVjKHByZXYuc3R5bGUpKVxuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShtWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyLnN0eWxlKVxuICAgICAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgKz0gY3VyLnN0eWxlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5T3V0ZXJEZWNvKGRvbSwgZGVjbywgbm9kZSkge1xuICAgIHJldHVybiBwYXRjaE91dGVyRGVjbyhkb20sIGRvbSwgbm9EZWNvLCBjb21wdXRlT3V0ZXJEZWNvKGRlY28sIG5vZGUsIGRvbS5ub2RlVHlwZSAhPSAxKSk7XG59XG5mdW5jdGlvbiBzYW1lT3V0ZXJEZWNvKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghYVtpXS50eXBlLmVxKGJbaV0udHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBSZW1vdmUgYSBET00gbm9kZSBhbmQgcmV0dXJuIGl0cyBuZXh0IHNpYmxpbmcuXG5mdW5jdGlvbiBybShkb20pIHtcbiAgICBsZXQgbmV4dCA9IGRvbS5uZXh0U2libGluZztcbiAgICBkb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20pO1xuICAgIHJldHVybiBuZXh0O1xufVxuLy8gSGVscGVyIGNsYXNzIGZvciBpbmNyZW1lbnRhbGx5IHVwZGF0aW5nIGEgdHJlZSBvZiBtYXJrIGRlc2NzIGFuZFxuLy8gdGhlIHdpZGdldCBhbmQgbm9kZSBkZXNjcyBpbnNpZGUgb2YgdGhlbS5cbmNsYXNzIFZpZXdUcmVlVXBkYXRlciB7XG4gICAgY29uc3RydWN0b3IodG9wLCBsb2NrLCB2aWV3KSB7XG4gICAgICAgIHRoaXMubG9jayA9IGxvY2s7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIC8vIEluZGV4IGludG8gYHRoaXMudG9wYCdzIGNoaWxkIGFycmF5LCByZXByZXNlbnRzIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIC8vIFdoZW4gZW50ZXJpbmcgYSBtYXJrLCB0aGUgY3VycmVudCB0b3AgYW5kIGluZGV4IGFyZSBwdXNoZWRcbiAgICAgICAgLy8gb250byB0aGlzLlxuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIGFueXRoaW5nIHdhcyBjaGFuZ2VkXG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5wcmVNYXRjaCA9IHByZU1hdGNoKHRvcC5ub2RlLmNvbnRlbnQsIHRvcCk7XG4gICAgfVxuICAgIC8vIERlc3Ryb3kgYW5kIHJlbW92ZSB0aGUgY2hpbGRyZW4gYmV0d2VlbiB0aGUgZ2l2ZW4gaW5kaWNlcyBpblxuICAgIC8vIGB0aGlzLnRvcGAuXG4gICAgZGVzdHJveUJldHdlZW4oc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIHRoaXMudG9wLmNoaWxkcmVuW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIERlc3Ryb3kgYWxsIHJlbWFpbmluZyBjaGlsZHJlbiBpbiBgdGhpcy50b3BgLlxuICAgIGRlc3Ryb3lSZXN0KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN5bmMgdGhlIGN1cnJlbnQgc3RhY2sgb2YgbWFyayBkZXNjcyB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZlxuICAgIC8vIG1hcmtzLCByZXVzaW5nIGV4aXN0aW5nIG1hcmsgZGVzY3Mgd2hlbiBwb3NzaWJsZS5cbiAgICBzeW5jVG9NYXJrcyhtYXJrcywgaW5saW5lLCB2aWV3KSB7XG4gICAgICAgIGxldCBrZWVwID0gMCwgZGVwdGggPSB0aGlzLnN0YWNrLmxlbmd0aCA+PiAxO1xuICAgICAgICBsZXQgbWF4S2VlcCA9IE1hdGgubWluKGRlcHRoLCBtYXJrcy5sZW5ndGgpO1xuICAgICAgICB3aGlsZSAoa2VlcCA8IG1heEtlZXAgJiZcbiAgICAgICAgICAgIChrZWVwID09IGRlcHRoIC0gMSA/IHRoaXMudG9wIDogdGhpcy5zdGFja1soa2VlcCArIDEpIDw8IDFdKVxuICAgICAgICAgICAgICAgIC5tYXRjaGVzTWFyayhtYXJrc1trZWVwXSkgJiYgbWFya3Nba2VlcF0udHlwZS5zcGVjLnNwYW5uaW5nICE9PSBmYWxzZSlcbiAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBkZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95UmVzdCgpO1xuICAgICAgICAgICAgdGhpcy50b3AuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMudG9wID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGRlcHRoIDwgbWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy50b3AsIHRoaXMuaW5kZXggKyAxKTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IC0xO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXg7IGkgPCBNYXRoLm1pbih0aGlzLmluZGV4ICsgMywgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5tYXRjaGVzTWFyayhtYXJrc1tkZXB0aF0pICYmICF0aGlzLmlzTG9ja2VkKG5leHQuZG9tKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGZvdW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrRGVzYyA9IE1hcmtWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG1hcmtzW2RlcHRoXSwgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCwgMCwgbWFya0Rlc2MpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gbWFya0Rlc2M7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIG5vZGUgZGVzYyBtYXRjaGluZyB0aGUgZ2l2ZW4gZGF0YS4gU2tpcCBvdmVyIGl0IGFuZFxuICAgIC8vIHJldHVybiB0cnVlIHdoZW4gc3VjY2Vzc2Z1bC5cbiAgICBmaW5kTm9kZU1hdGNoKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpbmRleCkge1xuICAgICAgICBsZXQgZm91bmQgPSAtMSwgdGFyZ2V0RGVzYztcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMucHJlTWF0Y2guaW5kZXggJiZcbiAgICAgICAgICAgICh0YXJnZXREZXNjID0gdGhpcy5wcmVNYXRjaC5tYXRjaGVzW2luZGV4IC0gdGhpcy5wcmVNYXRjaC5pbmRleF0pLnBhcmVudCA9PSB0aGlzLnRvcCAmJlxuICAgICAgICAgICAgdGFyZ2V0RGVzYy5tYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykpIHtcbiAgICAgICAgICAgIGZvdW5kID0gdGhpcy50b3AuY2hpbGRyZW4uaW5kZXhPZih0YXJnZXREZXNjLCB0aGlzLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4LCBlID0gTWF0aC5taW4odGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoLCBpICsgNSk7IGkgPCBlOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pICYmICF0aGlzLnByZU1hdGNoLm1hdGNoZWQuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmQgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGZvdW5kKTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdXBkYXRlTm9kZUF0KG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpbmRleCwgdmlldykge1xuICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgIGlmIChjaGlsZC5kaXJ0eSA9PSBOT0RFX0RJUlRZICYmIGNoaWxkLmRvbSA9PSBjaGlsZC5jb250ZW50RE9NKVxuICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgICAgICBpZiAoIWNoaWxkLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgaW5kZXgpO1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmaW5kSW5kZXhXaXRoQ2hpbGQoZG9tTm9kZSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PSB0aGlzLnRvcC5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlc2MgPSBkb21Ob2RlLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvcC5jaGlsZHJlbltpXSA9PSBkZXNjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tTm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gdXBkYXRlIHRoZSBuZXh0IG5vZGUsIGlmIGFueSwgdG8gdGhlIGdpdmVuIGRhdGEuIENoZWNrc1xuICAgIC8vIHByZS1tYXRjaGVzIHRvIGF2b2lkIG92ZXJ3cml0aW5nIG5vZGVzIHRoYXQgY291bGQgc3RpbGwgYmUgdXNlZC5cbiAgICB1cGRhdGVOZXh0Tm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgaW5kZXgsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMudG9wLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBOb2RlVmlld0Rlc2MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJlTWF0Y2ggPSB0aGlzLnByZU1hdGNoLm1hdGNoZWQuZ2V0KG5leHQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVNYXRjaCAhPSBudWxsICYmIHByZU1hdGNoICE9IGluZGV4KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRET00gPSBuZXh0LmRvbSwgdXBkYXRlZDtcbiAgICAgICAgICAgICAgICAvLyBDYW4ndCB1cGRhdGUgaWYgbmV4dERPTSBpcyBvciBjb250YWlucyB0aGlzLmxvY2ssIGV4Y2VwdCBpZlxuICAgICAgICAgICAgICAgIC8vIGl0J3MgYSB0ZXh0IG5vZGUgd2hvc2UgY29udGVudCBhbHJlYWR5IG1hdGNoZXMgdGhlIG5ldyB0ZXh0XG4gICAgICAgICAgICAgICAgLy8gYW5kIHdob3NlIGRlY29yYXRpb25zIG1hdGNoIHRoZSBuZXcgb25lcy5cbiAgICAgICAgICAgICAgICBsZXQgbG9ja2VkID0gdGhpcy5pc0xvY2tlZChuZXh0RE9NKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKG5vZGUuaXNUZXh0ICYmIG5leHQubm9kZSAmJiBuZXh0Lm5vZGUuaXNUZXh0ICYmIG5leHQubm9kZURPTS5ub2RlVmFsdWUgPT0gbm9kZS50ZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LmRpcnR5ICE9IE5PREVfRElSVFkgJiYgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIG5leHQub3V0ZXJEZWNvKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NrZWQgJiYgbmV4dC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmRvbSAhPSBuZXh0RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWxvY2tlZCAmJiAodXBkYXRlZCA9IHRoaXMucmVjcmVhdGVXcmFwcGVyKG5leHQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XSA9IHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC51cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXaGVuIGEgbm9kZSB3aXRoIGNvbnRlbnQgaXMgcmVwbGFjZWQgYnkgYSBkaWZmZXJlbnQgbm9kZSB3aXRoXG4gICAgLy8gaWRlbnRpY2FsIGNvbnRlbnQsIG1vdmUgb3ZlciBpdHMgY2hpbGRyZW4uXG4gICAgcmVjcmVhdGVXcmFwcGVyKG5leHQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgaWYgKG5leHQuZGlydHkgfHwgbm9kZS5pc0F0b20gfHwgIW5leHQuY2hpbGRyZW4ubGVuZ3RoIHx8XG4gICAgICAgICAgICAhbmV4dC5ub2RlLmNvbnRlbnQuZXEobm9kZS5jb250ZW50KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgd3JhcHBlciA9IE5vZGVWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpO1xuICAgICAgICBpZiAod3JhcHBlci5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICB3cmFwcGVyLmNoaWxkcmVuID0gbmV4dC5jaGlsZHJlbjtcbiAgICAgICAgICAgIG5leHQuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoIG9mIHdyYXBwZXIuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2gucGFyZW50ID0gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBuZXh0LmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIC8vIEluc2VydCB0aGUgbm9kZSBhcyBhIG5ld2x5IGNyZWF0ZWQgbm9kZSBkZXNjLlxuICAgIGFkZE5vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgZGVzYyA9IE5vZGVWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpO1xuICAgICAgICBpZiAoZGVzYy5jb250ZW50RE9NKVxuICAgICAgICAgICAgZGVzYy51cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgZGVzYyk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIHBsYWNlV2lkZ2V0KHdpZGdldCwgdmlldywgcG9zKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5pbmRleCA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCA/IHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXhdIDogbnVsbDtcbiAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5tYXRjaGVzV2lkZ2V0KHdpZGdldCkgJiZcbiAgICAgICAgICAgICh3aWRnZXQgPT0gbmV4dC53aWRnZXQgfHwgIW5leHQud2lkZ2V0LnR5cGUudG9ET00ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gbmV3IFdpZGdldFZpZXdEZXNjKHRoaXMudG9wLCB3aWRnZXQsIHZpZXcsIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBkZXNjKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIGEgdGV4dGJsb2NrIGxvb2tzIGFuZCBiZWhhdmVzIGNvcnJlY3RseSBpblxuICAgIC8vIGNvbnRlbnRFZGl0YWJsZS5cbiAgICBhZGRUZXh0YmxvY2tIYWNrcygpIHtcbiAgICAgICAgbGV0IGxhc3RDaGlsZCA9IHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXggLSAxXSwgcGFyZW50ID0gdGhpcy50b3A7XG4gICAgICAgIHdoaWxlIChsYXN0Q2hpbGQgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IGxhc3RDaGlsZDtcbiAgICAgICAgICAgIGxhc3RDaGlsZCA9IHBhcmVudC5jaGlsZHJlbltwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXN0Q2hpbGQgfHwgLy8gRW1wdHkgdGV4dGJsb2NrXG4gICAgICAgICAgICAhKGxhc3RDaGlsZCBpbnN0YW5jZW9mIFRleHRWaWV3RGVzYykgfHxcbiAgICAgICAgICAgIC9cXG4kLy50ZXN0KGxhc3RDaGlsZC5ub2RlLnRleHQpIHx8XG4gICAgICAgICAgICAodGhpcy52aWV3LnJlcXVpcmVzR2Vja29IYWNrTm9kZSAmJiAvXFxzJC8udGVzdChsYXN0Q2hpbGQubm9kZS50ZXh0KSkpIHtcbiAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3MgaW4gU2FmYXJpJ3MgY3Vyc29yIGRyYXdpbmcgKCMxMTY1KSBhbmQgQ2hyb21lJ3MgbW91c2Ugc2VsZWN0aW9uICgjMTE1MilcbiAgICAgICAgICAgIGlmICgoc2FmYXJpIHx8IGNocm9tZSkgJiYgbGFzdENoaWxkICYmIGxhc3RDaGlsZC5kb20uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEhhY2tOb2RlKFwiSU1HXCIsIHBhcmVudCk7XG4gICAgICAgICAgICB0aGlzLmFkZEhhY2tOb2RlKFwiQlJcIiwgdGhpcy50b3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEhhY2tOb2RlKG5vZGVOYW1lLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCA9PSB0aGlzLnRvcCAmJiB0aGlzLmluZGV4IDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAmJiBwYXJlbnQuY2hpbGRyZW5bdGhpcy5pbmRleF0ubWF0Y2hlc0hhY2sobm9kZU5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gICAgICAgICAgICBpZiAobm9kZU5hbWUgPT0gXCJJTUdcIikge1xuICAgICAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLXNlcGFyYXRvclwiO1xuICAgICAgICAgICAgICAgIGRvbS5hbHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09IFwiQlJcIilcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci10cmFpbGluZ0JyZWFrXCI7XG4gICAgICAgICAgICBsZXQgaGFjayA9IG5ldyBUcmFpbGluZ0hhY2tWaWV3RGVzYyh0aGlzLnRvcCwgW10sIGRvbSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAocGFyZW50ICE9IHRoaXMudG9wKVxuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKGhhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBoYWNrKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNMb2NrZWQobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NrICYmIChub2RlID09IHRoaXMubG9jayB8fCBub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5jb250YWlucyh0aGlzLmxvY2sucGFyZW50Tm9kZSkpO1xuICAgIH1cbn1cbi8vIEl0ZXJhdGUgZnJvbSB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCBhbmQgYXJyYXkgb2YgZGVzY3MgdG8gZmluZFxuLy8gZGlyZWN0bHkgbWF0Y2hpbmcgb25lcywgaW4gb3JkZXIgdG8gYXZvaWQgb3ZlcmVhZ2VybHkgcmV1c2luZyB0aG9zZVxuLy8gZm9yIG90aGVyIG5vZGVzLiBSZXR1cm5zIHRoZSBmcmFnbWVudCBpbmRleCBvZiB0aGUgZmlyc3Qgbm9kZSB0aGF0XG4vLyBpcyBwYXJ0IG9mIHRoZSBzZXF1ZW5jZSBvZiBtYXRjaGVkIG5vZGVzIGF0IHRoZSBlbmQgb2YgdGhlXG4vLyBmcmFnbWVudC5cbmZ1bmN0aW9uIHByZU1hdGNoKGZyYWcsIHBhcmVudERlc2MpIHtcbiAgICBsZXQgY3VyRGVzYyA9IHBhcmVudERlc2MsIGRlc2NJID0gY3VyRGVzYy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgbGV0IGZJID0gZnJhZy5jaGlsZENvdW50LCBtYXRjaGVkID0gbmV3IE1hcCwgbWF0Y2hlcyA9IFtdO1xuICAgIG91dGVyOiB3aGlsZSAoZkkgPiAwKSB7XG4gICAgICAgIGxldCBkZXNjO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoZGVzY0kpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGN1ckRlc2MuY2hpbGRyZW5bZGVzY0kgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgICAgICAgICBjdXJEZXNjID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZGVzY0kgPSBuZXh0LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkZXNjSS0tO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJEZXNjID09IHBhcmVudERlc2MpIHtcbiAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgZGVzY0kgPSBjdXJEZXNjLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGN1ckRlc2MpO1xuICAgICAgICAgICAgICAgIGN1ckRlc2MgPSBjdXJEZXNjLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZSA9IGRlc2Mubm9kZTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChub2RlICE9IGZyYWcuY2hpbGQoZkkgLSAxKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAtLWZJO1xuICAgICAgICBtYXRjaGVkLnNldChkZXNjLCBmSSk7XG4gICAgICAgIG1hdGNoZXMucHVzaChkZXNjKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW5kZXg6IGZJLCBtYXRjaGVkLCBtYXRjaGVzOiBtYXRjaGVzLnJldmVyc2UoKSB9O1xufVxuZnVuY3Rpb24gY29tcGFyZVNpZGUoYSwgYikge1xuICAgIHJldHVybiBhLnR5cGUuc2lkZSAtIGIudHlwZS5zaWRlO1xufVxuLy8gVGhpcyBmdW5jdGlvbiBhYnN0cmFjdHMgaXRlcmF0aW5nIG92ZXIgdGhlIG5vZGVzIGFuZCBkZWNvcmF0aW9ucyBpblxuLy8gYSBmcmFnbWVudC4gQ2FsbHMgYG9uTm9kZWAgZm9yIGVhY2ggbm9kZSwgd2l0aCBpdHMgbG9jYWwgYW5kIGNoaWxkXG4vLyBkZWNvcmF0aW9ucy4gU3BsaXRzIHRleHQgbm9kZXMgd2hlbiB0aGVyZSBpcyBhIGRlY29yYXRpb24gc3RhcnRpbmdcbi8vIG9yIGVuZGluZyBpbnNpZGUgb2YgdGhlbS4gQ2FsbHMgYG9uV2lkZ2V0YCBmb3IgZWFjaCB3aWRnZXQuXG5mdW5jdGlvbiBpdGVyRGVjbyhwYXJlbnQsIGRlY28sIG9uV2lkZ2V0LCBvbk5vZGUpIHtcbiAgICBsZXQgbG9jYWxzID0gZGVjby5sb2NhbHMocGFyZW50KSwgb2Zmc2V0ID0gMDtcbiAgICAvLyBTaW1wbGUsIGNoZWFwIHZhcmlhbnQgZm9yIHdoZW4gdGhlcmUgYXJlIG5vIGxvY2FsIGRlY29yYXRpb25zXG4gICAgaWYgKGxvY2Fscy5sZW5ndGggPT0gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudC5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHBhcmVudC5jaGlsZChpKTtcbiAgICAgICAgICAgIG9uTm9kZShjaGlsZCwgbG9jYWxzLCBkZWNvLmZvckNoaWxkKG9mZnNldCwgY2hpbGQpLCBpKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkZWNvSW5kZXggPSAwLCBhY3RpdmUgPSBbXSwgcmVzdE5vZGUgPSBudWxsO1xuICAgIGZvciAobGV0IHBhcmVudEluZGV4ID0gMDs7KSB7XG4gICAgICAgIGxldCB3aWRnZXQsIHdpZGdldHM7XG4gICAgICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID09IG9mZnNldCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBsb2NhbHNbZGVjb0luZGV4KytdO1xuICAgICAgICAgICAgaWYgKG5leHQud2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3aWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAod2lkZ2V0cyB8fCAod2lkZ2V0cyA9IFt3aWRnZXRdKSkucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkZ2V0KSB7XG4gICAgICAgICAgICBpZiAod2lkZ2V0cykge1xuICAgICAgICAgICAgICAgIHdpZGdldHMuc29ydChjb21wYXJlU2lkZSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWRnZXRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBvbldpZGdldCh3aWRnZXRzW2ldLCBwYXJlbnRJbmRleCwgISFyZXN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbldpZGdldCh3aWRnZXQsIHBhcmVudEluZGV4LCAhIXJlc3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGQsIGluZGV4O1xuICAgICAgICBpZiAocmVzdE5vZGUpIHtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjaGlsZCA9IHJlc3ROb2RlO1xuICAgICAgICAgICAgcmVzdE5vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudEluZGV4IDwgcGFyZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgICAgICAgICBjaGlsZCA9IHBhcmVudC5jaGlsZChwYXJlbnRJbmRleCsrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGFjdGl2ZVtpXS50byA8PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgYWN0aXZlLnNwbGljZShpLS0sIDEpO1xuICAgICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS5mcm9tIDw9IG9mZnNldCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA+IG9mZnNldClcbiAgICAgICAgICAgIGFjdGl2ZS5wdXNoKGxvY2Fsc1tkZWNvSW5kZXgrK10pO1xuICAgICAgICBsZXQgZW5kID0gb2Zmc2V0ICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGlmIChjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgICAgIGxldCBjdXRBdCA9IGVuZDtcbiAgICAgICAgICAgIGlmIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLmZyb20gPCBjdXRBdClcbiAgICAgICAgICAgICAgICBjdXRBdCA9IGxvY2Fsc1tkZWNvSW5kZXhdLmZyb207XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlW2ldLnRvIDwgY3V0QXQpXG4gICAgICAgICAgICAgICAgICAgIGN1dEF0ID0gYWN0aXZlW2ldLnRvO1xuICAgICAgICAgICAgaWYgKGN1dEF0IDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzdE5vZGUgPSBjaGlsZC5jdXQoY3V0QXQgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY3V0KDAsIGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBlbmQgPSBjdXRBdDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPCBlbmQpXG4gICAgICAgICAgICAgICAgZGVjb0luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dGVyRGVjbyA9IGNoaWxkLmlzSW5saW5lICYmICFjaGlsZC5pc0xlYWYgPyBhY3RpdmUuZmlsdGVyKGQgPT4gIWQuaW5saW5lKSA6IGFjdGl2ZS5zbGljZSgpO1xuICAgICAgICBvbk5vZGUoY2hpbGQsIG91dGVyRGVjbywgZGVjby5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKSwgaW5kZXgpO1xuICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgfVxufVxuLy8gTGlzdCBtYXJrZXJzIGluIE1vYmlsZSBTYWZhcmkgd2lsbCBteXN0ZXJpb3VzbHkgZGlzYXBwZWFyXG4vLyBzb21ldGltZXMuIFRoaXMgd29ya3MgYXJvdW5kIHRoYXQuXG5mdW5jdGlvbiBpb3NIYWNrcyhkb20pIHtcbiAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiVUxcIiB8fCBkb20ubm9kZU5hbWUgPT0gXCJPTFwiKSB7XG4gICAgICAgIGxldCBvbGRDU1MgPSBkb20uc3R5bGUuY3NzVGV4dDtcbiAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBvbGRDU1MgKyBcIjsgbGlzdC1zdHlsZTogc3F1YXJlICFpbXBvcnRhbnRcIjtcbiAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tKS5saXN0U3R5bGU7XG4gICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5lYXJieVRleHROb2RlKG5vZGUsIG9mZnNldCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gb2Zmc2V0ICYmIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIG9mZnNldCA9IG5vZGVTaXplKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBGaW5kIGEgcGllY2Ugb2YgdGV4dCBpbiBhbiBpbmxpbmUgZnJhZ21lbnQsIG92ZXJsYXBwaW5nIGZyb20tdG9cbmZ1bmN0aW9uIGZpbmRUZXh0SW5GcmFnbWVudChmcmFnLCB0ZXh0LCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgZnJhZy5jaGlsZENvdW50ICYmIHBvcyA8PSB0bzspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZnJhZy5jaGlsZChpKyspLCBjaGlsZFN0YXJ0ID0gcG9zO1xuICAgICAgICBwb3MgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGlmICghY2hpbGQuaXNUZXh0KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBzdHIgPSBjaGlsZC50ZXh0O1xuICAgICAgICB3aGlsZSAoaSA8IGZyYWcuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBmcmFnLmNoaWxkKGkrKyk7XG4gICAgICAgICAgICBwb3MgKz0gbmV4dC5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmICghbmV4dC5pc1RleHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdHIgKz0gbmV4dC50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gZnJvbSkge1xuICAgICAgICAgICAgaWYgKHBvcyA+PSB0byAmJiBzdHIuc2xpY2UodG8gLSB0ZXh0Lmxlbmd0aCAtIGNoaWxkU3RhcnQsIHRvIC0gY2hpbGRTdGFydCkgPT0gdGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gdG8gLSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGNoaWxkU3RhcnQgPCB0byA/IHN0ci5sYXN0SW5kZXhPZih0ZXh0LCB0byAtIGNoaWxkU3RhcnQgLSAxKSA6IC0xO1xuICAgICAgICAgICAgaWYgKGZvdW5kID49IDAgJiYgZm91bmQgKyB0ZXh0Lmxlbmd0aCArIGNoaWxkU3RhcnQgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRTdGFydCArIGZvdW5kO1xuICAgICAgICAgICAgaWYgKGZyb20gPT0gdG8gJiYgc3RyLmxlbmd0aCA+PSAodG8gKyB0ZXh0Lmxlbmd0aCkgLSBjaGlsZFN0YXJ0ICYmXG4gICAgICAgICAgICAgICAgc3RyLnNsaWNlKHRvIC0gY2hpbGRTdGFydCwgdG8gLSBjaGlsZFN0YXJ0ICsgdGV4dC5sZW5ndGgpID09IHRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8vIFJlcGxhY2UgcmFuZ2UgZnJvbS10byBpbiBhbiBhcnJheSBvZiB2aWV3IGRlc2NzIHdpdGggcmVwbGFjZW1lbnRcbi8vIChtYXkgYmUgbnVsbCB0byBqdXN0IGRlbGV0ZSkuIFRoaXMgZ29lcyB2ZXJ5IG11Y2ggYWdhaW5zdCB0aGUgZ3JhaW5cbi8vIG9mIHRoZSByZXN0IG9mIHRoaXMgY29kZSwgd2hpY2ggdGVuZHMgdG8gY3JlYXRlIG5vZGVzIHdpdGggdGhlXG4vLyByaWdodCBzaGFwZSBpbiBvbmUgZ28sIHJhdGhlciB0aGFuIG1lc3Npbmcgd2l0aCB0aGVtIGFmdGVyXG4vLyBjcmVhdGlvbiwgYnV0IGlzIG5lY2Vzc2FyeSBpbiB0aGUgY29tcG9zaXRpb24gaGFjay5cbmZ1bmN0aW9uIHJlcGxhY2VOb2Rlcyhub2RlcywgZnJvbSwgdG8sIHZpZXcsIHJlcGxhY2VtZW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBvZmYgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gbm9kZXNbaV0sIHN0YXJ0ID0gb2ZmLCBlbmQgPSBvZmYgKz0gY2hpbGQuc2l6ZTtcbiAgICAgICAgaWYgKHN0YXJ0ID49IHRvIHx8IGVuZCA8PSBmcm9tKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkLnNsaWNlKDAsIGZyb20gLSBzdGFydCwgdmlldykpO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkLnNsaWNlKHRvIC0gc3RhcnQsIGNoaWxkLnNpemUsIHZpZXcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcsIG9yaWdpbiA9IG51bGwpIHtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpLCBkb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICBpZiAoIWRvbVNlbC5mb2N1c05vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBuZWFyZXN0RGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhkb21TZWwuZm9jdXNOb2RlKSwgaW5XaWRnZXQgPSBuZWFyZXN0RGVzYyAmJiBuZWFyZXN0RGVzYy5zaXplID09IDA7XG4gICAgbGV0IGhlYWQgPSB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIDEpO1xuICAgIGlmIChoZWFkIDwgMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0ICRoZWFkID0gZG9jLnJlc29sdmUoaGVhZCksICRhbmNob3IsIHNlbGVjdGlvbjtcbiAgICBpZiAoc2VsZWN0aW9uQ29sbGFwc2VkKGRvbVNlbCkpIHtcbiAgICAgICAgJGFuY2hvciA9ICRoZWFkO1xuICAgICAgICB3aGlsZSAobmVhcmVzdERlc2MgJiYgIW5lYXJlc3REZXNjLm5vZGUpXG4gICAgICAgICAgICBuZWFyZXN0RGVzYyA9IG5lYXJlc3REZXNjLnBhcmVudDtcbiAgICAgICAgbGV0IG5lYXJlc3REZXNjTm9kZSA9IG5lYXJlc3REZXNjLm5vZGU7XG4gICAgICAgIGlmIChuZWFyZXN0RGVzYyAmJiBuZWFyZXN0RGVzY05vZGUuaXNBdG9tICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5lYXJlc3REZXNjTm9kZSkgJiYgbmVhcmVzdERlc2MucGFyZW50XG4gICAgICAgICAgICAmJiAhKG5lYXJlc3REZXNjTm9kZS5pc0lubGluZSAmJiBpc09uRWRnZShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIG5lYXJlc3REZXNjLmRvbSkpKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gbmVhcmVzdERlc2MucG9zQmVmb3JlO1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gbmV3IE5vZGVTZWxlY3Rpb24oaGVhZCA9PSBwb3MgPyAkaGVhZCA6IGRvYy5yZXNvbHZlKHBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgYW5jaG9yID0gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQsIDEpO1xuICAgICAgICBpZiAoYW5jaG9yIDwgMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAkYW5jaG9yID0gZG9jLnJlc29sdmUoYW5jaG9yKTtcbiAgICB9XG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGJpYXMgPSBvcmlnaW4gPT0gXCJwb2ludGVyXCIgfHwgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmhlYWQgPCAkaGVhZC5wb3MgJiYgIWluV2lkZ2V0KSA/IDEgOiAtMTtcbiAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkYW5jaG9yLCAkaGVhZCwgYmlhcyk7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiBlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpIHtcbiAgICByZXR1cm4gdmlldy5lZGl0YWJsZSA/IHZpZXcuaGFzRm9jdXMoKSA6XG4gICAgICAgIGhhc1NlbGVjdGlvbih2aWV3KSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY29udGFpbnModmlldy5kb20pO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uVG9ET00odmlldywgZm9yY2UgPSBmYWxzZSkge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBzeW5jTm9kZVNlbGVjdGlvbih2aWV3LCBzZWwpO1xuICAgIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIFRoZSBkZWxheWVkIGRyYWcgc2VsZWN0aW9uIGNhdXNlcyBpc3N1ZXMgd2l0aCBDZWxsIFNlbGVjdGlvbnNcbiAgICAvLyBpbiBTYWZhcmkuIEFuZCB0aGUgZHJhZyBzZWxlY3Rpb24gZGVsYXkgaXMgdG8gd29ya2Fyb25kIGlzc3Vlc1xuICAgIC8vIHdoaWNoIG9ubHkgcHJlc2VudCBpbiBDaHJvbWUuXG4gICAgaWYgKCFmb3JjZSAmJiB2aWV3LmlucHV0Lm1vdXNlRG93biAmJiB2aWV3LmlucHV0Lm1vdXNlRG93bi5hbGxvd0RlZmF1bHQgJiYgY2hyb21lKSB7XG4gICAgICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCksIGN1clNlbCA9IHZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICYmIGN1clNlbC5hbmNob3JOb2RlICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCwgY3VyU2VsLmFuY2hvck5vZGUsIGN1clNlbC5hbmNob3JPZmZzZXQpKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93bi5kZWxheWVkU2VsZWN0aW9uU3luYyA9IHRydWU7XG4gICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZGlzY29ubmVjdFNlbGVjdGlvbigpO1xuICAgIGlmICh2aWV3LmN1cnNvcldyYXBwZXIpIHtcbiAgICAgICAgc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB7IGFuY2hvciwgaGVhZCB9ID0gc2VsLCByZXNldEVkaXRhYmxlRnJvbSwgcmVzZXRFZGl0YWJsZVRvO1xuICAgICAgICBpZiAoYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUgJiYgIShzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgaWYgKCFzZWwuJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZUZyb20gPSB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBzZWwuZnJvbSk7XG4gICAgICAgICAgICBpZiAoIXNlbC5lbXB0eSAmJiAhc2VsLiRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGVUbyA9IHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHNlbC50byk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5kb2NWaWV3LnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHZpZXcucm9vdCwgZm9yY2UpO1xuICAgICAgICBpZiAoYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGlmIChyZXNldEVkaXRhYmxlRnJvbSlcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlKHJlc2V0RWRpdGFibGVGcm9tKTtcbiAgICAgICAgICAgIGlmIChyZXNldEVkaXRhYmxlVG8pXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZShyZXNldEVkaXRhYmxlVG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWwudmlzaWJsZSkge1xuICAgICAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgICAgICAgIGlmIChcIm9uc2VsZWN0aW9uY2hhbmdlXCIgaW4gZG9jdW1lbnQpXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NPblNlbGVjdGlvbkNoYW5nZSh2aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuY29ubmVjdFNlbGVjdGlvbigpO1xufVxuLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIFdlYmtpdCBub3QgYWxsb3dpbmcgYSBzZWxlY3Rpb24gdG8gc3RhcnQvZW5kXG4vLyBiZXR3ZWVuIG5vbi1lZGl0YWJsZSBibG9jayBub2Rlcy4gV2UgYnJpZWZseSBtYWtlIHNvbWV0aGluZ1xuLy8gZWRpdGFibGUsIHNldCB0aGUgc2VsZWN0aW9uLCB0aGVuIHNldCBpdCB1bmVkaXRhYmxlIGFnYWluLlxuY29uc3QgYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUgPSBzYWZhcmkgfHwgY2hyb21lICYmIGNocm9tZV92ZXJzaW9uIDwgNjM7XG5mdW5jdGlvbiB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBwb3MpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgMCk7XG4gICAgbGV0IGFmdGVyID0gb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA/IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdIDogbnVsbDtcbiAgICBsZXQgYmVmb3JlID0gb2Zmc2V0ID8gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdIDogbnVsbDtcbiAgICBpZiAoc2FmYXJpICYmIGFmdGVyICYmIGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgIHJldHVybiBzZXRFZGl0YWJsZShhZnRlcik7XG4gICAgaWYgKCghYWZ0ZXIgfHwgYWZ0ZXIuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgJiZcbiAgICAgICAgKCFiZWZvcmUgfHwgYmVmb3JlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpKSB7XG4gICAgICAgIGlmIChhZnRlcilcbiAgICAgICAgICAgIHJldHVybiBzZXRFZGl0YWJsZShhZnRlcik7XG4gICAgICAgIGVsc2UgaWYgKGJlZm9yZSlcbiAgICAgICAgICAgIHJldHVybiBzZXRFZGl0YWJsZShiZWZvcmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICAgIGlmIChzYWZhcmkgJiYgZWxlbWVudC5kcmFnZ2FibGUpIHtcbiAgICAgICAgZWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgZWxlbWVudC53YXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIHJlc2V0RWRpdGFibGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgIGlmIChlbGVtZW50Lndhc0RyYWdnYWJsZSkge1xuICAgICAgICBlbGVtZW50LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiByZW1vdmVDbGFzc09uU2VsZWN0aW9uQ2hhbmdlKHZpZXcpIHtcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IGRvbVNlbC5hbmNob3JOb2RlLCBvZmZzZXQgPSBkb21TZWwuYW5jaG9yT2Zmc2V0O1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkID0gKCkgPT4ge1xuICAgICAgICBpZiAoZG9tU2VsLmFuY2hvck5vZGUgIT0gbm9kZSB8fCBkb21TZWwuYW5jaG9yT2Zmc2V0ICE9IG9mZnNldCkge1xuICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpIHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUpXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgICAgICAgfSwgMjApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZWxlY3RDdXJzb3JXcmFwcGVyKHZpZXcpIHtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb24oKSwgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIGxldCBub2RlID0gdmlldy5jdXJzb3JXcmFwcGVyLmRvbSwgaW1nID0gbm9kZS5ub2RlTmFtZSA9PSBcIklNR1wiO1xuICAgIGlmIChpbWcpXG4gICAgICAgIHJhbmdlLnNldEVuZChub2RlLnBhcmVudE5vZGUsIGRvbUluZGV4KG5vZGUpICsgMSk7XG4gICAgZWxzZVxuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgMCk7XG4gICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgIGRvbVNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBkb21TZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgIC8vIEtsdWRnZSB0byBraWxsICdjb250cm9sIHNlbGVjdGlvbicgaW4gSUUxMSB3aGVuIHNlbGVjdGluZyBhblxuICAgIC8vIGludmlzaWJsZSBjdXJzb3Igd3JhcHBlciwgc2luY2UgdGhhdCB3b3VsZCByZXN1bHQgaW4gdGhvc2Ugd2VpcmRcbiAgICAvLyByZXNpemUgaGFuZGxlcyBhbmQgYSBzZWxlY3Rpb24gdGhhdCBjb25zaWRlcnMgdGhlIGFic29sdXRlbHlcbiAgICAvLyBwb3NpdGlvbmVkIHdyYXBwZXIsIHJhdGhlciB0aGFuIHRoZSByb290IGVkaXRhYmxlIG5vZGUsIHRoZVxuICAgIC8vIGZvY3VzZWQgZWxlbWVudC5cbiAgICBpZiAoIWltZyAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSAmJiBpZSAmJiBpZV92ZXJzaW9uIDw9IDExKSB7XG4gICAgICAgIG5vZGUuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBub2RlLmRpc2FibGVkID0gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gc3luY05vZGVTZWxlY3Rpb24odmlldywgc2VsKSB7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcuZGVzY0F0KHNlbC5mcm9tKTtcbiAgICAgICAgaWYgKGRlc2MgIT0gdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYykge1xuICAgICAgICAgICAgY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpO1xuICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgZGVzYy5zZWxlY3ROb2RlKCk7XG4gICAgICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gZGVzYztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpO1xuICAgIH1cbn1cbi8vIENsZWFyIGFsbCBET00gc3RhdGVmdWxuZXNzIG9mIHRoZSBsYXN0IG5vZGUgc2VsZWN0aW9uLlxuZnVuY3Rpb24gY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYykge1xuICAgICAgICBpZiAodmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYy5wYXJlbnQpXG4gICAgICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjLmRlc2VsZWN0Tm9kZSgpO1xuICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkJldHdlZW4odmlldywgJGFuY2hvciwgJGhlYWQsIGJpYXMpIHtcbiAgICByZXR1cm4gdmlldy5zb21lUHJvcChcImNyZWF0ZVNlbGVjdGlvbkJldHdlZW5cIiwgZiA9PiBmKHZpZXcsICRhbmNob3IsICRoZWFkKSlcbiAgICAgICAgfHwgVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKCRhbmNob3IsICRoZWFkLCBiaWFzKTtcbn1cbmZ1bmN0aW9uIGhhc0ZvY3VzQW5kU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5lZGl0YWJsZSAmJiAhdmlldy5oYXNGb2N1cygpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGhhc1NlbGVjdGlvbih2aWV3KTtcbn1cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbih2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBpZiAoIXNlbC5hbmNob3JOb2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyZWZveCB3aWxsIHJhaXNlICdwZXJtaXNzaW9uIGRlbmllZCcgZXJyb3JzIHdoZW4gYWNjZXNzaW5nXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb2YgYHNlbC5hbmNob3JOb2RlYCB3aGVuIGl0J3MgaW4gYSBnZW5lcmF0ZWQgQ1NTXG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHJldHVybiB2aWV3LmRvbS5jb250YWlucyhzZWwuYW5jaG9yTm9kZS5ub2RlVHlwZSA9PSAzID8gc2VsLmFuY2hvck5vZGUucGFyZW50Tm9kZSA6IHNlbC5hbmNob3JOb2RlKSAmJlxuICAgICAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgdmlldy5kb20uY29udGFpbnMoc2VsLmZvY3VzTm9kZS5ub2RlVHlwZSA9PSAzID8gc2VsLmZvY3VzTm9kZS5wYXJlbnROb2RlIDogc2VsLmZvY3VzTm9kZSkpO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gYW5jaG9ySW5SaWdodFBsYWNlKHZpZXcpIHtcbiAgICBsZXQgYW5jaG9yRE9NID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yLCAwKTtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIHJldHVybiBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xufVxuXG5mdW5jdGlvbiBtb3ZlU2VsZWN0aW9uQmxvY2soc3RhdGUsIGRpcikge1xuICAgIGxldCB7ICRhbmNob3IsICRoZWFkIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0ICRzaWRlID0gZGlyID4gMCA/ICRhbmNob3IubWF4KCRoZWFkKSA6ICRhbmNob3IubWluKCRoZWFkKTtcbiAgICBsZXQgJHN0YXJ0ID0gISRzaWRlLnBhcmVudC5pbmxpbmVDb250ZW50ID8gJHNpZGUgOiAkc2lkZS5kZXB0aCA/IHN0YXRlLmRvYy5yZXNvbHZlKGRpciA+IDAgPyAkc2lkZS5hZnRlcigpIDogJHNpZGUuYmVmb3JlKCkpIDogbnVsbDtcbiAgICByZXR1cm4gJHN0YXJ0ICYmIFNlbGVjdGlvbi5maW5kRnJvbSgkc3RhcnQsIGRpcik7XG59XG5mdW5jdGlvbiBhcHBseSh2aWV3LCBzZWwpIHtcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChtb2RzLmluZGV4T2YoXCJzXCIpID4gLTEpIHtcbiAgICAgICAgICAgIGxldCB7ICRoZWFkIH0gPSBzZWwsIG5vZGUgPSAkaGVhZC50ZXh0T2Zmc2V0ID8gbnVsbCA6IGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUuaXNUZXh0IHx8ICFub2RlLmlzTGVhZilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgJG5ld0hlYWQgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKCRoZWFkLnBvcyArIG5vZGUubm9kZVNpemUgKiAoZGlyIDwgMCA/IC0xIDogMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKHNlbC4kYW5jaG9yLCAkbmV3SGVhZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFzZWwuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA+IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIikpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiAobmV4dCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKG1hYyAmJiBtb2RzLmluZGV4T2YoXCJtXCIpID4gLTEpKSB7XG4gICAgICAgICAgICBsZXQgJGhlYWQgPSBzZWwuJGhlYWQsIG5vZGUgPSAkaGVhZC50ZXh0T2Zmc2V0ID8gbnVsbCA6IGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyLCBkZXNjO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBub2RlUG9zID0gZGlyIDwgMCA/ICRoZWFkLnBvcyAtIG5vZGUubm9kZVNpemUgOiAkaGVhZC5wb3M7XG4gICAgICAgICAgICBpZiAoIShub2RlLmlzQXRvbSB8fCAoZGVzYyA9IHZpZXcuZG9jVmlldy5kZXNjQXQobm9kZVBvcykpICYmICFkZXNjLmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgTm9kZVNlbGVjdGlvbihkaXIgPCAwID8gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgkaGVhZC5wb3MgLSBub2RlLm5vZGVTaXplKSA6ICRoZWFkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3ZWJraXQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSB3aWxsIGludHJvZHVjZSBleHRyYSBwb2ludGxlc3MgY3Vyc29yXG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb25zIGFyb3VuZCBpbmxpbmUgdW5lZGl0YWJsZSBub2Rlcywgc28gd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgIC8vIHRha2Ugb3ZlciBhbmQgbW92ZSB0aGUgY3Vyc29yIHBhc3QgdGhlbSAoIzkzNylcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24odmlldy5zdGF0ZS5kb2MucmVzb2x2ZShkaXIgPCAwID8gbm9kZVBvcyA6IG5vZGVQb3MgKyBub2RlLm5vZGVTaXplKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsLm5vZGUuaXNJbmxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVMZW4obm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNJZ25vcmFibGUoZG9tLCBkaXIpIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Muc2l6ZSA9PSAwICYmIChkaXIgPCAwIHx8IGRvbS5uZXh0U2libGluZyB8fCBkb20ubm9kZU5hbWUgIT0gXCJCUlwiKTtcbn1cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXModmlldywgZGlyKSB7XG4gICAgcmV0dXJuIGRpciA8IDAgPyBza2lwSWdub3JlZE5vZGVzQmVmb3JlKHZpZXcpIDogc2tpcElnbm9yZWROb2Rlc0FmdGVyKHZpZXcpO1xufVxuLy8gTWFrZSBzdXJlIHRoZSBjdXJzb3IgaXNuJ3QgZGlyZWN0bHkgYWZ0ZXIgb25lIG9yIG1vcmUgaWdub3JlZFxuLy8gbm9kZXMsIHdoaWNoIHdpbGwgY29uZnVzZSB0aGUgYnJvd3NlcidzIGN1cnNvciBtb3Rpb24gbG9naWMuXG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzQmVmb3JlKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBtb3ZlTm9kZSwgbW92ZU9mZnNldCwgZm9yY2UgPSBmYWxzZTtcbiAgICAvLyBHZWNrbyB3aWxsIGRvIG9kZCB0aGluZ3Mgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGRpcmVjdGx5IGluIGZyb250XG4gICAgLy8gb2YgYSBub24tZWRpdGFibGUgbm9kZSwgc28gaW4gdGhhdCBjYXNlLCBtb3ZlIGl0IGludG8gdGhlIG5leHRcbiAgICAvLyBub2RlIGlmIHBvc3NpYmxlLiBJc3N1ZSBwcm9zZW1pcnJvci9wcm9zZW1pcnJvciM4MzIuXG4gICAgaWYgKGdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlTGVuKG5vZGUpICYmIGlzSWdub3JhYmxlKG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLCAtMSkpXG4gICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChpc0lnbm9yYWJsZShiZWZvcmUsIC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSAtLW9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB3aGlsZSAocHJldiAmJiBpc0lnbm9yYWJsZShwcmV2LCAtMSkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gZG9tSW5kZXgocHJldik7XG4gICAgICAgICAgICAgICAgcHJldiA9IHByZXYucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwcmV2O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG5vZGVMZW4obm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvcmNlKVxuICAgICAgICBzZXRTZWxGb2N1cyh2aWV3LCBub2RlLCBvZmZzZXQpO1xuICAgIGVsc2UgaWYgKG1vdmVOb2RlKVxuICAgICAgICBzZXRTZWxGb2N1cyh2aWV3LCBtb3ZlTm9kZSwgbW92ZU9mZnNldCk7XG59XG4vLyBNYWtlIHN1cmUgdGhlIGN1cnNvciBpc24ndCBkaXJlY3RseSBiZWZvcmUgb25lIG9yIG1vcmUgaWdub3JlZFxuLy8gbm9kZXMuXG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzQWZ0ZXIodmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gICAgbGV0IG1vdmVOb2RlLCBtb3ZlT2Zmc2V0O1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBhZnRlciA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGlzSWdub3JhYmxlKGFmdGVyLCAxKSkge1xuICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gKytvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCbG9ja05vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQgJiYgaXNJZ25vcmFibGUobmV4dCwgMSkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5leHQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gZG9tSW5kZXgobmV4dCkgKyAxO1xuICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbGVuID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgbGVuID0gbm9kZUxlbihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobW92ZU5vZGUpXG4gICAgICAgIHNldFNlbEZvY3VzKHZpZXcsIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIGlzQmxvY2tOb2RlKGRvbSkge1xuICAgIGxldCBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gICAgcmV0dXJuIGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrO1xufVxuZnVuY3Rpb24gdGV4dE5vZGVBZnRlcihub2RlLCBvZmZzZXQpIHtcbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpICsgMTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDEgJiYgbmV4dC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRleHROb2RlQmVmb3JlKG5vZGUsIG9mZnNldCkge1xuICAgIHdoaWxlIChub2RlICYmICFvZmZzZXQgJiYgIWhhc0Jsb2NrRGVzYyhub2RlKSkge1xuICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBuZXh0ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDEgJiYgbmV4dC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICBvZmZzZXQgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFNlbEZvY3VzKHZpZXcsIG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDMpIHtcbiAgICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXI7XG4gICAgICAgIGlmIChhZnRlciA9IHRleHROb2RlQWZ0ZXIobm9kZSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgbm9kZSA9IGFmdGVyO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiZWZvcmUgPSB0ZXh0Tm9kZUJlZm9yZShub2RlLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgb2Zmc2V0ID0gYmVmb3JlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgaWYgKHNlbGVjdGlvbkNvbGxhcHNlZChzZWwpKSB7XG4gICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbC5leHRlbmQpIHtcbiAgICAgICAgc2VsLmV4dGVuZChub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3O1xuICAgIC8vIElmIG5vIHN0YXRlIHVwZGF0ZSBlbmRzIHVwIGhhcHBlbmluZywgcmVzZXQgdGhlIHNlbGVjdGlvbi5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUgPT0gc3RhdGUpXG4gICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBmaW5kRGlyZWN0aW9uKHZpZXcsIHBvcykge1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICghKGNocm9tZSB8fCB3aW5kb3dzKSAmJiAkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGxldCBjb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyk7XG4gICAgICAgIGlmIChwb3MgPiAkcG9zLnN0YXJ0KCkpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyAtIDEpO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChiZWZvcmUudG9wICsgYmVmb3JlLmJvdHRvbSkgLyAyO1xuICAgICAgICAgICAgaWYgKG1pZCA+IGNvb3Jkcy50b3AgJiYgbWlkIDwgY29vcmRzLmJvdHRvbSAmJiBNYXRoLmFicyhiZWZvcmUubGVmdCAtIGNvb3Jkcy5sZWZ0KSA+IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlZm9yZS5sZWZ0IDwgY29vcmRzLmxlZnQgPyBcImx0clwiIDogXCJydGxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zIDwgJHBvcy5lbmQoKSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gdmlldy5jb29yZHNBdFBvcyhwb3MgKyAxKTtcbiAgICAgICAgICAgIGxldCBtaWQgPSAoYWZ0ZXIudG9wICsgYWZ0ZXIuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICBpZiAobWlkID4gY29vcmRzLnRvcCAmJiBtaWQgPCBjb29yZHMuYm90dG9tICYmIE1hdGguYWJzKGFmdGVyLmxlZnQgLSBjb29yZHMubGVmdCkgPiAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBhZnRlci5sZWZ0ID4gY29vcmRzLmxlZnQgPyBcImx0clwiIDogXCJydGxcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY29tcHV0ZWQgPSBnZXRDb21wdXRlZFN0eWxlKHZpZXcuZG9tKS5kaXJlY3Rpb247XG4gICAgcmV0dXJuIGNvbXB1dGVkID09IFwicnRsXCIgPyBcInJ0bFwiIDogXCJsdHJcIjtcbn1cbi8vIENoZWNrIHdoZXRoZXIgdmVydGljYWwgc2VsZWN0aW9uIG1vdGlvbiB3b3VsZCBpbnZvbHZlIG5vZGVcbi8vIHNlbGVjdGlvbnMuIElmIHNvLCBhcHBseSBpdCAoaWYgbm90LCB0aGUgcmVzdWx0IGlzIGxlZnQgdG8gdGhlXG4vLyBicm93c2VyKVxuZnVuY3Rpb24gc2VsZWN0VmVydGljYWxseSh2aWV3LCBkaXIsIG1vZHMpIHtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgIXNlbC5lbXB0eSB8fCBtb2RzLmluZGV4T2YoXCJzXCIpID4gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAobWFjICYmIG1vZHMuaW5kZXhPZihcIm1cIikgPiAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHNlbDtcbiAgICBpZiAoISRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50IHx8IHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyIDwgMCA/IFwidXBcIiA6IFwiZG93blwiKSkge1xuICAgICAgICBsZXQgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgICBpZiAobmV4dCAmJiAobmV4dCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICAgIH1cbiAgICBpZiAoISRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGxldCBzaWRlID0gZGlyIDwgMCA/ICRmcm9tIDogJHRvO1xuICAgICAgICBsZXQgYmV5b25kID0gc2VsIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uID8gU2VsZWN0aW9uLm5lYXIoc2lkZSwgZGlyKSA6IFNlbGVjdGlvbi5maW5kRnJvbShzaWRlLCBkaXIpO1xuICAgICAgICByZXR1cm4gYmV5b25kID8gYXBwbHkodmlldywgYmV5b25kKSA6IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCBkaXIpIHtcbiAgICBpZiAoISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgeyAkaGVhZCwgJGFuY2hvciwgZW1wdHkgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQuc2FtZVBhcmVudCgkYW5jaG9yKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFlbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA+IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBuZXh0Tm9kZSA9ICEkaGVhZC50ZXh0T2Zmc2V0ICYmIChkaXIgPCAwID8gJGhlYWQubm9kZUJlZm9yZSA6ICRoZWFkLm5vZGVBZnRlcik7XG4gICAgaWYgKG5leHROb2RlICYmICFuZXh0Tm9kZS5pc1RleHQpIHtcbiAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICB0ci5kZWxldGUoJGhlYWQucG9zIC0gbmV4dE5vZGUubm9kZVNpemUsICRoZWFkLnBvcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgkaGVhZC5wb3MsICRoZWFkLnBvcyArIG5leHROb2RlLm5vZGVTaXplKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzd2l0Y2hFZGl0YWJsZSh2aWV3LCBub2RlLCBzdGF0ZSkge1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIG5vZGUuY29udGVudEVkaXRhYmxlID0gc3RhdGU7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xufVxuLy8gSXNzdWUgIzg2NyAvICMxMDkwIC8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTAzODIxXG4vLyBJbiB3aGljaCBTYWZhcmkgKGFuZCBhdCBzb21lIHBvaW50IGluIHRoZSBwYXN0LCBDaHJvbWUpIGRvZXMgcmVhbGx5XG4vLyB3cm9uZyB0aGluZ3Mgd2hlbiB0aGUgZG93biBhcnJvdyBpcyBwcmVzc2VkIHdoZW4gdGhlIGN1cnNvciBpc1xuLy8gZGlyZWN0bHkgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrIGFuZCBoYXMgYW4gdW5lZGl0YWJsZSBub2RlXG4vLyBhZnRlciBpdFxuZnVuY3Rpb24gc2FmYXJpRG93bkFycm93QnVnKHZpZXcpIHtcbiAgICBpZiAoIXNhZmFyaSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kaGVhZC5wYXJlbnRPZmZzZXQgPiAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGlmIChmb2N1c05vZGUgJiYgZm9jdXNOb2RlLm5vZGVUeXBlID09IDEgJiYgZm9jdXNPZmZzZXQgPT0gMCAmJlxuICAgICAgICBmb2N1c05vZGUuZmlyc3RDaGlsZCAmJiBmb2N1c05vZGUuZmlyc3RDaGlsZC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZvY3VzTm9kZS5maXJzdENoaWxkO1xuICAgICAgICBzd2l0Y2hFZGl0YWJsZSh2aWV3LCBjaGlsZCwgXCJ0cnVlXCIpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHN3aXRjaEVkaXRhYmxlKHZpZXcsIGNoaWxkLCBcImZhbHNlXCIpLCAyMCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIEEgYmFja2Ryb3Aga2V5IG1hcHBpbmcgdXNlZCB0byBtYWtlIHN1cmUgd2UgYWx3YXlzIHN1cHByZXNzIGtleXNcbi8vIHRoYXQgaGF2ZSBhIGRhbmdlcm91cyBkZWZhdWx0IGVmZmVjdCwgZXZlbiBpZiB0aGUgY29tbWFuZHMgdGhleSBhcmVcbi8vIGJvdW5kIHRvIHJldHVybiBmYWxzZSwgYW5kIHRvIG1ha2Ugc3VyZSB0aGF0IGN1cnNvci1tb3Rpb24ga2V5c1xuLy8gZmluZCBhIGN1cnNvciAoYXMgb3Bwb3NlZCB0byBhIG5vZGUgc2VsZWN0aW9uKSB3aGVuIHByZXNzZWQuIEZvclxuLy8gY3Vyc29yLW1vdGlvbiBrZXlzLCB0aGUgY29kZSBpbiB0aGUgaGFuZGxlcnMgYWxzbyB0YWtlcyBjYXJlIG9mXG4vLyBibG9jayBzZWxlY3Rpb25zLlxuZnVuY3Rpb24gZ2V0TW9kcyhldmVudCkge1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGlmIChldmVudC5jdHJsS2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJjXCI7XG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcIm1cIjtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJhXCI7XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJzXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVLZXlEb3duKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IGNvZGUgPSBldmVudC5rZXlDb2RlLCBtb2RzID0gZ2V0TW9kcyhldmVudCk7XG4gICAgaWYgKGNvZGUgPT0gOCB8fCAobWFjICYmIGNvZGUgPT0gNzIgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gQmFja3NwYWNlLCBDdHJsLWggb24gTWFjXG4gICAgICAgIHJldHVybiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCAtMSkgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAtMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChjb2RlID09IDQ2ICYmICFldmVudC5zaGlmdEtleSkgfHwgKG1hYyAmJiBjb2RlID09IDY4ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIERlbGV0ZSwgQ3RybC1kIG9uIE1hY1xuICAgICAgICByZXR1cm4gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgMSkgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAxKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAxMyB8fCBjb2RlID09IDI3KSB7IC8vIEVudGVyLCBFc2NcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMzcgfHwgKG1hYyAmJiBjb2RlID09IDY2ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIExlZnQgYXJyb3csIEN0cmwtYiBvbiBNYWNcbiAgICAgICAgbGV0IGRpciA9IGNvZGUgPT0gMzcgPyAoZmluZERpcmVjdGlvbih2aWV3LCB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tKSA9PSBcImx0clwiID8gLTEgOiAxKSA6IC0xO1xuICAgICAgICByZXR1cm4gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCBkaXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDM5IHx8IChtYWMgJiYgY29kZSA9PSA3MCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBSaWdodCBhcnJvdywgQ3RybC1mIG9uIE1hY1xuICAgICAgICBsZXQgZGlyID0gY29kZSA9PSAzOSA/IChmaW5kRGlyZWN0aW9uKHZpZXcsIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20pID09IFwibHRyXCIgPyAxIDogLTEpIDogMTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCBkaXIsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgZGlyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAzOCB8fCAobWFjICYmIGNvZGUgPT0gODAgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gVXAgYXJyb3csIEN0cmwtcCBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHNlbGVjdFZlcnRpY2FsbHkodmlldywgLTEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgLTEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDQwIHx8IChtYWMgJiYgY29kZSA9PSA3OCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBEb3duIGFycm93LCBDdHJsLW4gb24gTWFjXG4gICAgICAgIHJldHVybiBzYWZhcmlEb3duQXJyb3dCdWcodmlldykgfHwgc2VsZWN0VmVydGljYWxseSh2aWV3LCAxLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIDEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtb2RzID09IChtYWMgPyBcIm1cIiA6IFwiY1wiKSAmJlxuICAgICAgICAoY29kZSA9PSA2NiB8fCBjb2RlID09IDczIHx8IGNvZGUgPT0gODkgfHwgY29kZSA9PSA5MCkpIHsgLy8gTW9kLVtiaXl6XVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpIHtcbiAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtQ29waWVkXCIsIGYgPT4geyBzbGljZSA9IGYoc2xpY2UsIHZpZXcpOyB9KTtcbiAgICBsZXQgY29udGV4dCA9IFtdLCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gc2xpY2U7XG4gICAgd2hpbGUgKG9wZW5TdGFydCA+IDEgJiYgb3BlbkVuZCA+IDEgJiYgY29udGVudC5jaGlsZENvdW50ID09IDEgJiYgY29udGVudC5maXJzdENoaWxkLmNoaWxkQ291bnQgPT0gMSkge1xuICAgICAgICBvcGVuU3RhcnQtLTtcbiAgICAgICAgb3BlbkVuZC0tO1xuICAgICAgICBsZXQgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgY29udGV4dC5wdXNoKG5vZGUudHlwZS5uYW1lLCBub2RlLmF0dHJzICE9IG5vZGUudHlwZS5kZWZhdWx0QXR0cnMgPyBub2RlLmF0dHJzIDogbnVsbCk7XG4gICAgICAgIGNvbnRlbnQgPSBub2RlLmNvbnRlbnQ7XG4gICAgfVxuICAgIGxldCBzZXJpYWxpemVyID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFNlcmlhbGl6ZXJcIikgfHwgRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICBsZXQgZG9jID0gZGV0YWNoZWREb2MoKSwgd3JhcCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHdyYXAuYXBwZW5kQ2hpbGQoc2VyaWFsaXplci5zZXJpYWxpemVGcmFnbWVudChjb250ZW50LCB7IGRvY3VtZW50OiBkb2MgfSkpO1xuICAgIGxldCBmaXJzdENoaWxkID0gd3JhcC5maXJzdENoaWxkLCBuZWVkc1dyYXAsIHdyYXBwZXJzID0gMDtcbiAgICB3aGlsZSAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09IDEgJiYgKG5lZWRzV3JhcCA9IHdyYXBNYXBbZmlyc3RDaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG5lZWRzV3JhcC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHdyYXBwZXIgPSBkb2MuY3JlYXRlRWxlbWVudChuZWVkc1dyYXBbaV0pO1xuICAgICAgICAgICAgd2hpbGUgKHdyYXAuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHdyYXAuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB3cmFwLmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgICAgICAgICAgd3JhcHBlcnMrKztcbiAgICAgICAgfVxuICAgICAgICBmaXJzdENoaWxkID0gd3JhcC5maXJzdENoaWxkO1xuICAgIH1cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09IDEpXG4gICAgICAgIGZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwiZGF0YS1wbS1zbGljZVwiLCBgJHtvcGVuU3RhcnR9ICR7b3BlbkVuZH0ke3dyYXBwZXJzID8gYCAtJHt3cmFwcGVyc31gIDogXCJcIn0gJHtKU09OLnN0cmluZ2lmeShjb250ZXh0KX1gKTtcbiAgICBsZXQgdGV4dCA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRUZXh0U2VyaWFsaXplclwiLCBmID0+IGYoc2xpY2UsIHZpZXcpKSB8fFxuICAgICAgICBzbGljZS5jb250ZW50LnRleHRCZXR3ZWVuKDAsIHNsaWNlLmNvbnRlbnQuc2l6ZSwgXCJcXG5cXG5cIik7XG4gICAgcmV0dXJuIHsgZG9tOiB3cmFwLCB0ZXh0IH07XG59XG4vLyBSZWFkIGEgc2xpY2Ugb2YgY29udGVudCBmcm9tIHRoZSBjbGlwYm9hcmQgKG9yIGRyb3AgZGF0YSkuXG5mdW5jdGlvbiBwYXJzZUZyb21DbGlwYm9hcmQodmlldywgdGV4dCwgaHRtbCwgcGxhaW5UZXh0LCAkY29udGV4dCkge1xuICAgIGxldCBpbkNvZGUgPSAkY29udGV4dC5wYXJlbnQudHlwZS5zcGVjLmNvZGU7XG4gICAgbGV0IGRvbSwgc2xpY2U7XG4gICAgaWYgKCFodG1sICYmICF0ZXh0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYXNUZXh0ID0gdGV4dCAmJiAocGxhaW5UZXh0IHx8IGluQ29kZSB8fCAhaHRtbCk7XG4gICAgaWYgKGFzVGV4dCkge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkVGV4dFwiLCBmID0+IHsgdGV4dCA9IGYodGV4dCwgaW5Db2RlIHx8IHBsYWluVGV4dCwgdmlldyk7IH0pO1xuICAgICAgICBpZiAoaW5Db2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRleHQgPyBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh2aWV3LnN0YXRlLnNjaGVtYS50ZXh0KHRleHQucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSkpLCAwLCAwKSA6IFNsaWNlLmVtcHR5O1xuICAgICAgICBsZXQgcGFyc2VkID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRQYXJzZXJcIiwgZiA9PiBmKHRleHQsICRjb250ZXh0LCBwbGFpblRleHQsIHZpZXcpKTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgc2xpY2UgPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSAkY29udGV4dC5tYXJrcygpO1xuICAgICAgICAgICAgbGV0IHsgc2NoZW1hIH0gPSB2aWV3LnN0YXRlLCBzZXJpYWxpemVyID0gRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGV4dC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pKy8pLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBwID0gZG9tLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgICAgICAgICAgIHAuYXBwZW5kQ2hpbGQoc2VyaWFsaXplci5zZXJpYWxpemVOb2RlKHNjaGVtYS50ZXh0KGJsb2NrLCBtYXJrcykpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkSFRNTFwiLCBmID0+IHsgaHRtbCA9IGYoaHRtbCwgdmlldyk7IH0pO1xuICAgICAgICBkb20gPSByZWFkSFRNTChodG1sKTtcbiAgICAgICAgaWYgKHdlYmtpdClcbiAgICAgICAgICAgIHJlc3RvcmVSZXBsYWNlZFNwYWNlcyhkb20pO1xuICAgIH1cbiAgICBsZXQgY29udGV4dE5vZGUgPSBkb20gJiYgZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1wbS1zbGljZV1cIik7XG4gICAgbGV0IHNsaWNlRGF0YSA9IGNvbnRleHROb2RlICYmIC9eKFxcZCspIChcXGQrKSg/OiAtKFxcZCspKT8gKC4qKS8uZXhlYyhjb250ZXh0Tm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIpIHx8IFwiXCIpO1xuICAgIGlmIChzbGljZURhdGEgJiYgc2xpY2VEYXRhWzNdKVxuICAgICAgICBmb3IgKGxldCBpID0gK3NsaWNlRGF0YVszXTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGQgJiYgY2hpbGQubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRvbSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgaWYgKCFzbGljZSkge1xuICAgICAgICBsZXQgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFBhcnNlclwiKSB8fCB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IERPTVBhcnNlci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICAgICAgc2xpY2UgPSBwYXJzZXIucGFyc2VTbGljZShkb20sIHtcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogISEoYXNUZXh0IHx8IHNsaWNlRGF0YSksXG4gICAgICAgICAgICBjb250ZXh0OiAkY29udGV4dCxcbiAgICAgICAgICAgIHJ1bGVGcm9tTm9kZShkb20pIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiAhZG9tLm5leHRTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIGRvbS5wYXJlbnROb2RlICYmICFpbmxpbmVQYXJlbnRzLnRlc3QoZG9tLnBhcmVudE5vZGUubm9kZU5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpZ25vcmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzbGljZURhdGEpIHtcbiAgICAgICAgc2xpY2UgPSBhZGRDb250ZXh0KGNsb3NlU2xpY2Uoc2xpY2UsICtzbGljZURhdGFbMV0sICtzbGljZURhdGFbMl0pLCBzbGljZURhdGFbNF0pO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gSFRNTCB3YXNuJ3QgY3JlYXRlZCBieSBQcm9zZU1pcnJvci4gTWFrZSBzdXJlIHRvcC1sZXZlbCBzaWJsaW5ncyBhcmUgY29oZXJlbnRcbiAgICAgICAgc2xpY2UgPSBTbGljZS5tYXhPcGVuKG5vcm1hbGl6ZVNpYmxpbmdzKHNsaWNlLmNvbnRlbnQsICRjb250ZXh0KSwgdHJ1ZSk7XG4gICAgICAgIGlmIChzbGljZS5vcGVuU3RhcnQgfHwgc2xpY2Uub3BlbkVuZCkge1xuICAgICAgICAgICAgbGV0IG9wZW5TdGFydCA9IDAsIG9wZW5FbmQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZDsgb3BlblN0YXJ0IDwgc2xpY2Uub3BlblN0YXJ0ICYmICFub2RlLnR5cGUuc3BlYy5pc29sYXRpbmc7IG9wZW5TdGFydCsrLCBub2RlID0gbm9kZS5maXJzdENoaWxkKSB7IH1cbiAgICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzbGljZS5jb250ZW50Lmxhc3RDaGlsZDsgb3BlbkVuZCA8IHNsaWNlLm9wZW5FbmQgJiYgIW5vZGUudHlwZS5zcGVjLmlzb2xhdGluZzsgb3BlbkVuZCsrLCBub2RlID0gbm9kZS5sYXN0Q2hpbGQpIHsgfVxuICAgICAgICAgICAgc2xpY2UgPSBjbG9zZVNsaWNlKHNsaWNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldyk7IH0pO1xuICAgIHJldHVybiBzbGljZTtcbn1cbmNvbnN0IGlubGluZVBhcmVudHMgPSAvXihhfGFiYnJ8YWNyb255bXxifGNpdGV8Y29kZXxkZWx8ZW18aXxpbnN8a2JkfGxhYmVsfG91dHB1dHxxfHJ1Ynl8c3xzYW1wfHNwYW58c3Ryb25nfHN1YnxzdXB8dGltZXx1fHR0fHZhcikkL2k7XG4vLyBUYWtlcyBhIHNsaWNlIHBhcnNlZCB3aXRoIHBhcnNlU2xpY2UsIHdoaWNoIG1lYW5zIHRoZXJlIGhhc24ndCBiZWVuXG4vLyBhbnkgY29udGVudC1leHByZXNzaW9uIGNoZWNraW5nIGRvbmUgb24gdGhlIHRvcCBub2RlcywgdHJpZXMgdG9cbi8vIGZpbmQgYSBwYXJlbnQgbm9kZSBpbiB0aGUgY3VycmVudCBjb250ZXh0IHRoYXQgbWlnaHQgZml0IHRoZSBub2Rlcyxcbi8vIGFuZCBpZiBzdWNjZXNzZnVsLCByZWJ1aWxkcyB0aGUgc2xpY2Ugc28gdGhhdCBpdCBmaXRzIGludG8gdGhhdCBwYXJlbnQuXG4vL1xuLy8gVGhpcyBhZGRyZXNzZXMgdGhlIHByb2JsZW0gdGhhdCBUcmFuc2Zvcm0ucmVwbGFjZSBleHBlY3RzIGFcbi8vIGNvaGVyZW50IHNsaWNlLCBhbmQgd2lsbCBmYWlsIHRvIHBsYWNlIGEgc2V0IG9mIHNpYmxpbmdzIHRoYXQgZG9uJ3Rcbi8vIGZpdCBhbnl3aGVyZSBpbiB0aGUgc2NoZW1hLlxuZnVuY3Rpb24gbm9ybWFsaXplU2libGluZ3MoZnJhZ21lbnQsICRjb250ZXh0KSB7XG4gICAgaWYgKGZyYWdtZW50LmNoaWxkQ291bnQgPCAyKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgZm9yIChsZXQgZCA9ICRjb250ZXh0LmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgcGFyZW50ID0gJGNvbnRleHQubm9kZShkKTtcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KCRjb250ZXh0LmluZGV4KGQpKTtcbiAgICAgICAgbGV0IGxhc3RXcmFwLCByZXN1bHQgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB3cmFwID0gbWF0Y2guZmluZFdyYXBwaW5nKG5vZGUudHlwZSksIGluTGFzdDtcbiAgICAgICAgICAgIGlmICghd3JhcClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpbkxhc3QgPSByZXN1bHQubGVuZ3RoICYmIGxhc3RXcmFwLmxlbmd0aCAmJiBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIDApKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IGluTGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gY2xvc2VSaWdodChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCBsYXN0V3JhcC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxldCB3cmFwcGVkID0gd2l0aFdyYXBwZXJzKG5vZGUsIHdyYXApO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHdyYXBwZWQpO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hUeXBlKHdyYXBwZWQudHlwZSk7XG4gICAgICAgICAgICAgICAgbGFzdFdyYXAgPSB3cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIHdpdGhXcmFwcGVycyhub2RlLCB3cmFwLCBmcm9tID0gMCkge1xuICAgIGZvciAobGV0IGkgPSB3cmFwLmxlbmd0aCAtIDE7IGkgPj0gZnJvbTsgaS0tKVxuICAgICAgICBub2RlID0gd3JhcFtpXS5jcmVhdGUobnVsbCwgRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG4vLyBVc2VkIHRvIGdyb3VwIGFkamFjZW50IG5vZGVzIHdyYXBwZWQgaW4gc2ltaWxhciBwYXJlbnRzIGJ5XG4vLyBub3JtYWxpemVTaWJsaW5ncyBpbnRvIHRoZSBzYW1lIHBhcmVudCBub2RlXG5mdW5jdGlvbiBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHNpYmxpbmcsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoIDwgd3JhcC5sZW5ndGggJiYgZGVwdGggPCBsYXN0V3JhcC5sZW5ndGggJiYgd3JhcFtkZXB0aF0gPT0gbGFzdFdyYXBbZGVwdGhdKSB7XG4gICAgICAgIGxldCBpbm5lciA9IGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgc2libGluZy5sYXN0Q2hpbGQsIGRlcHRoICsgMSk7XG4gICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nLmNvcHkoc2libGluZy5jb250ZW50LnJlcGxhY2VDaGlsZChzaWJsaW5nLmNoaWxkQ291bnQgLSAxLCBpbm5lcikpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBzaWJsaW5nLmNvbnRlbnRNYXRjaEF0KHNpYmxpbmcuY2hpbGRDb3VudCk7XG4gICAgICAgIGlmIChtYXRjaC5tYXRjaFR5cGUoZGVwdGggPT0gd3JhcC5sZW5ndGggLSAxID8gbm9kZS50eXBlIDogd3JhcFtkZXB0aCArIDFdKSlcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nLmNvcHkoc2libGluZy5jb250ZW50LmFwcGVuZChGcmFnbWVudC5mcm9tKHdpdGhXcmFwcGVycyhub2RlLCB3cmFwLCBkZXB0aCArIDEpKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlUmlnaHQobm9kZSwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgbGV0IGZyYWdtZW50ID0gbm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChub2RlLmNoaWxkQ291bnQgLSAxLCBjbG9zZVJpZ2h0KG5vZGUubGFzdENoaWxkLCBkZXB0aCAtIDEpKTtcbiAgICBsZXQgZmlsbCA9IG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICByZXR1cm4gbm9kZS5jb3B5KGZyYWdtZW50LmFwcGVuZChmaWxsKSk7XG59XG5mdW5jdGlvbiBjbG9zZVJhbmdlKGZyYWdtZW50LCBzaWRlLCBmcm9tLCB0bywgZGVwdGgsIG9wZW5FbmQpIHtcbiAgICBsZXQgbm9kZSA9IHNpZGUgPCAwID8gZnJhZ21lbnQuZmlyc3RDaGlsZCA6IGZyYWdtZW50Lmxhc3RDaGlsZCwgaW5uZXIgPSBub2RlLmNvbnRlbnQ7XG4gICAgaWYgKGZyYWdtZW50LmNoaWxkQ291bnQgPiAxKVxuICAgICAgICBvcGVuRW5kID0gMDtcbiAgICBpZiAoZGVwdGggPCB0byAtIDEpXG4gICAgICAgIGlubmVyID0gY2xvc2VSYW5nZShpbm5lciwgc2lkZSwgZnJvbSwgdG8sIGRlcHRoICsgMSwgb3BlbkVuZCk7XG4gICAgaWYgKGRlcHRoID49IGZyb20pXG4gICAgICAgIGlubmVyID0gc2lkZSA8IDAgPyBub2RlLmNvbnRlbnRNYXRjaEF0KDApLmZpbGxCZWZvcmUoaW5uZXIsIG9wZW5FbmQgPD0gZGVwdGgpLmFwcGVuZChpbm5lcilcbiAgICAgICAgICAgIDogaW5uZXIuYXBwZW5kKG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZChzaWRlIDwgMCA/IDAgOiBmcmFnbWVudC5jaGlsZENvdW50IC0gMSwgbm9kZS5jb3B5KGlubmVyKSk7XG59XG5mdW5jdGlvbiBjbG9zZVNsaWNlKHNsaWNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBpZiAob3BlblN0YXJ0IDwgc2xpY2Uub3BlblN0YXJ0KVxuICAgICAgICBzbGljZSA9IG5ldyBTbGljZShjbG9zZVJhbmdlKHNsaWNlLmNvbnRlbnQsIC0xLCBvcGVuU3RhcnQsIHNsaWNlLm9wZW5TdGFydCwgMCwgc2xpY2Uub3BlbkVuZCksIG9wZW5TdGFydCwgc2xpY2Uub3BlbkVuZCk7XG4gICAgaWYgKG9wZW5FbmQgPCBzbGljZS5vcGVuRW5kKVxuICAgICAgICBzbGljZSA9IG5ldyBTbGljZShjbG9zZVJhbmdlKHNsaWNlLmNvbnRlbnQsIDEsIG9wZW5FbmQsIHNsaWNlLm9wZW5FbmQsIDAsIDApLCBzbGljZS5vcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIHJldHVybiBzbGljZTtcbn1cbi8vIFRyaWNrIGZyb20galF1ZXJ5IC0tIHNvbWUgZWxlbWVudHMgbXVzdCBiZSB3cmFwcGVkIGluIG90aGVyXG4vLyBlbGVtZW50cyBmb3IgaW5uZXJIVE1MIHRvIHdvcmsuIEkuZS4gaWYgeW91IGRvIGBkaXYuaW5uZXJIVE1MID1cbi8vIFwiPHRkPi4uPC90ZD5cImAgdGhlIHRhYmxlIGNlbGxzIGFyZSBpZ25vcmVkLlxuY29uc3Qgd3JhcE1hcCA9IHtcbiAgICB0aGVhZDogW1widGFibGVcIl0sXG4gICAgdGJvZHk6IFtcInRhYmxlXCJdLFxuICAgIHRmb290OiBbXCJ0YWJsZVwiXSxcbiAgICBjYXB0aW9uOiBbXCJ0YWJsZVwiXSxcbiAgICBjb2xncm91cDogW1widGFibGVcIl0sXG4gICAgY29sOiBbXCJ0YWJsZVwiLCBcImNvbGdyb3VwXCJdLFxuICAgIHRyOiBbXCJ0YWJsZVwiLCBcInRib2R5XCJdLFxuICAgIHRkOiBbXCJ0YWJsZVwiLCBcInRib2R5XCIsIFwidHJcIl0sXG4gICAgdGg6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXVxufTtcbmxldCBfZGV0YWNoZWREb2MgPSBudWxsO1xuZnVuY3Rpb24gZGV0YWNoZWREb2MoKSB7XG4gICAgcmV0dXJuIF9kZXRhY2hlZERvYyB8fCAoX2RldGFjaGVkRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwidGl0bGVcIikpO1xufVxuZnVuY3Rpb24gcmVhZEhUTUwoaHRtbCkge1xuICAgIGxldCBtZXRhcyA9IC9eKFxccyo8bWV0YSBbXj5dKj4pKi8uZXhlYyhodG1sKTtcbiAgICBpZiAobWV0YXMpXG4gICAgICAgIGh0bWwgPSBodG1sLnNsaWNlKG1ldGFzWzBdLmxlbmd0aCk7XG4gICAgbGV0IGVsdCA9IGRldGFjaGVkRG9jKCkuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBsZXQgZmlyc3RUYWcgPSAvPChbYS16XVtePlxcc10rKS9pLmV4ZWMoaHRtbCksIHdyYXA7XG4gICAgaWYgKHdyYXAgPSBmaXJzdFRhZyAmJiB3cmFwTWFwW2ZpcnN0VGFnWzFdLnRvTG93ZXJDYXNlKCldKVxuICAgICAgICBodG1sID0gd3JhcC5tYXAobiA9PiBcIjxcIiArIG4gKyBcIj5cIikuam9pbihcIlwiKSArIGh0bWwgKyB3cmFwLm1hcChuID0+IFwiPC9cIiArIG4gKyBcIj5cIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG4gICAgZWx0LmlubmVySFRNTCA9IGh0bWw7XG4gICAgaWYgKHdyYXApXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JhcC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGVsdCA9IGVsdC5xdWVyeVNlbGVjdG9yKHdyYXBbaV0pIHx8IGVsdDtcbiAgICByZXR1cm4gZWx0O1xufVxuLy8gV2Via2l0IGJyb3dzZXJzIGRvIHNvbWUgaGFyZC10by1wcmVkaWN0IHJlcGxhY2VtZW50IG9mIHJlZ3VsYXJcbi8vIHNwYWNlcyB3aXRoIG5vbi1icmVha2luZyBzcGFjZXMgd2hlbiBwdXR0aW5nIGNvbnRlbnQgb24gdGhlXG4vLyBjbGlwYm9hcmQuIFRoaXMgdHJpZXMgdG8gY29udmVydCBzdWNoIG5vbi1icmVha2luZyBzcGFjZXMgKHdoaWNoXG4vLyB3aWxsIGJlIHdyYXBwZWQgaW4gYSBwbGFpbiBzcGFuIG9uIENocm9tZSwgYSBzcGFuIHdpdGggY2xhc3Ncbi8vIEFwcGxlLWNvbnZlcnRlZC1zcGFjZSBvbiBTYWZhcmkpIGJhY2sgdG8gcmVndWxhciBzcGFjZXMuXG5mdW5jdGlvbiByZXN0b3JlUmVwbGFjZWRTcGFjZXMoZG9tKSB7XG4gICAgbGV0IG5vZGVzID0gZG9tLnF1ZXJ5U2VsZWN0b3JBbGwoY2hyb21lID8gXCJzcGFuOm5vdChbY2xhc3NdKTpub3QoW3N0eWxlXSlcIiA6IFwic3Bhbi5BcHBsZS1jb252ZXJ0ZWQtc3BhY2VcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIG5vZGUudGV4dENvbnRlbnQgPT0gXCJcXHUwMGEwXCIgJiYgbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChkb20ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIiBcIiksIG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZENvbnRleHQoc2xpY2UsIGNvbnRleHQpIHtcbiAgICBpZiAoIXNsaWNlLnNpemUpXG4gICAgICAgIHJldHVybiBzbGljZTtcbiAgICBsZXQgc2NoZW1hID0gc2xpY2UuY29udGVudC5maXJzdENoaWxkLnR5cGUuc2NoZW1hLCBhcnJheTtcbiAgICB0cnkge1xuICAgICAgICBhcnJheSA9IEpTT04ucGFyc2UoY29udGV4dCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzbGljZTtcbiAgICB9XG4gICAgbGV0IHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSBzbGljZTtcbiAgICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBzY2hlbWEubm9kZXNbYXJyYXlbaV1dO1xuICAgICAgICBpZiAoIXR5cGUgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXJyYXlbaSArIDFdLCBjb250ZW50KSk7XG4gICAgICAgIG9wZW5TdGFydCsrO1xuICAgICAgICBvcGVuRW5kKys7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2xpY2UoY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbn1cblxuLy8gQSBjb2xsZWN0aW9uIG9mIERPTSBldmVudHMgdGhhdCBvY2N1ciB3aXRoaW4gdGhlIGVkaXRvciwgYW5kIGNhbGxiYWNrIGZ1bmN0aW9uc1xuLy8gdG8gaW52b2tlIHdoZW4gdGhlIGV2ZW50IGZpcmVzLlxuY29uc3QgaGFuZGxlcnMgPSB7fTtcbmNvbnN0IGVkaXRIYW5kbGVycyA9IHt9O1xuY29uc3QgcGFzc2l2ZUhhbmRsZXJzID0geyB0b3VjaHN0YXJ0OiB0cnVlLCB0b3VjaG1vdmU6IHRydWUgfTtcbmNsYXNzIElucHV0U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNoaWZ0S2V5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW91c2VEb3duID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGVUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q2xpY2sgPSB7IHRpbWU6IDAsIHg6IDAsIHk6IDAsIHR5cGU6IFwiXCIgfTtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgdGhpcy5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0Rm9jdXMgPSAwO1xuICAgICAgICB0aGlzLmxhc3RUb3VjaCA9IDA7XG4gICAgICAgIHRoaXMubGFzdEFuZHJvaWREZWxldGUgPSAwO1xuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbXBvc2luZ1RpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbk5vZGVzID0gW107XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0ID0gLTJlODtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbklEID0gMTtcbiAgICAgICAgLy8gU2V0IHRvIGEgY29tcG9zaXRpb24gSUQgd2hlbiB0aGVyZSBhcmUgcGVuZGluZyBjaGFuZ2VzIGF0IGNvbXBvc2l0aW9uZW5kXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyA9IDA7XG4gICAgICAgIHRoaXMuZG9tQ2hhbmdlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmhpZGVTZWxlY3Rpb25HdWFyZCA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5pdElucHV0KHZpZXcpIHtcbiAgICBmb3IgKGxldCBldmVudCBpbiBoYW5kbGVycykge1xuICAgICAgICBsZXQgaGFuZGxlciA9IGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW2V2ZW50XSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50QmVsb25nc1RvVmlldyh2aWV3LCBldmVudCkgJiYgIXJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpICYmXG4gICAgICAgICAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgIShldmVudC50eXBlIGluIGVkaXRIYW5kbGVycykpKVxuICAgICAgICAgICAgICAgIGhhbmRsZXIodmlldywgZXZlbnQpO1xuICAgICAgICB9LCBwYXNzaXZlSGFuZGxlcnNbZXZlbnRdID8geyBwYXNzaXZlOiB0cnVlIH0gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvLyBPbiBTYWZhcmksIGZvciByZWFzb25zIGJleW9uZCBteSB1bmRlcnN0YW5kaW5nLCBhZGRpbmcgYW4gaW5wdXRcbiAgICAvLyBldmVudCBoYW5kbGVyIG1ha2VzIGFuIGlzc3VlIHdoZXJlIHRoZSBjb21wb3NpdGlvbiB2YW5pc2hlcyB3aGVuXG4gICAgLy8geW91IHByZXNzIGVudGVyIGdvIGF3YXkuXG4gICAgaWYgKHNhZmFyaSlcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IG51bGwpO1xuICAgIGVuc3VyZUxpc3RlbmVycyh2aWV3KTtcbn1cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBvcmlnaW4pIHtcbiAgICB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBvcmlnaW47XG4gICAgdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uVGltZSA9IERhdGUubm93KCk7XG59XG5mdW5jdGlvbiBkZXN0cm95SW5wdXQodmlldykge1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIGZvciAobGV0IHR5cGUgaW4gdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzKVxuICAgICAgICB2aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSk7XG4gICAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCk7XG4gICAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQubGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0KTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUxpc3RlbmVycyh2aWV3KSB7XG4gICAgdmlldy5zb21lUHJvcChcImhhbmRsZURPTUV2ZW50c1wiLCBjdXJyZW50SGFuZGxlcnMgPT4ge1xuICAgICAgICBmb3IgKGxldCB0eXBlIGluIGN1cnJlbnRIYW5kbGVycylcbiAgICAgICAgICAgIGlmICghdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW3R5cGVdKVxuICAgICAgICAgICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW3R5cGVdID0gZXZlbnQgPT4gcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkge1xuICAgIHJldHVybiB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRE9NRXZlbnRzXCIsIGhhbmRsZXJzID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudC50eXBlXTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIgPyBoYW5kbGVyKHZpZXcsIGV2ZW50KSB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkIDogZmFsc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBldmVudEJlbG9uZ3NUb1ZpZXcodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LmJ1YmJsZXMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbm9kZSA9IGV2ZW50LnRhcmdldDsgbm9kZSAhPSB2aWV3LmRvbTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgfHxcbiAgICAgICAgICAgIChub2RlLnBtVmlld0Rlc2MgJiYgbm9kZS5wbVZpZXdEZXNjLnN0b3BFdmVudChldmVudCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCh2aWV3LCBldmVudCkge1xuICAgIGlmICghcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkgJiYgaGFuZGxlcnNbZXZlbnQudHlwZV0gJiZcbiAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgIShldmVudC50eXBlIGluIGVkaXRIYW5kbGVycykpKVxuICAgICAgICBoYW5kbGVyc1tldmVudC50eXBlXSh2aWV3LCBldmVudCk7XG59XG5lZGl0SGFuZGxlcnMua2V5ZG93biA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgdmlldy5pbnB1dC5zaGlmdEtleSA9IGV2ZW50LmtleUNvZGUgPT0gMTYgfHwgZXZlbnQuc2hpZnRLZXk7XG4gICAgaWYgKGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpKVxuICAgICAgICByZXR1cm47XG4gICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFN1cHByZXNzIGVudGVyIGtleSBldmVudHMgb24gQ2hyb21lIEFuZHJvaWQsIGJlY2F1c2UgdGhvc2UgdGVuZFxuICAgIC8vIHRvIGJlIHBhcnQgb2YgYSBjb25mdXNlZCBzZXF1ZW5jZSBvZiBjb21wb3NpdGlvbiBldmVudHMgZmlyZWQsXG4gICAgLy8gYW5kIGhhbmRsaW5nIHRoZW0gZWFnZXJseSB0ZW5kcyB0byBjb3JydXB0IHRoZSBpbnB1dC5cbiAgICBpZiAoYW5kcm9pZCAmJiBjaHJvbWUgJiYgZXZlbnQua2V5Q29kZSA9PSAxMylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChldmVudC5rZXlDb2RlICE9IDIyOSlcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5mb3JjZUZsdXNoKCk7XG4gICAgLy8gT24gaU9TLCBpZiB3ZSBwcmV2ZW50RGVmYXVsdCBlbnRlciBrZXkgcHJlc3NlcywgdGhlIHZpcnR1YWxcbiAgICAvLyBrZXlib2FyZCBnZXRzIGNvbmZ1c2VkLiBTbyB0aGUgaGFjayBoZXJlIGlzIHRvIHNldCBhIGZsYWcgdGhhdFxuICAgIC8vIG1ha2VzIHRoZSBET00gY2hhbmdlIGNvZGUgcmVjb2duaXplIHRoYXQgd2hhdCBqdXN0IGhhcHBlbnMgc2hvdWxkXG4gICAgLy8gYmUgcmVwbGFjZWQgYnkgd2hhdGV2ZXIgdGhlIEVudGVyIGtleSBoYW5kbGVycyBkby5cbiAgICBpZiAoaW9zICYmIGV2ZW50LmtleUNvZGUgPT0gMTMgJiYgIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSAmJiAhZXZlbnQubWV0YUtleSkge1xuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSBub3c7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPT0gbm93KSB7XG4gICAgICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSk7XG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAyMDApO1xuICAgIH1cbiAgICBlbHNlIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywgZXZlbnQpKSB8fCBjYXB0dXJlS2V5RG93bih2aWV3LCBldmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcImtleVwiKTtcbiAgICB9XG59O1xuZWRpdEhhbmRsZXJzLmtleXVwID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTYpXG4gICAgICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBmYWxzZTtcbn07XG5lZGl0SGFuZGxlcnMua2V5cHJlc3MgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGlmIChpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSB8fCAhZXZlbnQuY2hhckNvZGUgfHxcbiAgICAgICAgZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5IHx8IG1hYyAmJiBldmVudC5tZXRhS2V5KVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlQcmVzc1wiLCBmID0+IGYodmlldywgZXZlbnQpKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoIShzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB8fCAhc2VsLiRmcm9tLnNhbWVQYXJlbnQoc2VsLiR0bykpIHtcbiAgICAgICAgbGV0IHRleHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmNoYXJDb2RlKTtcbiAgICAgICAgaWYgKCEvW1xcclxcbl0vLnRlc3QodGV4dCkgJiYgIXZpZXcuc29tZVByb3AoXCJoYW5kbGVUZXh0SW5wdXRcIiwgZiA9PiBmKHZpZXcsIHNlbC4kZnJvbS5wb3MsIHNlbC4kdG8ucG9zLCB0ZXh0KSkpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dCh0ZXh0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZXZlbnRDb29yZHMoZXZlbnQpIHsgcmV0dXJuIHsgbGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZIH07IH1cbmZ1bmN0aW9uIGlzTmVhcihldmVudCwgY2xpY2spIHtcbiAgICBsZXQgZHggPSBjbGljay54IC0gZXZlbnQuY2xpZW50WCwgZHkgPSBjbGljay55IC0gZXZlbnQuY2xpZW50WTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgPCAxMDA7XG59XG5mdW5jdGlvbiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIHByb3BOYW1lLCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgICBpZiAoaW5zaWRlID09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGlmICh2aWV3LnNvbWVQcm9wKHByb3BOYW1lLCBmID0+IGkgPiAkcG9zLmRlcHRoID8gZih2aWV3LCBwb3MsICRwb3Mubm9kZUFmdGVyLCAkcG9zLmJlZm9yZShpKSwgZXZlbnQsIHRydWUpXG4gICAgICAgICAgICA6IGYodmlldywgcG9zLCAkcG9zLm5vZGUoaSksICRwb3MuYmVmb3JlKGkpLCBldmVudCwgZmFsc2UpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24odmlldywgc2VsZWN0aW9uLCBvcmlnaW4pIHtcbiAgICBpZiAoIXZpZXcuZm9jdXNlZClcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgaWYgKG9yaWdpbiA9PSBcInBvaW50ZXJcIilcbiAgICAgICAgdHIuc2V0TWV0YShcInBvaW50ZXJcIiwgdHJ1ZSk7XG4gICAgdmlldy5kaXNwYXRjaCh0cik7XG59XG5mdW5jdGlvbiBzZWxlY3RDbGlja2VkTGVhZih2aWV3LCBpbnNpZGUpIHtcbiAgICBpZiAoaW5zaWRlID09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSksIG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICBpZiAobm9kZSAmJiBub2RlLmlzQXRvbSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgbmV3IE5vZGVTZWxlY3Rpb24oJHBvcyksIFwicG9pbnRlclwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdENsaWNrZWROb2RlKHZpZXcsIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24sIHNlbGVjdGVkTm9kZSwgc2VsZWN0QXQ7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pXG4gICAgICAgIHNlbGVjdGVkTm9kZSA9IHNlbC5ub2RlO1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShpbnNpZGUpO1xuICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoICsgMTsgaSA+IDA7IGktLSkge1xuICAgICAgICBsZXQgbm9kZSA9IGkgPiAkcG9zLmRlcHRoID8gJHBvcy5ub2RlQWZ0ZXIgOiAkcG9zLm5vZGUoaSk7XG4gICAgICAgIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZSAmJiBzZWwuJGZyb20uZGVwdGggPiAwICYmXG4gICAgICAgICAgICAgICAgaSA+PSBzZWwuJGZyb20uZGVwdGggJiYgJHBvcy5iZWZvcmUoc2VsLiRmcm9tLmRlcHRoICsgMSkgPT0gc2VsLiRmcm9tLnBvcylcbiAgICAgICAgICAgICAgICBzZWxlY3RBdCA9ICRwb3MuYmVmb3JlKHNlbC4kZnJvbS5kZXB0aCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VsZWN0QXQgPSAkcG9zLmJlZm9yZShpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZWxlY3RBdCAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgc2VsZWN0QXQpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVNpbmdsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCwgc2VsZWN0Tm9kZSkge1xuICAgIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVDbGlja1wiLCBmID0+IGYodmlldywgcG9zLCBldmVudCkpIHx8XG4gICAgICAgIChzZWxlY3ROb2RlID8gc2VsZWN0Q2xpY2tlZE5vZGUodmlldywgaW5zaWRlKSA6IHNlbGVjdENsaWNrZWRMZWFmKHZpZXcsIGluc2lkZSkpO1xufVxuZnVuY3Rpb24gaGFuZGxlRG91YmxlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVEb3VibGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZURvdWJsZUNsaWNrXCIsIGYgPT4gZih2aWV3LCBwb3MsIGV2ZW50KSk7XG59XG5mdW5jdGlvbiBoYW5kbGVUcmlwbGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZVRyaXBsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlVHJpcGxlQ2xpY2tcIiwgZiA9PiBmKHZpZXcsIHBvcywgZXZlbnQpKSB8fFxuICAgICAgICBkZWZhdWx0VHJpcGxlQ2xpY2sodmlldywgaW5zaWRlLCBldmVudCk7XG59XG5mdW5jdGlvbiBkZWZhdWx0VHJpcGxlQ2xpY2sodmlldywgaW5zaWRlLCBldmVudCkge1xuICAgIGlmIChldmVudC5idXR0b24gIT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBkb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICBpZiAoaW5zaWRlID09IC0xKSB7XG4gICAgICAgIGlmIChkb2MuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgMCwgZG9jLmNvbnRlbnQuc2l6ZSksIFwicG9pbnRlclwiKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShpbnNpZGUpO1xuICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoICsgMTsgaSA+IDA7IGktLSkge1xuICAgICAgICBsZXQgbm9kZSA9IGkgPiAkcG9zLmRlcHRoID8gJHBvcy5ub2RlQWZ0ZXIgOiAkcG9zLm5vZGUoaSk7XG4gICAgICAgIGxldCBub2RlUG9zID0gJHBvcy5iZWZvcmUoaSk7XG4gICAgICAgIGlmIChub2RlLmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBub2RlUG9zICsgMSwgbm9kZVBvcyArIDEgKyBub2RlLmNvbnRlbnQuc2l6ZSksIFwicG9pbnRlclwiKTtcbiAgICAgICAgZWxzZSBpZiAoTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgTm9kZVNlbGVjdGlvbi5jcmVhdGUoZG9jLCBub2RlUG9zKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZm9yY2VET01GbHVzaCh2aWV3KSB7XG4gICAgcmV0dXJuIGVuZENvbXBvc2l0aW9uKHZpZXcpO1xufVxuY29uc3Qgc2VsZWN0Tm9kZU1vZGlmaWVyID0gbWFjID8gXCJtZXRhS2V5XCIgOiBcImN0cmxLZXlcIjtcbmhhbmRsZXJzLm1vdXNlZG93biA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgdmlldy5pbnB1dC5zaGlmdEtleSA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgIGxldCBmbHVzaGVkID0gZm9yY2VET01GbHVzaCh2aWV3KTtcbiAgICBsZXQgbm93ID0gRGF0ZS5ub3coKSwgdHlwZSA9IFwic2luZ2xlQ2xpY2tcIjtcbiAgICBpZiAobm93IC0gdmlldy5pbnB1dC5sYXN0Q2xpY2sudGltZSA8IDUwMCAmJiBpc05lYXIoZXZlbnQsIHZpZXcuaW5wdXQubGFzdENsaWNrKSAmJiAhZXZlbnRbc2VsZWN0Tm9kZU1vZGlmaWVyXSkge1xuICAgICAgICBpZiAodmlldy5pbnB1dC5sYXN0Q2xpY2sudHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpXG4gICAgICAgICAgICB0eXBlID0gXCJkb3VibGVDbGlja1wiO1xuICAgICAgICBlbHNlIGlmICh2aWV3LmlucHV0Lmxhc3RDbGljay50eXBlID09IFwiZG91YmxlQ2xpY2tcIilcbiAgICAgICAgICAgIHR5cGUgPSBcInRyaXBsZUNsaWNrXCI7XG4gICAgfVxuICAgIHZpZXcuaW5wdXQubGFzdENsaWNrID0geyB0aW1lOiBub3csIHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFksIHR5cGUgfTtcbiAgICBsZXQgcG9zID0gdmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgIGlmICghcG9zKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGUgPT0gXCJzaW5nbGVDbGlja1wiKSB7XG4gICAgICAgIGlmICh2aWV3LmlucHV0Lm1vdXNlRG93bilcbiAgICAgICAgICAgIHZpZXcuaW5wdXQubW91c2VEb3duLmRvbmUoKTtcbiAgICAgICAgdmlldy5pbnB1dC5tb3VzZURvd24gPSBuZXcgTW91c2VEb3duKHZpZXcsIHBvcywgZXZlbnQsICEhZmx1c2hlZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCh0eXBlID09IFwiZG91YmxlQ2xpY2tcIiA/IGhhbmRsZURvdWJsZUNsaWNrIDogaGFuZGxlVHJpcGxlQ2xpY2spKHZpZXcsIHBvcy5wb3MsIHBvcy5pbnNpZGUsIGV2ZW50KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbiAgICB9XG59O1xuY2xhc3MgTW91c2VEb3duIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBwb3MsIGV2ZW50LCBmbHVzaGVkKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMuZmx1c2hlZCA9IGZsdXNoZWQ7XG4gICAgICAgIHRoaXMuZGVsYXllZFNlbGVjdGlvblN5bmMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5taWdodERyYWcgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXJ0RG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgICAgIHRoaXMuc2VsZWN0Tm9kZSA9ICEhZXZlbnRbc2VsZWN0Tm9kZU1vZGlmaWVyXTtcbiAgICAgICAgdGhpcy5hbGxvd0RlZmF1bHQgPSBldmVudC5zaGlmdEtleTtcbiAgICAgICAgbGV0IHRhcmdldE5vZGUsIHRhcmdldFBvcztcbiAgICAgICAgaWYgKHBvcy5pbnNpZGUgPiAtMSkge1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IHZpZXcuc3RhdGUuZG9jLm5vZGVBdChwb3MuaW5zaWRlKTtcbiAgICAgICAgICAgIHRhcmdldFBvcyA9IHBvcy5pbnNpZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zLnBvcyk7XG4gICAgICAgICAgICB0YXJnZXROb2RlID0gJHBvcy5wYXJlbnQ7XG4gICAgICAgICAgICB0YXJnZXRQb3MgPSAkcG9zLmRlcHRoID8gJHBvcy5iZWZvcmUoKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZmx1c2hlZCA/IG51bGwgOiBldmVudC50YXJnZXQ7XG4gICAgICAgIGNvbnN0IHRhcmdldERlc2MgPSB0YXJnZXQgPyB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2ModGFyZ2V0LCB0cnVlKSA6IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0RGVzYyA/IHRhcmdldERlc2MuZG9tIDogbnVsbDtcbiAgICAgICAgbGV0IHsgc2VsZWN0aW9uIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID09IDAgJiZcbiAgICAgICAgICAgIHRhcmdldE5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSAmJiB0YXJnZXROb2RlLnR5cGUuc3BlYy5zZWxlY3RhYmxlICE9PSBmYWxzZSB8fFxuICAgICAgICAgICAgc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzZWxlY3Rpb24uZnJvbSA8PSB0YXJnZXRQb3MgJiYgc2VsZWN0aW9uLnRvID4gdGFyZ2V0UG9zKVxuICAgICAgICAgICAgdGhpcy5taWdodERyYWcgPSB7XG4gICAgICAgICAgICAgICAgbm9kZTogdGFyZ2V0Tm9kZSxcbiAgICAgICAgICAgICAgICBwb3M6IHRhcmdldFBvcyxcbiAgICAgICAgICAgICAgICBhZGRBdHRyOiAhISh0aGlzLnRhcmdldCAmJiAhdGhpcy50YXJnZXQuZHJhZ2dhYmxlKSxcbiAgICAgICAgICAgICAgICBzZXRVbmVkaXRhYmxlOiAhISh0aGlzLnRhcmdldCAmJiBnZWNrbyAmJiAhdGhpcy50YXJnZXQuaGFzQXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0ICYmIHRoaXMubWlnaHREcmFnICYmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyIHx8IHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5zZXRVbmVkaXRhYmxlKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3LmlucHV0Lm1vdXNlRG93biA9PSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuc2V0QXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIsIFwiZmFsc2VcIik7XG4gICAgICAgICAgICAgICAgfSwgMjApO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXAgPSB0aGlzLnVwLmJpbmQodGhpcykpO1xuICAgICAgICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUgPSB0aGlzLm1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG4gICAgfVxuICAgIGRvbmUoKSB7XG4gICAgICAgIHRoaXMudmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXApO1xuICAgICAgICB0aGlzLnZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSk7XG4gICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZyAmJiB0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyKVxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5zZXRVbmVkaXRhYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRTZWxlY3Rpb25TeW5jKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0Lm1vdXNlRG93biA9IG51bGw7XG4gICAgfVxuICAgIHVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZG9uZSgpO1xuICAgICAgICBpZiAoIXRoaXMudmlldy5kb20uY29udGFpbnMoZXZlbnQudGFyZ2V0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmRvYyAhPSB0aGlzLnN0YXJ0RG9jKVxuICAgICAgICAgICAgcG9zID0gdGhpcy52aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgICAgIHRoaXMudXBkYXRlQWxsb3dEZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dEZWZhdWx0IHx8ICFwb3MpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYW5kbGVTaW5nbGVDbGljayh0aGlzLnZpZXcsIHBvcy5wb3MsIHBvcy5pbnNpZGUsIGV2ZW50LCB0aGlzLnNlbGVjdE5vZGUpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmJ1dHRvbiA9PSAwICYmXG4gICAgICAgICAgICAodGhpcy5mbHVzaGVkIHx8XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIGlnbm9yZXMgY2xpY2tzIG9uIGRyYWdnYWJsZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIChzYWZhcmkgJiYgdGhpcy5taWdodERyYWcgJiYgIXRoaXMubWlnaHREcmFnLm5vZGUuaXNBdG9tKSB8fFxuICAgICAgICAgICAgICAgIC8vIENocm9tZSB3aWxsIHNvbWV0aW1lcyB0cmVhdCBhIG5vZGUgc2VsZWN0aW9uIGFzIGFcbiAgICAgICAgICAgICAgICAvLyBjdXJzb3IsIGJ1dCBzdGlsbCByZXBvcnQgdGhhdCB0aGUgbm9kZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIC8vIHdoZW4gYXNrZWQgdGhyb3VnaCBnZXRTZWxlY3Rpb24uIFlvdSdsbCB0aGVuIGdldCBhXG4gICAgICAgICAgICAgICAgLy8gc2l0dWF0aW9uIHdoZXJlIGNsaWNraW5nIGF0IHRoZSBwb2ludCB3aGVyZSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gKGhpZGRlbikgY3Vyc29yIGlzIGRvZXNuJ3QgY2hhbmdlIHRoZSBzZWxlY3Rpb24sIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRodXMgZG9lc24ndCBnZXQgYSByZWFjdGlvbiBmcm9tIFByb3NlTWlycm9yLiBUaGlzXG4gICAgICAgICAgICAgICAgLy8gd29ya3MgYXJvdW5kIHRoYXQuXG4gICAgICAgICAgICAgICAgKGNocm9tZSAmJiAhdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlICYmXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKE1hdGguYWJzKHBvcy5wb3MgLSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20pLCBNYXRoLmFicyhwb3MucG9zIC0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi50bykpIDw9IDIpKSkge1xuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHRoaXMudmlldywgU2VsZWN0aW9uLm5lYXIodGhpcy52aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcy5wb3MpKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlQWxsb3dEZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9ucyA9PSAwKVxuICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgfVxuICAgIHVwZGF0ZUFsbG93RGVmYXVsdChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsb3dEZWZhdWx0ICYmIChNYXRoLmFicyh0aGlzLmV2ZW50LnggLSBldmVudC5jbGllbnRYKSA+IDQgfHxcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuZXZlbnQueSAtIGV2ZW50LmNsaWVudFkpID4gNCkpXG4gICAgICAgICAgICB0aGlzLmFsbG93RGVmYXVsdCA9IHRydWU7XG4gICAgfVxufVxuaGFuZGxlcnMudG91Y2hzdGFydCA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXQubGFzdFRvdWNoID0gRGF0ZS5ub3coKTtcbiAgICBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG59O1xuaGFuZGxlcnMudG91Y2htb3ZlID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dC5sYXN0VG91Y2ggPSBEYXRlLm5vdygpO1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG59O1xuaGFuZGxlcnMuY29udGV4dG1lbnUgPSB2aWV3ID0+IGZvcmNlRE9NRmx1c2godmlldyk7XG5mdW5jdGlvbiBpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBTZWUgaHR0cHM6Ly93d3cuc3R1bS5kZS8yMDE2LzA2LzI0L2hhbmRsaW5nLWltZS1ldmVudHMtaW4tamF2YXNjcmlwdC8uXG4gICAgLy8gT24gSmFwYW5lc2UgaW5wdXQgbWV0aG9kIGVkaXRvcnMgKElNRXMpLCB0aGUgRW50ZXIga2V5IGlzIHVzZWQgdG8gY29uZmlybSBjaGFyYWN0ZXJcbiAgICAvLyBzZWxlY3Rpb24uIE9uIFNhZmFyaSwgd2hlbiBFbnRlciBpcyBwcmVzc2VkLCBjb21wb3NpdGlvbmVuZCBhbmQga2V5ZG93biBldmVudHMgYXJlXG4gICAgLy8gZW1pdHRlZC4gVGhlIGtleWRvd24gZXZlbnQgdHJpZ2dlcnMgbmV3bGluZSBpbnNlcnRpb24sIHdoaWNoIHdlIGRvbid0IHdhbnQuXG4gICAgLy8gVGhpcyBtZXRob2QgcmV0dXJucyB0cnVlIGlmIHRoZSBrZXlkb3duIGV2ZW50IHNob3VsZCBiZSBpZ25vcmVkLlxuICAgIC8vIFdlIG9ubHkgaWdub3JlIGl0IG9uY2UsIGFzIHByZXNzaW5nIEVudGVyIGEgc2Vjb25kIHRpbWUgKnNob3VsZCogaW5zZXJ0IGEgbmV3bGluZS5cbiAgICAvLyBGdXJ0aGVybW9yZSwgdGhlIGtleWRvd24gZXZlbnQgdGltZXN0YW1wIG11c3QgYmUgY2xvc2UgdG8gdGhlIGNvbXBvc2l0aW9uRW5kZWRBdCB0aW1lc3RhbXAuXG4gICAgLy8gVGhpcyBndWFyZHMgYWdhaW5zdCB0aGUgY2FzZSB3aGVyZSBjb21wb3NpdGlvbmVuZCBpcyB0cmlnZ2VyZWQgd2l0aG91dCB0aGUga2V5Ym9hcmRcbiAgICAvLyAoZS5nLiBjaGFyYWN0ZXIgY29uZmlybWF0aW9uIG1heSBiZSBkb25lIHdpdGggdGhlIG1vdXNlKSwgYW5kIGtleWRvd24gaXMgdHJpZ2dlcmVkXG4gICAgLy8gYWZ0ZXJ3YXJkcy0gd2Ugd291bGRuJ3Qgd2FudCB0byBpZ25vcmUgdGhlIGtleWRvd24gZXZlbnQgaW4gdGhpcyBjYXNlLlxuICAgIGlmIChzYWZhcmkgJiYgTWF0aC5hYnMoZXZlbnQudGltZVN0YW1wIC0gdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQpIDwgNTAwKSB7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gLTJlODtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIERyb3AgYWN0aXZlIGNvbXBvc2l0aW9uIGFmdGVyIDUgc2Vjb25kcyBvZiBpbmFjdGl2aXR5IG9uIEFuZHJvaWRcbmNvbnN0IHRpbWVvdXRDb21wb3NpdGlvbiA9IGFuZHJvaWQgPyA1MDAwIDogLTE7XG5lZGl0SGFuZGxlcnMuY29tcG9zaXRpb25zdGFydCA9IGVkaXRIYW5kbGVycy5jb21wb3NpdGlvbnVwZGF0ZSA9IHZpZXcgPT4ge1xuICAgIGlmICghdmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5mbHVzaCgpO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgJHBvcyA9IHN0YXRlLnNlbGVjdGlvbi4kZnJvbTtcbiAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5lbXB0eSAmJlxuICAgICAgICAgICAgKHN0YXRlLnN0b3JlZE1hcmtzIHx8XG4gICAgICAgICAgICAgICAgKCEkcG9zLnRleHRPZmZzZXQgJiYgJHBvcy5wYXJlbnRPZmZzZXQgJiYgJHBvcy5ub2RlQmVmb3JlLm1hcmtzLnNvbWUobSA9PiBtLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlKSkpKSB7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIHdyYXAgdGhlIGN1cnNvciBpbiBtYXJrIG5vZGVzIGRpZmZlcmVudCBmcm9tIHRoZSBvbmVzIGluIHRoZSBET00gY29udGV4dFxuICAgICAgICAgICAgdmlldy5tYXJrQ3Vyc29yID0gdmlldy5zdGF0ZS5zdG9yZWRNYXJrcyB8fCAkcG9zLm1hcmtzKCk7XG4gICAgICAgICAgICBlbmRDb21wb3NpdGlvbih2aWV3LCB0cnVlKTtcbiAgICAgICAgICAgIHZpZXcubWFya0N1cnNvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmRDb21wb3NpdGlvbih2aWV3KTtcbiAgICAgICAgICAgIC8vIEluIGZpcmVmb3gsIGlmIHRoZSBjdXJzb3IgaXMgYWZ0ZXIgYnV0IG91dHNpZGUgYSBtYXJrZWQgbm9kZSxcbiAgICAgICAgICAgIC8vIHRoZSBpbnNlcnRlZCB0ZXh0IHdvbid0IGluaGVyaXQgdGhlIG1hcmtzLiBTbyB0aGlzIG1vdmVzIGl0XG4gICAgICAgICAgICAvLyBpbnNpZGUgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgaWYgKGdlY2tvICYmIHN0YXRlLnNlbGVjdGlvbi5lbXB0eSAmJiAkcG9zLnBhcmVudE9mZnNldCAmJiAhJHBvcy50ZXh0T2Zmc2V0ICYmICRwb3Mubm9kZUJlZm9yZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7IG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCAhPSAwOykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gb2Zmc2V0IDwgMCA/IG5vZGUubGFzdENoaWxkIDogbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZG9tU2VsZWN0aW9uKCkuY29sbGFwc2UoYmVmb3JlLCBiZWZvcmUubm9kZVZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZyA9IHRydWU7XG4gICAgfVxuICAgIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCB0aW1lb3V0Q29tcG9zaXRpb24pO1xufTtcbmVkaXRIYW5kbGVycy5jb21wb3NpdGlvbmVuZCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzID0gdmlldy5kb21PYnNlcnZlci5wZW5kaW5nUmVjb3JkcygpLmxlbmd0aCA/IHZpZXcuaW5wdXQuY29tcG9zaXRpb25JRCA6IDA7XG4gICAgICAgIGlmICh2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMpXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2goKSk7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25JRCsrO1xuICAgICAgICBzY2hlZHVsZUNvbXBvc2VFbmQodmlldywgMjApO1xuICAgIH1cbn07XG5mdW5jdGlvbiBzY2hlZHVsZUNvbXBvc2VFbmQodmlldywgZGVsYXkpIHtcbiAgICBjbGVhclRpbWVvdXQodmlldy5pbnB1dC5jb21wb3NpbmdUaW1lb3V0KTtcbiAgICBpZiAoZGVsYXkgPiAtMSlcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBlbmRDb21wb3NpdGlvbih2aWV3KSwgZGVsYXkpO1xufVxuZnVuY3Rpb24gY2xlYXJDb21wb3NpdGlvbih2aWV3KSB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gdGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50KCk7XG4gICAgfVxuICAgIHdoaWxlICh2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMubGVuZ3RoID4gMClcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLnBvcCgpLm1hcmtQYXJlbnRzRGlydHkoKTtcbn1cbmZ1bmN0aW9uIHRpbWVzdGFtcEZyb21DdXN0b21FdmVudCgpIHtcbiAgICBsZXQgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGV2ZW50LmluaXRFdmVudChcImV2ZW50XCIsIHRydWUsIHRydWUpO1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXA7XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIGVuZENvbXBvc2l0aW9uKHZpZXcsIGZvcmNlVXBkYXRlID0gZmFsc2UpIHtcbiAgICBpZiAoYW5kcm9pZCAmJiB2aWV3LmRvbU9ic2VydmVyLmZsdXNoaW5nU29vbiA+PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgdmlldy5kb21PYnNlcnZlci5mb3JjZUZsdXNoKCk7XG4gICAgY2xlYXJDb21wb3NpdGlvbih2aWV3KTtcbiAgICBpZiAoZm9yY2VVcGRhdGUgfHwgdmlldy5kb2NWaWV3ICYmIHZpZXcuZG9jVmlldy5kaXJ0eSkge1xuICAgICAgICBsZXQgc2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3KTtcbiAgICAgICAgaWYgKHNlbCAmJiAhc2VsLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjYXB0dXJlQ29weSh2aWV3LCBkb20pIHtcbiAgICAvLyBUaGUgZXh0cmEgd3JhcHBlciBpcyBzb21laG93IG5lY2Vzc2FyeSBvbiBJRS9FZGdlIHRvIHByZXZlbnQgdGhlXG4gICAgLy8gY29udGVudCBmcm9tIGJlaW5nIG1hbmdsZWQgd2hlbiBpdCBpcyBwdXQgb250byB0aGUgY2xpcGJvYXJkXG4gICAgaWYgKCF2aWV3LmRvbS5wYXJlbnROb2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHdyYXAgPSB2aWV3LmRvbS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgIHdyYXAuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICB3cmFwLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIGxldCBzZWwgPSBnZXRTZWxlY3Rpb24oKSwgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhkb20pO1xuICAgIC8vIERvbmUgYmVjYXVzZSBJRSB3aWxsIGZpcmUgYSBzZWxlY3Rpb25jaGFuZ2UgbW92aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAvLyB0byBpdHMgc3RhcnQgd2hlbiByZW1vdmVBbGxSYW5nZXMgaXMgY2FsbGVkIGFuZCB0aGUgZWRpdG9yIHN0aWxsXG4gICAgLy8gaGFzIGZvY3VzICh3aGljaCB3aWxsIG1lc3MgdXAgdGhlIGVkaXRvcidzIHNlbGVjdGlvbiBzdGF0ZSkuXG4gICAgdmlldy5kb20uYmx1cigpO1xuICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAod3JhcC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgd3JhcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHdyYXApO1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgfSwgNTApO1xufVxuLy8gVGhpcyBpcyB2ZXJ5IGNydWRlLCBidXQgdW5mb3J0dW5hdGVseSBib3RoIHRoZXNlIGJyb3dzZXJzIF9wcmV0ZW5kX1xuLy8gdGhhdCB0aGV5IGhhdmUgYSBjbGlwYm9hcmQgQVBJ4oCUYWxsIHRoZSBvYmplY3RzIGFuZCBtZXRob2RzIGFyZVxuLy8gdGhlcmUsIHRoZXkganVzdCBkb24ndCB3b3JrLCBhbmQgdGhleSBhcmUgaGFyZCB0byB0ZXN0LlxuY29uc3QgYnJva2VuQ2xpcGJvYXJkQVBJID0gKGllICYmIGllX3ZlcnNpb24gPCAxNSkgfHxcbiAgICAoaW9zICYmIHdlYmtpdF92ZXJzaW9uIDwgNjA0KTtcbmhhbmRsZXJzLmNvcHkgPSBlZGl0SGFuZGxlcnMuY3V0ID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24sIGN1dCA9IGV2ZW50LnR5cGUgPT0gXCJjdXRcIjtcbiAgICBpZiAoc2VsLmVtcHR5KVxuICAgICAgICByZXR1cm47XG4gICAgLy8gSUUgYW5kIEVkZ2UncyBjbGlwYm9hcmQgaW50ZXJmYWNlIGlzIGNvbXBsZXRlbHkgYnJva2VuXG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBsZXQgc2xpY2UgPSBzZWwuY29udGVudCgpLCB7IGRvbSwgdGV4dCB9ID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIHNsaWNlKTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkYXRhLmNsZWFyRGF0YSgpO1xuICAgICAgICBkYXRhLnNldERhdGEoXCJ0ZXh0L2h0bWxcIiwgZG9tLmlubmVySFRNTCk7XG4gICAgICAgIGRhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgdGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYXB0dXJlQ29weSh2aWV3LCBkb20pO1xuICAgIH1cbiAgICBpZiAoY3V0KVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuZGVsZXRlU2VsZWN0aW9uKCkuc2Nyb2xsSW50b1ZpZXcoKS5zZXRNZXRhKFwidWlFdmVudFwiLCBcImN1dFwiKSk7XG59O1xuZnVuY3Rpb24gc2xpY2VTaW5nbGVOb2RlKHNsaWNlKSB7XG4gICAgcmV0dXJuIHNsaWNlLm9wZW5TdGFydCA9PSAwICYmIHNsaWNlLm9wZW5FbmQgPT0gMCAmJiBzbGljZS5jb250ZW50LmNoaWxkQ291bnQgPT0gMSA/IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCA6IG51bGw7XG59XG5mdW5jdGlvbiBjYXB0dXJlUGFzdGUodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIXZpZXcuZG9tLnBhcmVudE5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgcGxhaW5UZXh0ID0gdmlldy5pbnB1dC5zaGlmdEtleSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGU7XG4gICAgbGV0IHRhcmdldCA9IHZpZXcuZG9tLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChwbGFpblRleHQgPyBcInRleHRhcmVhXCIgOiBcImRpdlwiKSk7XG4gICAgaWYgKCFwbGFpblRleHQpXG4gICAgICAgIHRhcmdldC5jb250ZW50RWRpdGFibGUgPSBcInRydWVcIjtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgbGV0IHBsYWluID0gdmlldy5pbnB1dC5zaGlmdEtleSAmJiB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlICE9IDQ1O1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIGlmICh0YXJnZXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIHRhcmdldC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgICAgIGlmIChwbGFpblRleHQpXG4gICAgICAgICAgICBkb1Bhc3RlKHZpZXcsIHRhcmdldC52YWx1ZSwgbnVsbCwgcGxhaW4sIGV2ZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudGV4dENvbnRlbnQsIHRhcmdldC5pbm5lckhUTUwsIHBsYWluLCBldmVudCk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gZG9QYXN0ZSh2aWV3LCB0ZXh0LCBodG1sLCBwcmVmZXJQbGFpbiwgZXZlbnQpIHtcbiAgICBsZXQgc2xpY2UgPSBwYXJzZUZyb21DbGlwYm9hcmQodmlldywgdGV4dCwgaHRtbCwgcHJlZmVyUGxhaW4sIHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRmcm9tKTtcbiAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZVBhc3RlXCIsIGYgPT4gZih2aWV3LCBldmVudCwgc2xpY2UgfHwgU2xpY2UuZW1wdHkpKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFzbGljZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzaW5nbGVOb2RlID0gc2xpY2VTaW5nbGVOb2RlKHNsaWNlKTtcbiAgICBsZXQgdHIgPSBzaW5nbGVOb2RlXG4gICAgICAgID8gdmlldy5zdGF0ZS50ci5yZXBsYWNlU2VsZWN0aW9uV2l0aChzaW5nbGVOb2RlLCBwcmVmZXJQbGFpbilcbiAgICAgICAgOiB2aWV3LnN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb24oc2xpY2UpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKS5zZXRNZXRhKFwicGFzdGVcIiwgdHJ1ZSkuc2V0TWV0YShcInVpRXZlbnRcIiwgXCJwYXN0ZVwiKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRUZXh0KGNsaXBib2FyZERhdGEpIHtcbiAgICBsZXQgdGV4dCA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIikgfHwgY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiVGV4dFwiKTtcbiAgICBpZiAodGV4dClcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgbGV0IHVyaXMgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0L3VyaS1saXN0XCIpO1xuICAgIHJldHVybiB1cmlzID8gdXJpcy5yZXBsYWNlKC9cXHI/XFxuL2csIFwiIFwiKSA6IFwiXCI7XG59XG5lZGl0SGFuZGxlcnMucGFzdGUgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIC8vIEhhbmRsaW5nIHBhc3RlIGZyb20gSmF2YVNjcmlwdCBkdXJpbmcgY29tcG9zaXRpb24gaXMgdmVyeSBwb29ybHlcbiAgICAvLyBoYW5kbGVkIGJ5IGJyb3dzZXJzLCBzbyBhcyBhIGRvZGd5IGJ1dCBwcmVmZXJhYmxlIGtsdWRnZSwgd2UganVzdFxuICAgIC8vIGxldCB0aGUgYnJvd3NlciBkbyBpdHMgbmF0aXZlIHRoaW5nIHRoZXJlLCBleGNlcHQgb24gQW5kcm9pZCxcbiAgICAvLyB3aGVyZSB0aGUgZWRpdG9yIGlzIGFsbW9zdCBhbHdheXMgY29tcG9zaW5nLlxuICAgIGlmICh2aWV3LmNvbXBvc2luZyAmJiAhYW5kcm9pZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgbGV0IHBsYWluID0gdmlldy5pbnB1dC5zaGlmdEtleSAmJiB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlICE9IDQ1O1xuICAgIGlmIChkYXRhICYmIGRvUGFzdGUodmlldywgZ2V0VGV4dChkYXRhKSwgZGF0YS5nZXREYXRhKFwidGV4dC9odG1sXCIpLCBwbGFpbiwgZXZlbnQpKVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGVsc2VcbiAgICAgICAgY2FwdHVyZVBhc3RlKHZpZXcsIGV2ZW50KTtcbn07XG5jbGFzcyBEcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3Ioc2xpY2UsIG1vdmUsIG5vZGUpIHtcbiAgICAgICAgdGhpcy5zbGljZSA9IHNsaWNlO1xuICAgICAgICB0aGlzLm1vdmUgPSBtb3ZlO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cbn1cbmNvbnN0IGRyYWdDb3B5TW9kaWZpZXIgPSBtYWMgPyBcImFsdEtleVwiIDogXCJjdHJsS2V5XCI7XG5oYW5kbGVycy5kcmFnc3RhcnQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBtb3VzZURvd24gPSB2aWV3LmlucHV0Lm1vdXNlRG93bjtcbiAgICBpZiAobW91c2VEb3duKVxuICAgICAgICBtb3VzZURvd24uZG9uZSgpO1xuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBwb3MgPSBzZWwuZW1wdHkgPyBudWxsIDogdmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgIGxldCBub2RlO1xuICAgIGlmIChwb3MgJiYgcG9zLnBvcyA+PSBzZWwuZnJvbSAmJiBwb3MucG9zIDw9IChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uID8gc2VsLnRvIC0gMSA6IHNlbC50bykpIDtcbiAgICBlbHNlIGlmIChtb3VzZURvd24gJiYgbW91c2VEb3duLm1pZ2h0RHJhZykge1xuICAgICAgICBub2RlID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIG1vdXNlRG93bi5taWdodERyYWcucG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGV2ZW50LnRhcmdldCwgdHJ1ZSk7XG4gICAgICAgIGlmIChkZXNjICYmIGRlc2Mubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlICYmIGRlc2MgIT0gdmlldy5kb2NWaWV3KVxuICAgICAgICAgICAgbm9kZSA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBkZXNjLnBvc0JlZm9yZSk7XG4gICAgfVxuICAgIGxldCBzbGljZSA9IChub2RlIHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uKS5jb250ZW50KCksIHsgZG9tLCB0ZXh0IH0gPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpO1xuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5jbGVhckRhdGEoKTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShicm9rZW5DbGlwYm9hcmRBUEkgPyBcIlRleHRcIiA6IFwidGV4dC9odG1sXCIsIGRvbS5pbm5lckhUTUwpO1xuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3IvaXNzdWVzLzExNTZcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcbiAgICBpZiAoIWJyb2tlbkNsaXBib2FyZEFQSSlcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgIHZpZXcuZHJhZ2dpbmcgPSBuZXcgRHJhZ2dpbmcoc2xpY2UsICFldmVudFtkcmFnQ29weU1vZGlmaWVyXSwgbm9kZSk7XG59O1xuaGFuZGxlcnMuZHJhZ2VuZCA9IHZpZXcgPT4ge1xuICAgIGxldCBkcmFnZ2luZyA9IHZpZXcuZHJhZ2dpbmc7XG4gICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodmlldy5kcmFnZ2luZyA9PSBkcmFnZ2luZylcbiAgICAgICAgICAgIHZpZXcuZHJhZ2dpbmcgPSBudWxsO1xuICAgIH0sIDUwKTtcbn07XG5lZGl0SGFuZGxlcnMuZHJhZ292ZXIgPSBlZGl0SGFuZGxlcnMuZHJhZ2VudGVyID0gKF8sIGUpID0+IGUucHJldmVudERlZmF1bHQoKTtcbmVkaXRIYW5kbGVycy5kcm9wID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBsZXQgZHJhZ2dpbmcgPSB2aWV3LmRyYWdnaW5nO1xuICAgIHZpZXcuZHJhZ2dpbmcgPSBudWxsO1xuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGV2ZW50UG9zID0gdmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgIGlmICghZXZlbnRQb3MpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgJG1vdXNlID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShldmVudFBvcy5wb3MpO1xuICAgIGxldCBzbGljZSA9IGRyYWdnaW5nICYmIGRyYWdnaW5nLnNsaWNlO1xuICAgIGlmIChzbGljZSkge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkXCIsIGYgPT4geyBzbGljZSA9IGYoc2xpY2UsIHZpZXcpOyB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNsaWNlID0gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIGdldFRleHQoZXZlbnQuZGF0YVRyYW5zZmVyKSwgYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dC9odG1sXCIpLCBmYWxzZSwgJG1vdXNlKTtcbiAgICB9XG4gICAgbGV0IG1vdmUgPSAhIShkcmFnZ2luZyAmJiAhZXZlbnRbZHJhZ0NvcHlNb2RpZmllcl0pO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRHJvcFwiLCBmID0+IGYodmlldywgZXZlbnQsIHNsaWNlIHx8IFNsaWNlLmVtcHR5LCBtb3ZlKSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNsaWNlKVxuICAgICAgICByZXR1cm47XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgaW5zZXJ0UG9zID0gc2xpY2UgPyBkcm9wUG9pbnQodmlldy5zdGF0ZS5kb2MsICRtb3VzZS5wb3MsIHNsaWNlKSA6ICRtb3VzZS5wb3M7XG4gICAgaWYgKGluc2VydFBvcyA9PSBudWxsKVxuICAgICAgICBpbnNlcnRQb3MgPSAkbW91c2UucG9zO1xuICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgaWYgKG1vdmUpIHtcbiAgICAgICAgbGV0IHsgbm9kZSB9ID0gZHJhZ2dpbmc7XG4gICAgICAgIGlmIChub2RlKVxuICAgICAgICAgICAgbm9kZS5yZXBsYWNlKHRyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGxldCBwb3MgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgIGxldCBpc05vZGUgPSBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDE7XG4gICAgbGV0IGJlZm9yZUluc2VydCA9IHRyLmRvYztcbiAgICBpZiAoaXNOb2RlKVxuICAgICAgICB0ci5yZXBsYWNlUmFuZ2VXaXRoKHBvcywgcG9zLCBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIGVsc2VcbiAgICAgICAgdHIucmVwbGFjZVJhbmdlKHBvcywgcG9zLCBzbGljZSk7XG4gICAgaWYgKHRyLmRvYy5lcShiZWZvcmVJbnNlcnQpKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0ICRwb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmIChpc05vZGUgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoc2xpY2UuY29udGVudC5maXJzdENoaWxkKSAmJlxuICAgICAgICAkcG9zLm5vZGVBZnRlciAmJiAkcG9zLm5vZGVBZnRlci5zYW1lTWFya3VwKHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBlbmQgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgICAgICB0ci5tYXBwaW5nLm1hcHNbdHIubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4gZW5kID0gbmV3VG8pO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkcG9zLCB0ci5kb2MucmVzb2x2ZShlbmQpKSk7XG4gICAgfVxuICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiZHJvcFwiKSk7XG59O1xuaGFuZGxlcnMuZm9jdXMgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IERhdGUubm93KCk7XG4gICAgaWYgKCF2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuZG9jVmlldyAmJiB2aWV3Lmhhc0ZvY3VzKCkgJiYgIXZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5lcSh2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCkpKVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgICAgICB9LCAyMCk7XG4gICAgfVxufTtcbmhhbmRsZXJzLmJsdXIgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGlmICh2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ICYmIHZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5oYW5kbGVycy5iZWZvcmVpbnB1dCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IGRvIG1vcmUgd2l0aCBiZWZvcmVpbnB1dCBldmVudHMsIGJ1dCBzdXBwb3J0XG4gICAgLy8gaXMgc28gc3BvdHR5IHRoYXQgSSdtIHN0aWxsIHdhaXRpbmcgdG8gc2VlIHdoZXJlIHRoZXkgYXJlIGdvaW5nLlxuICAgIC8vIFZlcnkgc3BlY2lmaWMgaGFjayB0byBkZWFsIHdpdGggYmFja3NwYWNlIHNvbWV0aW1lcyBmYWlsaW5nIG9uXG4gICAgLy8gQ2hyb21lIEFuZHJvaWQgd2hlbiBhZnRlciBhbiB1bmVkaXRhYmxlIG5vZGUuXG4gICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmIGV2ZW50LmlucHV0VHlwZSA9PSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgICAgIGxldCB7IGRvbUNoYW5nZUNvdW50IH0gPSB2aWV3LmlucHV0O1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0LmRvbUNoYW5nZUNvdW50ICE9IGRvbUNoYW5nZUNvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gRXZlbnQgYWxyZWFkeSBoYWQgc29tZSBlZmZlY3RcbiAgICAgICAgICAgIC8vIFRoaXMgYnVnIHRlbmRzIHRvIGNsb3NlIHRoZSB2aXJ0dWFsIGtleWJvYXJkLCBzbyB3ZSByZWZvY3VzXG4gICAgICAgICAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAvLyBDcnVkZSBhcHByb3hpbWF0aW9uIG9mIGJhY2tzcGFjZSBiZWhhdmlvciB3aGVuIG5vIGNvbW1hbmQgaGFuZGxlZCBpdFxuICAgICAgICAgICAgaWYgKCRjdXJzb3IgJiYgJGN1cnNvci5wb3MgPiAwKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGUoJGN1cnNvci5wb3MgLSAxLCAkY3Vyc29yLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG59O1xuLy8gTWFrZSBzdXJlIGFsbCBoYW5kbGVycyBnZXQgcmVnaXN0ZXJlZFxuZm9yIChsZXQgcHJvcCBpbiBlZGl0SGFuZGxlcnMpXG4gICAgaGFuZGxlcnNbcHJvcF0gPSBlZGl0SGFuZGxlcnNbcHJvcF07XG5cbmZ1bmN0aW9uIGNvbXBhcmVPYmpzKGEsIGIpIHtcbiAgICBpZiAoYSA9PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKGxldCBwIGluIGEpXG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IHAgaW4gYilcbiAgICAgICAgaWYgKCEocCBpbiBhKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRvRE9NLCBzcGVjKSB7XG4gICAgICAgIHRoaXMudG9ET00gPSB0b0RPTTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgICAgIHRoaXMuc2lkZSA9IHRoaXMuc3BlYy5zaWRlIHx8IDA7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgeyBwb3MsIGRlbGV0ZWQgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zaWRlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBkZWxldGVkID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKHBvcyAtIG9mZnNldCwgcG9zIC0gb2Zmc2V0LCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIFdpZGdldFR5cGUgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5zcGVjLmtleSAmJiB0aGlzLnNwZWMua2V5ID09IG90aGVyLnNwZWMua2V5IHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9ET00gPT0gb3RoZXIudG9ET00gJiYgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSkpO1xuICAgIH1cbiAgICBkZXN0cm95KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5zcGVjLmRlc3Ryb3kobm9kZSk7XG4gICAgfVxufVxuY2xhc3MgSW5saW5lVHlwZSB7XG4gICAgY29uc3RydWN0b3IoYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlU3RhcnQgPyAtMSA6IDEpIC0gb2Zmc2V0O1xuICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcChzcGFuLnRvICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlRW5kID8gMSA6IC0xKSAtIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGZyb20gPj0gdG8gPyBudWxsIDogbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChfLCBzcGFuKSB7IHJldHVybiBzcGFuLmZyb20gPCBzcGFuLnRvOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIElubGluZVR5cGUgJiYgY29tcGFyZU9ianModGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpcyhzcGFuKSB7IHJldHVybiBzcGFuLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuY2xhc3MgTm9kZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRvID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi50byArIG9sZE9mZnNldCwgLTEpO1xuICAgICAgICBpZiAodG8uZGVsZXRlZCB8fCB0by5wb3MgPD0gZnJvbS5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20ucG9zIC0gb2Zmc2V0LCB0by5wb3MgLSBvZmZzZXQsIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChub2RlLCBzcGFuKSB7XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoc3Bhbi5mcm9tKSwgY2hpbGQ7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPT0gc3Bhbi5mcm9tICYmICEoY2hpbGQgPSBub2RlLmNoaWxkKGluZGV4KSkuaXNUZXh0ICYmIG9mZnNldCArIGNoaWxkLm5vZGVTaXplID09IHNwYW4udG87XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBOb2RlVHlwZSAmJiBjb21wYXJlT2Jqcyh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuLyoqXG5EZWNvcmF0aW9uIG9iamVjdHMgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSB2aWV3IHRocm91Z2ggdGhlXG5bYGRlY29yYXRpb25zYCBwcm9wXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5kZWNvcmF0aW9ucykuIFRoZXkgY29tZSBpblxuc2V2ZXJhbCB2YXJpYW50c+KAlHNlZSB0aGUgc3RhdGljIG1lbWJlcnMgb2YgdGhpcyBjbGFzcyBmb3IgZGV0YWlscy5cbiovXG5jbGFzcyBEZWNvcmF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24uIFdpbGwgYmUgdGhlIHNhbWUgYXMgYGZyb21gIGZvciBbd2lkZ2V0XG4gICAgZGVjb3JhdGlvbnNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ed2lkZ2V0KS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHR5cGUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvcHkoZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVxKG90aGVyLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuZXEob3RoZXIudHlwZSkgJiYgdGhpcy5mcm9tICsgb2Zmc2V0ID09IG90aGVyLmZyb20gJiYgdGhpcy50byArIG9mZnNldCA9PSBvdGhlci50bztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5tYXAobWFwcGluZywgdGhpcywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGlzIGEgRE9NIG5vZGUgdGhhdCdzIHNob3duIGluXG4gICAgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3VcbiAgICBkZWxheSByZW5kZXJpbmcgdGhlIHdpZGdldCBieSBwYXNzaW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gICAgY2FsbGVkIHdoZW4gdGhlIHdpZGdldCBpcyBhY3R1YWxseSBkcmF3biBpbiBhIHZpZXcsIGJ1dCB5b3UgY2FuXG4gICAgYWxzbyBkaXJlY3RseSBwYXNzIGEgRE9NIG5vZGUuIGBnZXRQb3NgIGNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlXG4gICAgd2lkZ2V0J3MgY3VycmVudCBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyB3aWRnZXQocG9zLCB0b0RPTSwgc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24ocG9zLCBwb3MsIG5ldyBXaWRnZXRUeXBlKHRvRE9NLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZXMgYW4gaW5saW5lIGRlY29yYXRpb24sIHdoaWNoIGFkZHMgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgdG9cbiAgICBlYWNoIGlubGluZSBub2RlIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLlxuICAgICovXG4gICAgc3RhdGljIGlubGluZShmcm9tLCB0bywgYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCBuZXcgSW5saW5lVHlwZShhdHRycywgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgbm9kZSBkZWNvcmF0aW9uLiBgZnJvbWAgYW5kIGB0b2Agc2hvdWxkIHBvaW50IHByZWNpc2VseVxuICAgIGJlZm9yZSBhbmQgYWZ0ZXIgYSBub2RlIGluIHRoZSBkb2N1bWVudC4gVGhhdCBub2RlLCBhbmQgb25seSB0aGF0XG4gICAgbm9kZSwgd2lsbCByZWNlaXZlIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgc3RhdGljIG5vZGUoZnJvbSwgdG8sIGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IE5vZGVUeXBlKGF0dHJzLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzcGVjIHByb3ZpZGVkIHdoZW4gY3JlYXRpbmcgdGhpcyBkZWNvcmF0aW9uLiBDYW4gYmUgdXNlZnVsXG4gICAgaWYgeW91J3ZlIHN0b3JlZCBleHRyYSBpbmZvcm1hdGlvbiBpbiB0aGF0IG9iamVjdC5cbiAgICAqL1xuICAgIGdldCBzcGVjKCkgeyByZXR1cm4gdGhpcy50eXBlLnNwZWM7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpbmxpbmUoKSB7IHJldHVybiB0aGlzLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgd2lkZ2V0KCkgeyByZXR1cm4gdGhpcy50eXBlIGluc3RhbmNlb2YgV2lkZ2V0VHlwZTsgfVxufVxuY29uc3Qgbm9uZSA9IFtdLCBub1NwZWMgPSB7fTtcbi8qKlxuQSBjb2xsZWN0aW9uIG9mIFtkZWNvcmF0aW9uc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbiksIG9yZ2FuaXplZCBpbiBzdWNoXG5hIHdheSB0aGF0IHRoZSBkcmF3aW5nIGFsZ29yaXRobSBjYW4gZWZmaWNpZW50bHkgdXNlIGFuZCBjb21wYXJlXG50aGVtLiBUaGlzIGlzIGEgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZeKAlGl0IGlzIG5vdCBtb2RpZmllZCxcbnVwZGF0ZXMgY3JlYXRlIGEgbmV3IHZhbHVlLlxuKi9cbmNsYXNzIERlY29yYXRpb25TZXQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYWwsIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbC5sZW5ndGggPyBsb2NhbCA6IG5vbmU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlbiA6IG5vbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBkZWNvcmF0aW9ucywgdXNpbmcgdGhlIHN0cnVjdHVyZSBvZiB0aGUgZ2l2ZW5cbiAgICBkb2N1bWVudC4gVGhpcyB3aWxsIGNvbnN1bWUgKG1vZGlmeSkgdGhlIGBkZWNvcmF0aW9uc2AgYXJyYXksIHNvXG4gICAgeW91IG11c3QgbWFrZSBhIGNvcHkgaWYgeW91IHdhbnQgbmVlZCB0byBwcmVzZXJ2ZSB0aGF0LlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGRlY29yYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBkZWNvcmF0aW9ucy5sZW5ndGggPyBidWlsZFRyZWUoZGVjb3JhdGlvbnMsIGRvYywgMCwgbm9TcGVjKSA6IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGFsbCBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCB3aGljaCB0b3VjaCB0aGUgZ2l2ZW4gcmFuZ2VcbiAgICAoaW5jbHVkaW5nIGRlY29yYXRpb25zIHRoYXQgc3RhcnQgb3IgZW5kIGRpcmVjdGx5IGF0IHRoZVxuICAgIGJvdW5kYXJpZXMpIGFuZCBtYXRjaCB0aGUgZ2l2ZW4gcHJlZGljYXRlIG9uIHRoZWlyIHNwZWMuIFdoZW5cbiAgICBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgb21pdHRlZCwgYWxsIGRlY29yYXRpb25zIGluIHRoZSBzZXQgYXJlXG4gICAgY29uc2lkZXJlZC4gV2hlbiBgcHJlZGljYXRlYCBpc24ndCBnaXZlbiwgYWxsIGRlY29yYXRpb25zIGFyZVxuICAgIGFzc3VtZWQgdG8gbWF0Y2guXG4gICAgKi9cbiAgICBmaW5kKHN0YXJ0LCBlbmQsIHByZWRpY2F0ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZmluZElubmVyKHN0YXJ0ID09IG51bGwgPyAwIDogc3RhcnQsIGVuZCA9PSBudWxsID8gMWU5IDogZW5kLCByZXN1bHQsIDAsIHByZWRpY2F0ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZpbmRJbm5lcihzdGFydCwgZW5kLCByZXN1bHQsIG9mZnNldCwgcHJlZGljYXRlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSB0aGlzLmxvY2FsW2ldO1xuICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA8PSBlbmQgJiYgc3Bhbi50byA+PSBzdGFydCAmJiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoc3Bhbi5zcGVjKSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Bhbi5jb3B5KHNwYW4uZnJvbSArIG9mZnNldCwgc3Bhbi50byArIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPCBlbmQgJiYgdGhpcy5jaGlsZHJlbltpICsgMV0gPiBzdGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZE9mZiA9IHRoaXMuY2hpbGRyZW5baV0gKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baSArIDJdLmZpbmRJbm5lcihzdGFydCAtIGNoaWxkT2ZmLCBlbmQgLSBjaGlsZE9mZiwgcmVzdWx0LCBvZmZzZXQgKyBjaGlsZE9mZiwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhlIHNldCBvZiBkZWNvcmF0aW9ucyBpbiByZXNwb25zZSB0byBhIGNoYW5nZSBpbiB0aGVcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nLCBkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkgfHwgbWFwcGluZy5tYXBzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcElubmVyKG1hcHBpbmcsIGRvYywgMCwgMCwgb3B0aW9ucyB8fCBub1NwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hcElubmVyKG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBuZXdMb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gdGhpcy5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZCAmJiBtYXBwZWQudHlwZS52YWxpZChub2RlLCBtYXBwZWQpKVxuICAgICAgICAgICAgICAgIChuZXdMb2NhbCB8fCAobmV3TG9jYWwgPSBbXSkpLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZSh0aGlzLmxvY2FsW2ldLnNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBtYXBDaGlsZHJlbih0aGlzLmNoaWxkcmVuLCBuZXdMb2NhbCB8fCBbXSwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3TG9jYWwgPyBuZXcgRGVjb3JhdGlvblNldChuZXdMb2NhbC5zb3J0KGJ5UG9zKSwgbm9uZSkgOiBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIHRoZSBnaXZlbiBhcnJheSBvZiBkZWNvcmF0aW9ucyB0byB0aGUgb25lcyBpbiB0aGUgc2V0LFxuICAgIHByb2R1Y2luZyBhIG5ldyBzZXQuIENvbnN1bWVzIHRoZSBgZGVjb3JhdGlvbnNgIGFycmF5LiBOZWVkc1xuICAgIGFjY2VzcyB0byB0aGUgY3VycmVudCBkb2N1bWVudCB0byBjcmVhdGUgdGhlIGFwcHJvcHJpYXRlIHRyZWVcbiAgICBzdHJ1Y3R1cmUuXG4gICAgKi9cbiAgICBhZGQoZG9jLCBkZWNvcmF0aW9ucykge1xuICAgICAgICBpZiAoIWRlY29yYXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkSW5uZXIoZG9jLCBkZWNvcmF0aW9ucywgMCk7XG4gICAgfVxuICAgIGFkZElubmVyKGRvYywgZGVjb3JhdGlvbnMsIG9mZnNldCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4sIGNoaWxkSW5kZXggPSAwO1xuICAgICAgICBkb2MuZm9yRWFjaCgoY2hpbGROb2RlLCBjaGlsZE9mZnNldCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJhc2VPZmZzZXQgPSBjaGlsZE9mZnNldCArIG9mZnNldCwgZm91bmQ7XG4gICAgICAgICAgICBpZiAoIShmb3VuZCA9IHRha2VTcGFuc0Zvck5vZGUoZGVjb3JhdGlvbnMsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRJbmRleCA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltjaGlsZEluZGV4XSA8IGNoaWxkT2Zmc2V0KVxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXggKz0gMztcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltjaGlsZEluZGV4XSA9PSBjaGlsZE9mZnNldClcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0gPSBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0uYWRkSW5uZXIoY2hpbGROb2RlLCBmb3VuZCwgYmFzZU9mZnNldCArIDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAwLCBjaGlsZE9mZnNldCwgY2hpbGRPZmZzZXQgKyBjaGlsZE5vZGUubm9kZVNpemUsIGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBiYXNlT2Zmc2V0ICsgMSwgbm9TcGVjKSk7XG4gICAgICAgICAgICBjaGlsZEluZGV4ICs9IDM7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbG9jYWwgPSBtb3ZlU3BhbnMoY2hpbGRJbmRleCA/IHdpdGhvdXROdWxscyhkZWNvcmF0aW9ucykgOiBkZWNvcmF0aW9ucywgLW9mZnNldCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWxvY2FsW2ldLnR5cGUudmFsaWQoZG9jLCBsb2NhbFtpXSkpXG4gICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvblNldChsb2NhbC5sZW5ndGggPyB0aGlzLmxvY2FsLmNvbmNhdChsb2NhbCkuc29ydChieVBvcykgOiB0aGlzLmxvY2FsLCBjaGlsZHJlbiB8fCB0aGlzLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHNldCB0aGF0IGNvbnRhaW5zIHRoZSBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCwgbWludXNcbiAgICB0aGUgb25lcyBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gICAgKi9cbiAgICByZW1vdmUoZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgaWYgKGRlY29yYXRpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSW5uZXIoZGVjb3JhdGlvbnMsIDApO1xuICAgIH1cbiAgICByZW1vdmVJbm5lcihkZWNvcmF0aW9ucywgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4sIGxvY2FsID0gdGhpcy5sb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IGZvdW5kO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBjaGlsZHJlbltpXSArIG9mZnNldCwgdG8gPSBjaGlsZHJlbltpICsgMV0gKyBvZmZzZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgc3BhbjsgaiA8IGRlY29yYXRpb25zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmIChzcGFuID0gZGVjb3JhdGlvbnNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA+IGZyb20gJiYgc3Bhbi50byA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0aW9uc1tqXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiA9PSB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgbGV0IHJlbW92ZWQgPSBjaGlsZHJlbltpICsgMl0ucmVtb3ZlSW5uZXIoZm91bmQsIGZyb20gKyAxKTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkICE9IGVtcHR5KSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDJdID0gcmVtb3ZlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAzKTtcbiAgICAgICAgICAgICAgICBpIC09IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzcGFuOyBpIDwgZGVjb3JhdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHNwYW4gPSBkZWNvcmF0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvY2FsLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsW2pdLmVxKHNwYW4sIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWwgPT0gdGhpcy5sb2NhbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzLmxvY2FsLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4gPT0gdGhpcy5jaGlsZHJlbiAmJiBsb2NhbCA9PSB0aGlzLmxvY2FsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBsb2NhbC5sZW5ndGggfHwgY2hpbGRyZW4ubGVuZ3RoID8gbmV3IERlY29yYXRpb25TZXQobG9jYWwsIGNoaWxkcmVuKSA6IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvckNoaWxkKG9mZnNldCwgbm9kZSkge1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5lbXB0eTtcbiAgICAgICAgbGV0IGNoaWxkLCBsb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPj0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baSArIDJdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBvZmZzZXQgKyAxLCBlbmQgPSBzdGFydCArIG5vZGUuY29udGVudC5zaXplO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBkZWMgPSB0aGlzLmxvY2FsW2ldO1xuICAgICAgICAgICAgaWYgKGRlYy5mcm9tIDwgZW5kICYmIGRlYy50byA+IHN0YXJ0ICYmIChkZWMudHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChzdGFydCwgZGVjLmZyb20pIC0gc3RhcnQsIHRvID0gTWF0aC5taW4oZW5kLCBkZWMudG8pIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bylcbiAgICAgICAgICAgICAgICAgICAgKGxvY2FsIHx8IChsb2NhbCA9IFtdKSkucHVzaChkZWMuY29weShmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgbGV0IGxvY2FsU2V0ID0gbmV3IERlY29yYXRpb25TZXQobG9jYWwuc29ydChieVBvcyksIG5vbmUpO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkID8gbmV3IERlY29yYXRpb25Hcm91cChbbG9jYWxTZXQsIGNoaWxkXSkgOiBsb2NhbFNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gb3RoZXIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0KSB8fFxuICAgICAgICAgICAgdGhpcy5sb2NhbC5sZW5ndGggIT0gb3RoZXIubG9jYWwubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPSBvdGhlci5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5sb2NhbFtpXS5lcShvdGhlci5sb2NhbFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSAhPSBvdGhlci5jaGlsZHJlbltpXSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baSArIDFdICE9IG90aGVyLmNoaWxkcmVuW2kgKyAxXSB8fFxuICAgICAgICAgICAgICAgICF0aGlzLmNoaWxkcmVuW2kgKyAyXS5lcShvdGhlci5jaGlsZHJlbltpICsgMl0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9jYWxzKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZU92ZXJsYXAodGhpcy5sb2NhbHNJbm5lcihub2RlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9jYWxzSW5uZXIobm9kZSkge1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBub25lO1xuICAgICAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50IHx8ICF0aGlzLmxvY2FsLnNvbWUoSW5saW5lVHlwZS5pcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMubG9jYWxbaV0udHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubG9jYWxbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIGRlY29yYXRpb25zLlxuKi9cbkRlY29yYXRpb25TZXQuZW1wdHkgPSBuZXcgRGVjb3JhdGlvblNldChbXSwgW10pO1xuLyoqXG5AaW50ZXJuYWxcbiovXG5EZWNvcmF0aW9uU2V0LnJlbW92ZU92ZXJsYXAgPSByZW1vdmVPdmVybGFwO1xuY29uc3QgZW1wdHkgPSBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuLy8gQW4gYWJzdHJhY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGNvZGUgZGVhbGluZyB3aXRoIGRlY29yYXRpb25zIHRvXG4vLyB0cmVhdCBtdWx0aXBsZSBEZWNvcmF0aW9uU2V0IG9iamVjdHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZSBvYmplY3Rcbi8vIHdpdGggKGEgc3Vic2V0IG9mKSB0aGUgc2FtZSBpbnRlcmZhY2UuXG5jbGFzcyBEZWNvcmF0aW9uR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKG1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIGRvYykge1xuICAgICAgICBjb25zdCBtYXBwZWREZWNvcyA9IHRoaXMubWVtYmVycy5tYXAobWVtYmVyID0+IG1lbWJlci5tYXAobWFwcGluZywgZG9jLCBub1NwZWMpKTtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKG1hcHBlZERlY29zKTtcbiAgICB9XG4gICAgZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuZW1wdHk7XG4gICAgICAgIGxldCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubWVtYmVyc1tpXS5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gZW1wdHkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRGVjb3JhdGlvbkdyb3VwKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gZm91bmQuY29uY2F0KHJlc3VsdC5tZW1iZXJzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uR3JvdXApIHx8XG4gICAgICAgICAgICBvdGhlci5tZW1iZXJzLmxlbmd0aCAhPSB0aGlzLm1lbWJlcnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5tZW1iZXJzW2ldLmVxKG90aGVyLm1lbWJlcnNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxvY2Fscyhub2RlKSB7XG4gICAgICAgIGxldCByZXN1bHQsIHNvcnRlZCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxzID0gdGhpcy5tZW1iZXJzW2ldLmxvY2Fsc0lubmVyKG5vZGUpO1xuICAgICAgICAgICAgaWYgKCFsb2NhbHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsb2NhbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb2NhbHMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxvY2Fsc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlbW92ZU92ZXJsYXAoc29ydGVkID8gcmVzdWx0IDogcmVzdWx0LnNvcnQoYnlQb3MpKSA6IG5vbmU7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIGdyb3VwIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbiBzZXRzLCBvciByZXR1cm5cbiAgICAvLyBhIHNpbmdsZSBzZXQgd2hlbiBwb3NzaWJsZS5cbiAgICBzdGF0aWMgZnJvbShtZW1iZXJzKSB7XG4gICAgICAgIHN3aXRjaCAobWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIGVtcHR5O1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbWVtYmVyc1swXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBuZXcgRGVjb3JhdGlvbkdyb3VwKG1lbWJlcnMuZXZlcnkobSA9PiBtIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCkgPyBtZW1iZXJzIDpcbiAgICAgICAgICAgICAgICBtZW1iZXJzLnJlZHVjZSgociwgbSkgPT4gci5jb25jYXQobSBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQgPyBtIDogbS5tZW1iZXJzKSwgW10pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKG9sZENoaWxkcmVuLCBuZXdMb2NhbCwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBvbGRDaGlsZHJlbi5zbGljZSgpO1xuICAgIC8vIE1hcmsgdGhlIGNoaWxkcmVuIHRoYXQgYXJlIGRpcmVjdGx5IHRvdWNoZWQgYnkgY2hhbmdlcywgYW5kXG4gICAgLy8gbW92ZSB0aG9zZSB0aGF0IGFyZSBhZnRlciB0aGUgY2hhbmdlcy5cbiAgICBmb3IgKGxldCBpID0gMCwgYmFzZU9mZnNldCA9IG9sZE9mZnNldDsgaSA8IG1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbW92ZWQgPSAwO1xuICAgICAgICBtYXBwaW5nLm1hcHNbaV0uZm9yRWFjaCgob2xkU3RhcnQsIG9sZEVuZCwgbmV3U3RhcnQsIG5ld0VuZCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRTaXplID0gKG5ld0VuZCAtIG5ld1N0YXJ0KSAtIChvbGRFbmQgLSBvbGRTdGFydCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGNoaWxkcmVuW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kIDwgMCB8fCBvbGRTdGFydCA+IGVuZCArIGJhc2VPZmZzZXQgLSBtb3ZlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY2hpbGRyZW5baV0gKyBiYXNlT2Zmc2V0IC0gbW92ZWQ7XG4gICAgICAgICAgICAgICAgaWYgKG9sZEVuZCA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSBvbGRTdGFydCA8PSBzdGFydCA/IC0yIDogLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9sZFN0YXJ0ID49IGJhc2VPZmZzZXQgJiYgZFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0gKz0gZFNpemU7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSArPSBkU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb3ZlZCArPSBkU2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJhc2VPZmZzZXQgPSBtYXBwaW5nLm1hcHNbaV0ubWFwKGJhc2VPZmZzZXQsIC0xKTtcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgY2hpbGQgbm9kZXMgdGhhdCBzdGlsbCBjb3JyZXNwb25kIHRvIGEgc2luZ2xlIG5vZGUsXG4gICAgLy8gcmVjdXJzaXZlbHkgY2FsbCBtYXBJbm5lciBvbiB0aGVtIGFuZCB1cGRhdGUgdGhlaXIgcG9zaXRpb25zLlxuICAgIGxldCBtdXN0UmVidWlsZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPCAwKSB7IC8vIFRvdWNoZWQgbm9kZXNcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPT0gLTIpIHtcbiAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gLTE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwKG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0KSwgZnJvbUxvY2FsID0gZnJvbSAtIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChmcm9tTG9jYWwgPCAwIHx8IGZyb21Mb2NhbCA+PSBub2RlLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE11c3QgcmVhZCBvbGRDaGlsZHJlbiBiZWNhdXNlIGNoaWxkcmVuIHdhcyB0YWdnZWQgd2l0aCAtMVxuICAgICAgICAgICAgbGV0IHRvID0gbWFwcGluZy5tYXAob2xkQ2hpbGRyZW5baSArIDFdICsgb2xkT2Zmc2V0LCAtMSksIHRvTG9jYWwgPSB0byAtIG9mZnNldDtcbiAgICAgICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQ6IGNoaWxkT2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KGZyb21Mb2NhbCk7XG4gICAgICAgICAgICBsZXQgY2hpbGROb2RlID0gbm9kZS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGRPZmZzZXQgPT0gZnJvbUxvY2FsICYmIGNoaWxkT2Zmc2V0ICsgY2hpbGROb2RlLm5vZGVTaXplID09IHRvTG9jYWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFwcGVkID0gY2hpbGRyZW5baSArIDJdXG4gICAgICAgICAgICAgICAgICAgIC5tYXBJbm5lcihtYXBwaW5nLCBjaGlsZE5vZGUsIGZyb20gKyAxLCBvbGRDaGlsZHJlbltpXSArIG9sZE9mZnNldCArIDEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWQgIT0gZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0gPSBmcm9tTG9jYWw7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IHRvTG9jYWw7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAyXSA9IG1hcHBlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IC0yO1xuICAgICAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgLy8gUmVtYWluaW5nIGNoaWxkcmVuIG11c3QgYmUgY29sbGVjdGVkIGFuZCByZWJ1aWx0IGludG8gdGhlIGFwcHJvcHJpYXRlIHN0cnVjdHVyZVxuICAgIGlmIChtdXN0UmVidWlsZCkge1xuICAgICAgICBsZXQgZGVjb3JhdGlvbnMgPSBtYXBBbmRHYXRoZXJSZW1haW5pbmdEZWNvcmF0aW9ucyhjaGlsZHJlbiwgb2xkQ2hpbGRyZW4sIG5ld0xvY2FsLCBtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucyk7XG4gICAgICAgIGxldCBidWlsdCA9IGJ1aWxkVHJlZShkZWNvcmF0aW9ucywgbm9kZSwgMCwgb3B0aW9ucyk7XG4gICAgICAgIG5ld0xvY2FsID0gYnVpbHQubG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdIDwgMCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAzKTtcbiAgICAgICAgICAgICAgICBpIC09IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGJ1aWx0LmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGJ1aWx0LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBjaGlsZHJlbi5sZW5ndGggJiYgY2hpbGRyZW5bal0gPCBmcm9tKVxuICAgICAgICAgICAgICAgIGogKz0gMztcbiAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShqLCAwLCBidWlsdC5jaGlsZHJlbltpXSwgYnVpbHQuY2hpbGRyZW5baSArIDFdLCBidWlsdC5jaGlsZHJlbltpICsgMl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGVjb3JhdGlvblNldChuZXdMb2NhbC5zb3J0KGJ5UG9zKSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gbW92ZVNwYW5zKHNwYW5zLCBvZmZzZXQpIHtcbiAgICBpZiAoIW9mZnNldCB8fCAhc3BhbnMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gc3BhbnM7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IERlY29yYXRpb24oc3Bhbi5mcm9tICsgb2Zmc2V0LCBzcGFuLnRvICsgb2Zmc2V0LCBzcGFuLnR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zKGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgZGVjb3JhdGlvbnMsIG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgLy8gR2F0aGVyIGFsbCBkZWNvcmF0aW9ucyBmcm9tIHRoZSByZW1haW5pbmcgbWFya2VkIGNoaWxkcmVuXG4gICAgZnVuY3Rpb24gZ2F0aGVyKHNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0LmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gc2V0LmxvY2FsW2ldLm1hcChtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCk7XG4gICAgICAgICAgICBpZiAobWFwcGVkKVxuICAgICAgICAgICAgICAgIGRlY29yYXRpb25zLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZShzZXQubG9jYWxbaV0uc3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBnYXRoZXIoc2V0LmNoaWxkcmVuW2kgKyAyXSwgc2V0LmNoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPT0gLTEpXG4gICAgICAgICAgICBnYXRoZXIoY2hpbGRyZW5baSArIDJdLCBvbGRDaGlsZHJlbltpXSArIG9sZE9mZnNldCArIDEpO1xuICAgIHJldHVybiBkZWNvcmF0aW9ucztcbn1cbmZ1bmN0aW9uIHRha2VTcGFuc0Zvck5vZGUoc3BhbnMsIG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGVuZCA9IG9mZnNldCArIG5vZGUubm9kZVNpemUsIGZvdW5kID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMCwgc3BhbjsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoc3BhbiA9IHNwYW5zW2ldKSAmJiBzcGFuLmZyb20gPiBvZmZzZXQgJiYgc3Bhbi50byA8IGVuZCkge1xuICAgICAgICAgICAgKGZvdW5kIHx8IChmb3VuZCA9IFtdKSkucHVzaChzcGFuKTtcbiAgICAgICAgICAgIHNwYW5zW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiB3aXRob3V0TnVsbHMoYXJyYXkpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGFycmF5W2ldICE9IG51bGwpXG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEJ1aWxkIHVwIGEgdHJlZSB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgc2V0IG9mIGRlY29yYXRpb25zLiBgb2Zmc2V0YFxuLy8gaXMgYSBiYXNlIG9mZnNldCB0aGF0IHNob3VsZCBiZSBzdWJ0cmFjdGVkIGZyb20gdGhlIGBmcm9tYCBhbmQgYHRvYFxuLy8gcG9zaXRpb25zIGluIHRoZSBzcGFucyAoc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGFsbG9jYXRlIG5ldyBzcGFuc1xuLy8gZm9yIHJlY3Vyc2l2ZSBjYWxscykuXG5mdW5jdGlvbiBidWlsZFRyZWUoc3BhbnMsIG5vZGUsIG9mZnNldCwgb3B0aW9ucykge1xuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBoYXNOdWxscyA9IGZhbHNlO1xuICAgIG5vZGUuZm9yRWFjaCgoY2hpbGROb2RlLCBsb2NhbFN0YXJ0KSA9PiB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRha2VTcGFuc0Zvck5vZGUoc3BhbnMsIGNoaWxkTm9kZSwgbG9jYWxTdGFydCArIG9mZnNldCk7XG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgaGFzTnVsbHMgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHN1YnRyZWUgPSBidWlsZFRyZWUoZm91bmQsIGNoaWxkTm9kZSwgb2Zmc2V0ICsgbG9jYWxTdGFydCArIDEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHN1YnRyZWUgIT0gZW1wdHkpXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChsb2NhbFN0YXJ0LCBsb2NhbFN0YXJ0ICsgY2hpbGROb2RlLm5vZGVTaXplLCBzdWJ0cmVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBsb2NhbHMgPSBtb3ZlU3BhbnMoaGFzTnVsbHMgPyB3aXRob3V0TnVsbHMoc3BhbnMpIDogc3BhbnMsIC1vZmZzZXQpLnNvcnQoYnlQb3MpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWxvY2Fsc1tpXS50eXBlLnZhbGlkKG5vZGUsIGxvY2Fsc1tpXSkpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uUmVtb3ZlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZW1vdmUobG9jYWxzW2ldLnNwZWMpO1xuICAgICAgICAgICAgbG9jYWxzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGxvY2Fscy5sZW5ndGggfHwgY2hpbGRyZW4ubGVuZ3RoID8gbmV3IERlY29yYXRpb25TZXQobG9jYWxzLCBjaGlsZHJlbikgOiBlbXB0eTtcbn1cbi8vIFVzZWQgdG8gc29ydCBkZWNvcmF0aW9ucyBzbyB0aGF0IG9uZXMgd2l0aCBhIGxvdyBzdGFydCBwb3NpdGlvblxuLy8gY29tZSBmaXJzdCwgYW5kIHdpdGhpbiBhIHNldCB3aXRoIHRoZSBzYW1lIHN0YXJ0IHBvc2l0aW9uLCB0aG9zZVxuLy8gd2l0aCBhbiBzbWFsbGVyIGVuZCBwb3NpdGlvbiBjb21lIGZpcnN0LlxuZnVuY3Rpb24gYnlQb3MoYSwgYikge1xuICAgIHJldHVybiBhLmZyb20gLSBiLmZyb20gfHwgYS50byAtIGIudG87XG59XG4vLyBTY2FuIGEgc29ydGVkIGFycmF5IG9mIGRlY29yYXRpb25zIGZvciBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgc3BhbnMsXG4vLyBhbmQgc3BsaXQgdGhvc2Ugc28gdGhhdCBvbmx5IGZ1bGx5IG92ZXJsYXBwaW5nIHNwYW5zIGFyZSBsZWZ0ICh0b1xuLy8gbWFrZSBzdWJzZXF1ZW50IHJlbmRlcmluZyBlYXNpZXIpLiBXaWxsIHJldHVybiB0aGUgaW5wdXQgYXJyYXkgaWZcbi8vIG5vIHBhcnRpYWxseSBvdmVybGFwcGluZyBzcGFucyBhcmUgZm91bmQgKHRoZSBjb21tb24gY2FzZSkuXG5mdW5jdGlvbiByZW1vdmVPdmVybGFwKHNwYW5zKSB7XG4gICAgbGV0IHdvcmtpbmcgPSBzcGFucztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmtpbmcubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGxldCBzcGFuID0gd29ya2luZ1tpXTtcbiAgICAgICAgaWYgKHNwYW4uZnJvbSAhPSBzcGFuLnRvKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgd29ya2luZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gd29ya2luZ1tqXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5mcm9tID09IHNwYW4uZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC50byAhPSBzcGFuLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya2luZyA9PSBzcGFucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gc3BhbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvbGxvd2VkIGJ5IGEgcGFydGlhbGx5IG92ZXJsYXBwaW5nIGxhcmdlciBzcGFuLiBTcGxpdCB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGFuLlxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1tqXSA9IG5leHQuY29weShuZXh0LmZyb20sIHNwYW4udG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QWhlYWQod29ya2luZywgaiArIDEsIG5leHQuY29weShzcGFuLnRvLCBuZXh0LnRvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5mcm9tIDwgc3Bhbi50bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcgPT0gc3BhbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IHNwYW5zLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZW5kIG9mIHRoaXMgb25lIG92ZXJsYXBzIHdpdGggYSBzdWJzZXF1ZW50IHNwYW4uIFNwbGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdbaV0gPSBzcGFuLmNvcHkoc3Bhbi5mcm9tLCBuZXh0LmZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QWhlYWQod29ya2luZywgaiwgc3Bhbi5jb3B5KG5leHQuZnJvbSwgc3Bhbi50bykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdvcmtpbmc7XG59XG5mdW5jdGlvbiBpbnNlcnRBaGVhZChhcnJheSwgaSwgZGVjbykge1xuICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoICYmIGJ5UG9zKGRlY28sIGFycmF5W2ldKSA+IDApXG4gICAgICAgIGkrKztcbiAgICBhcnJheS5zcGxpY2UoaSwgMCwgZGVjbyk7XG59XG4vLyBHZXQgdGhlIGRlY29yYXRpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBwcm9wcyBvZiBhIHZpZXcuXG5mdW5jdGlvbiB2aWV3RGVjb3JhdGlvbnModmlldykge1xuICAgIGxldCBmb3VuZCA9IFtdO1xuICAgIHZpZXcuc29tZVByb3AoXCJkZWNvcmF0aW9uc1wiLCBmID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGYodmlldy5zdGF0ZSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0ICE9IGVtcHR5KVxuICAgICAgICAgICAgZm91bmQucHVzaChyZXN1bHQpO1xuICAgIH0pO1xuICAgIGlmICh2aWV3LmN1cnNvcldyYXBwZXIpXG4gICAgICAgIGZvdW5kLnB1c2goRGVjb3JhdGlvblNldC5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIFt2aWV3LmN1cnNvcldyYXBwZXIuZGVjb10pKTtcbiAgICByZXR1cm4gRGVjb3JhdGlvbkdyb3VwLmZyb20oZm91bmQpO1xufVxuXG5jb25zdCBvYnNlcnZlT3B0aW9ucyA9IHtcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWUsXG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcbiAgICBzdWJ0cmVlOiB0cnVlXG59O1xuLy8gSUUxMSBoYXMgdmVyeSBicm9rZW4gbXV0YXRpb24gb2JzZXJ2ZXJzLCBzbyB3ZSBhbHNvIGxpc3RlbiB0byBET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcbmNvbnN0IHVzZUNoYXJEYXRhID0gaWUgJiYgaWVfdmVyc2lvbiA8PSAxMTtcbmNsYXNzIFNlbGVjdGlvblN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBzZXQoc2VsKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IHNlbC5hbmNob3JOb2RlO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IHNlbC5hbmNob3JPZmZzZXQ7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICB9XG4gICAgZXEoc2VsKSB7XG4gICAgICAgIHJldHVybiBzZWwuYW5jaG9yTm9kZSA9PSB0aGlzLmFuY2hvck5vZGUgJiYgc2VsLmFuY2hvck9mZnNldCA9PSB0aGlzLmFuY2hvck9mZnNldCAmJlxuICAgICAgICAgICAgc2VsLmZvY3VzTm9kZSA9PSB0aGlzLmZvY3VzTm9kZSAmJiBzZWwuZm9jdXNPZmZzZXQgPT0gdGhpcy5mb2N1c09mZnNldDtcbiAgICB9XG59XG5jbGFzcyBET01PYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IodmlldywgaGFuZGxlRE9NQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuaGFuZGxlRE9NQ2hhbmdlID0gaGFuZGxlRE9NQ2hhbmdlO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZmx1c2hpbmdTb29uID0gLTE7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIHRoaXMub25DaGFyRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciAmJlxuICAgICAgICAgICAgbmV3IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXRhdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgIC8vIElFMTEgd2lsbCBzb21ldGltZXMgKG9uIGJhY2tzcGFjaW5nIG91dCBhIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAvLyB0ZXh0IG5vZGUgYWZ0ZXIgYSBCUiBub2RlKSBjYWxsIHRoZSBvYnNlcnZlciBjYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIGJlZm9yZSBhY3R1YWxseSB1cGRhdGluZyB0aGUgRE9NLCB3aGljaCB3aWxsIGNhdXNlXG4gICAgICAgICAgICAgICAgLy8gUHJvc2VNaXJyb3IgdG8gbWlzcyB0aGUgY2hhbmdlIChzZWUgIzkzMClcbiAgICAgICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBtdXRhdGlvbnMuc29tZShtID0+IG0udHlwZSA9PSBcImNoaWxkTGlzdFwiICYmIG0ucmVtb3ZlZE5vZGVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICBtLnR5cGUgPT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbS5vbGRWYWx1ZS5sZW5ndGggPiBtLnRhcmdldC5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFyRGF0YSA9IGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh7IHRhcmdldDogZS50YXJnZXQsIHR5cGU6IFwiY2hhcmFjdGVyRGF0YVwiLCBvbGRWYWx1ZTogZS5wcmV2VmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgZmx1c2hTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5mbHVzaGluZ1Nvb24gPCAwKVxuICAgICAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuZmx1c2hpbmdTb29uID0gLTE7IHRoaXMuZmx1c2goKTsgfSwgMjApO1xuICAgIH1cbiAgICBmb3JjZUZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5mbHVzaGluZ1Nvb24gPiAtMSkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmZsdXNoaW5nU29vbik7XG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IC0xO1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHRoaXMudmlldy5kb20sIG9ic2VydmVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbkNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgICAgIHRoaXMuY29ubmVjdFNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcikge1xuICAgICAgICAgICAgbGV0IHRha2UgPSB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICAgICAgICBpZiAodGFrZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2UubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh0YWtlW2ldKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLmZsdXNoKCksIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGNvbm5lY3RTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20ub3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0U2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCkge1xuICAgICAgICB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSBmYWxzZSwgNTApO1xuICAgIH1cbiAgICBvblNlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgaWYgKCFoYXNGb2N1c0FuZFNlbGVjdGlvbih0aGlzLnZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMpXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uVG9ET00odGhpcy52aWV3KTtcbiAgICAgICAgLy8gRGVsZXRpb25zIG9uIElFMTEgZmlyZSB0aGVpciBldmVudHMgaW4gdGhlIHdyb25nIG9yZGVyLCBnaXZpbmdcbiAgICAgICAgLy8gdXMgYSBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50IGJlZm9yZSB0aGUgRE9NIGNoYW5nZXMgYXJlXG4gICAgICAgIC8vIHJlcG9ydGVkLlxuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiAhdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHNlbCA9IHRoaXMudmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgLy8gU2VsZWN0aW9uLmlzQ29sbGFwc2VkIGlzbid0IHJlbGlhYmxlIG9uIElFXG4gICAgICAgICAgICBpZiAoc2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICAgIHNldEN1clNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uLnNldCh0aGlzLnZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSk7XG4gICAgfVxuICAgIGlnbm9yZVNlbGVjdGlvbkNoYW5nZShzZWwpIHtcbiAgICAgICAgaWYgKCFzZWwuZm9jdXNOb2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBhbmNlc3RvcnMgPSBuZXcgU2V0LCBjb250YWluZXI7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBzZWwuZm9jdXNOb2RlOyBzY2FuOyBzY2FuID0gcGFyZW50Tm9kZShzY2FuKSlcbiAgICAgICAgICAgIGFuY2VzdG9ycy5hZGQoc2Nhbik7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBzZWwuYW5jaG9yTm9kZTsgc2Nhbjsgc2NhbiA9IHBhcmVudE5vZGUoc2NhbikpXG4gICAgICAgICAgICBpZiAoYW5jZXN0b3JzLmhhcyhzY2FuKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHNjYW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBkZXNjID0gY29udGFpbmVyICYmIHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGNvbnRhaW5lcik7XG4gICAgICAgIGlmIChkZXNjICYmIGRlc2MuaWdub3JlTXV0YXRpb24oe1xuICAgICAgICAgICAgdHlwZTogXCJzZWxlY3Rpb25cIixcbiAgICAgICAgICAgIHRhcmdldDogY29udGFpbmVyLm5vZGVUeXBlID09IDMgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lclxuICAgICAgICB9KSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBlbmRpbmdSZWNvcmRzKCkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcilcbiAgICAgICAgICAgIGZvciAobGV0IG11dCBvZiB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlO1xuICAgIH1cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCF2aWV3LmRvY1ZpZXcgfHwgdGhpcy5mbHVzaGluZ1Nvb24gPiAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG11dGF0aW9ucyA9IHRoaXMucGVuZGluZ1JlY29yZHMoKTtcbiAgICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBuZXdTZWwgPSAhdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgJiYgIXRoaXMuY3VycmVudFNlbGVjdGlvbi5lcShzZWwpICYmIGhhc0ZvY3VzQW5kU2VsZWN0aW9uKHZpZXcpICYmICF0aGlzLmlnbm9yZVNlbGVjdGlvbkNoYW5nZShzZWwpO1xuICAgICAgICBsZXQgZnJvbSA9IC0xLCB0byA9IC0xLCB0eXBlT3ZlciA9IGZhbHNlLCBhZGRlZCA9IFtdO1xuICAgICAgICBpZiAodmlldy5lZGl0YWJsZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5yZWdpc3Rlck11dGF0aW9uKG11dGF0aW9uc1tpXSwgYWRkZWQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IGZyb20gPCAwID8gcmVzdWx0LmZyb20gOiBNYXRoLm1pbihyZXN1bHQuZnJvbSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gdG8gPCAwID8gcmVzdWx0LnRvIDogTWF0aC5tYXgocmVzdWx0LnRvLCB0byk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZU92ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlT3ZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChnZWNrbyAmJiBhZGRlZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsZXQgYnJzID0gYWRkZWQuZmlsdGVyKG4gPT4gbi5ub2RlTmFtZSA9PSBcIkJSXCIpO1xuICAgICAgICAgICAgaWYgKGJycy5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgIGxldCBhID0gYnJzWzBdLCBiID0gYnJzWzFdO1xuICAgICAgICAgICAgICAgIGlmIChhLnBhcmVudE5vZGUgJiYgYS5wYXJlbnROb2RlLnBhcmVudE5vZGUgPT0gYi5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBiLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVhZFNlbCA9IG51bGw7XG4gICAgICAgIC8vIElmIGl0IGxvb2tzIGxpa2UgdGhlIGJyb3dzZXIgaGFzIHJlc2V0IHRoZSBzZWxlY3Rpb24gdG8gdGhlXG4gICAgICAgIC8vIHN0YXJ0IG9mIHRoZSBkb2N1bWVudCBhZnRlciBmb2N1cywgcmVzdG9yZSB0aGUgc2VsZWN0aW9uIGZyb21cbiAgICAgICAgLy8gdGhlIHN0YXRlXG4gICAgICAgIGlmIChmcm9tIDwgMCAmJiBuZXdTZWwgJiYgdmlldy5pbnB1dC5sYXN0Rm9jdXMgPiBEYXRlLm5vdygpIC0gMjAwICYmXG4gICAgICAgICAgICBNYXRoLm1heCh2aWV3LmlucHV0Lmxhc3RUb3VjaCwgdmlldy5pbnB1dC5sYXN0Q2xpY2sudGltZSkgPCBEYXRlLm5vdygpIC0gMzAwICYmXG4gICAgICAgICAgICBzZWxlY3Rpb25Db2xsYXBzZWQoc2VsKSAmJiAocmVhZFNlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldykpICYmXG4gICAgICAgICAgICByZWFkU2VsLmVxKFNlbGVjdGlvbi5uZWFyKHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoMCksIDEpKSkge1xuICAgICAgICAgICAgdmlldy5pbnB1dC5sYXN0Rm9jdXMgPSAwO1xuICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHNlbCk7XG4gICAgICAgICAgICB2aWV3LnNjcm9sbFRvU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZnJvbSA+IC0xIHx8IG5ld1NlbCkge1xuICAgICAgICAgICAgaWYgKGZyb20gPiAtMSkge1xuICAgICAgICAgICAgICAgIHZpZXcuZG9jVmlldy5tYXJrRGlydHkoZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgIGNoZWNrQ1NTKHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYW5kbGVET01DaGFuZ2UoZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZCk7XG4gICAgICAgICAgICBpZiAodmlldy5kb2NWaWV3ICYmIHZpZXcuZG9jVmlldy5kaXJ0eSlcbiAgICAgICAgICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY3VycmVudFNlbGVjdGlvbi5lcShzZWwpKVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uLnNldChzZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyTXV0YXRpb24obXV0LCBhZGRlZCkge1xuICAgICAgICAvLyBJZ25vcmUgbXV0YXRpb25zIGluc2lkZSBub2RlcyB0aGF0IHdlcmUgYWxyZWFkeSBub3RlZCBhcyBpbnNlcnRlZFxuICAgICAgICBpZiAoYWRkZWQuaW5kZXhPZihtdXQudGFyZ2V0KSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBkZXNjID0gdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MobXV0LnRhcmdldCk7XG4gICAgICAgIGlmIChtdXQudHlwZSA9PSBcImF0dHJpYnV0ZXNcIiAmJlxuICAgICAgICAgICAgKGRlc2MgPT0gdGhpcy52aWV3LmRvY1ZpZXcgfHwgbXV0LmF0dHJpYnV0ZU5hbWUgPT0gXCJjb250ZW50ZWRpdGFibGVcIiB8fFxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggc29tZXRpbWVzIGZpcmVzIHNwdXJpb3VzIGV2ZW50cyBmb3IgbnVsbC9lbXB0eSBzdHlsZXNcbiAgICAgICAgICAgICAgICAobXV0LmF0dHJpYnV0ZU5hbWUgPT0gXCJzdHlsZVwiICYmICFtdXQub2xkVmFsdWUgJiYgIW11dC50YXJnZXQuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikpKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIWRlc2MgfHwgZGVzYy5pZ25vcmVNdXRhdGlvbihtdXQpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChtdXQudHlwZSA9PSBcImNoaWxkTGlzdFwiKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dC5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGFkZGVkLnB1c2gobXV0LmFkZGVkTm9kZXNbaV0pO1xuICAgICAgICAgICAgaWYgKGRlc2MuY29udGVudERPTSAmJiBkZXNjLmNvbnRlbnRET00gIT0gZGVzYy5kb20gJiYgIWRlc2MuY29udGVudERPTS5jb250YWlucyhtdXQudGFyZ2V0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyBmcm9tOiBkZXNjLnBvc0JlZm9yZSwgdG86IGRlc2MucG9zQWZ0ZXIgfTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbXV0LnByZXZpb3VzU2libGluZywgbmV4dCA9IG11dC5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIG11dC5hZGRlZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIElFMTEgZ2l2ZXMgdXMgaW5jb3JyZWN0IG5leHQvcHJldiBzaWJsaW5ncyBmb3Igc29tZVxuICAgICAgICAgICAgICAgIC8vIGluc2VydGlvbnMsIHNvIGlmIHRoZXJlIGFyZSBhZGRlZCBub2RlcywgcmVjb21wdXRlIHRob3NlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXQuYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBwcmV2aW91c1NpYmxpbmcsIG5leHRTaWJsaW5nIH0gPSBtdXQuYWRkZWROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91c1NpYmxpbmcgfHwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChtdXQuYWRkZWROb2RlcywgcHJldmlvdXNTaWJsaW5nKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gcHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHRTaWJsaW5nIHx8IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobXV0LmFkZGVkTm9kZXMsIG5leHRTaWJsaW5nKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZyb21PZmZzZXQgPSBwcmV2ICYmIHByZXYucGFyZW50Tm9kZSA9PSBtdXQudGFyZ2V0XG4gICAgICAgICAgICAgICAgPyBkb21JbmRleChwcmV2KSArIDEgOiAwO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBkZXNjLmxvY2FsUG9zRnJvbURPTShtdXQudGFyZ2V0LCBmcm9tT2Zmc2V0LCAtMSk7XG4gICAgICAgICAgICBsZXQgdG9PZmZzZXQgPSBuZXh0ICYmIG5leHQucGFyZW50Tm9kZSA9PSBtdXQudGFyZ2V0XG4gICAgICAgICAgICAgICAgPyBkb21JbmRleChuZXh0KSA6IG11dC50YXJnZXQuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgdG8gPSBkZXNjLmxvY2FsUG9zRnJvbURPTShtdXQudGFyZ2V0LCB0b09mZnNldCwgMSk7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tLCB0byB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG11dC50eXBlID09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBkZXNjLnBvc0F0U3RhcnQgLSBkZXNjLmJvcmRlciwgdG86IGRlc2MucG9zQXRFbmQgKyBkZXNjLmJvcmRlciB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBcImNoYXJhY3RlckRhdGFcIlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBkZXNjLnBvc0F0U3RhcnQsXG4gICAgICAgICAgICAgICAgdG86IGRlc2MucG9zQXRFbmQsXG4gICAgICAgICAgICAgICAgLy8gQW4gZXZlbnQgd2FzIGdlbmVyYXRlZCBmb3IgYSB0ZXh0IGNoYW5nZSB0aGF0IGRpZG4ndCBjaGFuZ2VcbiAgICAgICAgICAgICAgICAvLyBhbnkgdGV4dC4gTWFyayB0aGUgZG9tIGNoYW5nZSB0byBmYWxsIGJhY2sgdG8gYXNzdW1pbmcgdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0aW9uIHdhcyB0eXBlZCBvdmVyIHdpdGggYW4gaWRlbnRpY2FsIHZhbHVlIGlmIGl0IGNhbid0XG4gICAgICAgICAgICAgICAgLy8gZmluZCBhbm90aGVyIGNoYW5nZS5cbiAgICAgICAgICAgICAgICB0eXBlT3ZlcjogbXV0LnRhcmdldC5ub2RlVmFsdWUgPT0gbXV0Lm9sZFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxubGV0IGNzc0NoZWNrZWQgPSBuZXcgV2Vha01hcCgpO1xubGV0IGNzc0NoZWNrV2FybmVkID0gZmFsc2U7XG5mdW5jdGlvbiBjaGVja0NTUyh2aWV3KSB7XG4gICAgaWYgKGNzc0NoZWNrZWQuaGFzKHZpZXcpKVxuICAgICAgICByZXR1cm47XG4gICAgY3NzQ2hlY2tlZC5zZXQodmlldywgbnVsbCk7XG4gICAgaWYgKFsnbm9ybWFsJywgJ25vd3JhcCcsICdwcmUtbGluZSddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZSh2aWV3LmRvbSkud2hpdGVTcGFjZSkgIT09IC0xKSB7XG4gICAgICAgIHZpZXcucmVxdWlyZXNHZWNrb0hhY2tOb2RlID0gZ2Vja287XG4gICAgICAgIGlmIChjc3NDaGVja1dhcm5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZVtcIndhcm5cIl0oXCJQcm9zZU1pcnJvciBleHBlY3RzIHRoZSBDU1Mgd2hpdGUtc3BhY2UgcHJvcGVydHkgdG8gYmUgc2V0LCBwcmVmZXJhYmx5IHRvICdwcmUtd3JhcCcuIEl0IGlzIHJlY29tbWVuZGVkIHRvIGxvYWQgc3R5bGUvcHJvc2VtaXJyb3IuY3NzIGZyb20gdGhlIHByb3NlbWlycm9yLXZpZXcgcGFja2FnZS5cIik7XG4gICAgICAgIGNzc0NoZWNrV2FybmVkID0gdHJ1ZTtcbiAgICB9XG59XG4vLyBVc2VkIHRvIHdvcmsgYXJvdW5kIGEgU2FmYXJpIFNlbGVjdGlvbi9zaGFkb3cgRE9NIGJ1Z1xuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy80MTQgZml4XG5mdW5jdGlvbiBzYWZhcmlTaGFkb3dTZWxlY3Rpb25SYW5nZSh2aWV3KSB7XG4gICAgbGV0IGZvdW5kO1xuICAgIGZ1bmN0aW9uIHJlYWQoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGZvdW5kID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKClbMF07XG4gICAgfVxuICAgIC8vIEJlY2F1c2UgU2FmYXJpIChhdCBsZWFzdCBpbiAyMDE4LTIwMjIpIGRvZXNuJ3QgcHJvdmlkZSByZWd1bGFyXG4gICAgLy8gYWNjZXNzIHRvIHRoZSBzZWxlY3Rpb24gaW5zaWRlIGEgc2hhZG93Um9vdCwgd2UgaGF2ZSB0byBwZXJmb3JtIGFcbiAgICAvLyByaWRpY3Vsb3VzIGhhY2sgdG8gZ2V0IGF0IGl04oCUdXNpbmcgYGV4ZWNDb21tYW5kYCB0byB0cmlnZ2VyIGFcbiAgICAvLyBgYmVmb3JlSW5wdXRgIGV2ZW50IHNvIHRoYXQgd2UgY2FuIHJlYWQgdGhlIHRhcmdldCByYW5nZSBmcm9tIHRoZVxuICAgIC8vIGV2ZW50LlxuICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZChcImluZGVudFwiKTtcbiAgICB2aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgbGV0IGFuY2hvck5vZGUgPSBmb3VuZC5zdGFydENvbnRhaW5lciwgYW5jaG9yT2Zmc2V0ID0gZm91bmQuc3RhcnRPZmZzZXQ7XG4gICAgbGV0IGZvY3VzTm9kZSA9IGZvdW5kLmVuZENvbnRhaW5lciwgZm9jdXNPZmZzZXQgPSBmb3VuZC5lbmRPZmZzZXQ7XG4gICAgbGV0IGN1cnJlbnRBbmNob3IgPSB2aWV3LmRvbUF0UG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvcik7XG4gICAgLy8gU2luY2Ugc3VjaCBhIHJhbmdlIGRvZXNuJ3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbmNob3IgYW5kIGhlYWQsXG4gICAgLy8gdXNlIGEgaGV1cmlzdGljIHRoYXQgZmxpcHMgaXQgYXJvdW5kIGlmIGl0cyBlbmQgbWF0Y2hlcyB0aGVcbiAgICAvLyBjdXJyZW50IGFuY2hvci5cbiAgICBpZiAoaXNFcXVpdmFsZW50UG9zaXRpb24oY3VycmVudEFuY2hvci5ub2RlLCBjdXJyZW50QW5jaG9yLm9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpXG4gICAgICAgIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXRdID0gW2ZvY3VzTm9kZSwgZm9jdXNPZmZzZXQsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldF07XG4gICAgcmV0dXJuIHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH07XG59XG5cbi8vIE5vdGUgdGhhdCBhbGwgcmVmZXJlbmNpbmcgYW5kIHBhcnNpbmcgaXMgZG9uZSB3aXRoIHRoZVxuLy8gc3RhcnQtb2Ytb3BlcmF0aW9uIHNlbGVjdGlvbiBhbmQgZG9jdW1lbnQsIHNpbmNlIHRoYXQncyB0aGUgb25lXG4vLyB0aGF0IHRoZSBET00gcmVwcmVzZW50cy4gSWYgYW55IGNoYW5nZXMgY2FtZSBpbiBpbiB0aGUgbWVhbnRpbWUsXG4vLyB0aGUgbW9kaWZpY2F0aW9uIGlzIG1hcHBlZCBvdmVyIHRob3NlIGJlZm9yZSBpdCBpcyBhcHBsaWVkLCBpblxuLy8gcmVhZERPTUNoYW5nZS5cbmZ1bmN0aW9uIHBhcnNlQmV0d2Vlbih2aWV3LCBmcm9tXywgdG9fKSB7XG4gICAgbGV0IHsgbm9kZTogcGFyZW50LCBmcm9tT2Zmc2V0LCB0b09mZnNldCwgZnJvbSwgdG8gfSA9IHZpZXcuZG9jVmlldy5wYXJzZVJhbmdlKGZyb21fLCB0b18pO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IGZpbmQ7XG4gICAgbGV0IGFuY2hvciA9IGRvbVNlbC5hbmNob3JOb2RlO1xuICAgIGlmIChhbmNob3IgJiYgdmlldy5kb20uY29udGFpbnMoYW5jaG9yLm5vZGVUeXBlID09IDEgPyBhbmNob3IgOiBhbmNob3IucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgZmluZCA9IFt7IG5vZGU6IGFuY2hvciwgb2Zmc2V0OiBkb21TZWwuYW5jaG9yT2Zmc2V0IH1dO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpKVxuICAgICAgICAgICAgZmluZC5wdXNoKHsgbm9kZTogZG9tU2VsLmZvY3VzTm9kZSwgb2Zmc2V0OiBkb21TZWwuZm9jdXNPZmZzZXQgfSk7XG4gICAgfVxuICAgIC8vIFdvcmsgYXJvdW5kIGlzc3VlIGluIENocm9tZSB3aGVyZSBiYWNrc3BhY2luZyBzb21ldGltZXMgcmVwbGFjZXNcbiAgICAvLyB0aGUgZGVsZXRlZCBjb250ZW50IHdpdGggYSByYW5kb20gQlIgbm9kZSAoaXNzdWVzICM3OTksICM4MzEpXG4gICAgaWYgKGNocm9tZSAmJiB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09PSA4KSB7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRvT2Zmc2V0OyBvZmYgPiBmcm9tT2Zmc2V0OyBvZmYtLSkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBwYXJlbnQuY2hpbGROb2Rlc1tvZmYgLSAxXSwgZGVzYyA9IG5vZGUucG1WaWV3RGVzYztcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiQlJcIiAmJiAhZGVzYykge1xuICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gb2ZmO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IGRlc2Muc2l6ZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhcnREb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICBsZXQgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImRvbVBhcnNlclwiKSB8fCBET01QYXJzZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gICAgbGV0ICRmcm9tID0gc3RhcnREb2MucmVzb2x2ZShmcm9tKTtcbiAgICBsZXQgc2VsID0gbnVsbCwgZG9jID0gcGFyc2VyLnBhcnNlKHBhcmVudCwge1xuICAgICAgICB0b3BOb2RlOiAkZnJvbS5wYXJlbnQsXG4gICAgICAgIHRvcE1hdGNoOiAkZnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXgoKSksXG4gICAgICAgIHRvcE9wZW46IHRydWUsXG4gICAgICAgIGZyb206IGZyb21PZmZzZXQsXG4gICAgICAgIHRvOiB0b09mZnNldCxcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAkZnJvbS5wYXJlbnQudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIgPyBcImZ1bGxcIiA6IHRydWUsXG4gICAgICAgIGZpbmRQb3NpdGlvbnM6IGZpbmQsXG4gICAgICAgIHJ1bGVGcm9tTm9kZSxcbiAgICAgICAgY29udGV4dDogJGZyb21cbiAgICB9KTtcbiAgICBpZiAoZmluZCAmJiBmaW5kWzBdLnBvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCBhbmNob3IgPSBmaW5kWzBdLnBvcywgaGVhZCA9IGZpbmRbMV0gJiYgZmluZFsxXS5wb3M7XG4gICAgICAgIGlmIChoZWFkID09IG51bGwpXG4gICAgICAgICAgICBoZWFkID0gYW5jaG9yO1xuICAgICAgICBzZWwgPSB7IGFuY2hvcjogYW5jaG9yICsgZnJvbSwgaGVhZDogaGVhZCArIGZyb20gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9jLCBzZWwsIGZyb20sIHRvIH07XG59XG5mdW5jdGlvbiBydWxlRnJvbU5vZGUoZG9tKSB7XG4gICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICBpZiAoZGVzYykge1xuICAgICAgICByZXR1cm4gZGVzYy5wYXJzZVJ1bGUoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiBkb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAvLyBTYWZhcmkgcmVwbGFjZXMgdGhlIGxpc3QgaXRlbSBvciB0YWJsZSBjZWxsIHdpdGggYSBCUlxuICAgICAgICAvLyBkaXJlY3RseSBpbiB0aGUgbGlzdCBub2RlICg/ISkgaWYgeW91IGRlbGV0ZSB0aGUgbGFzdFxuICAgICAgICAvLyBjaGFyYWN0ZXIgaW4gYSBsaXN0IGl0ZW0gb3IgdGFibGUgY2VsbCAoIzcwOCwgIzg2MilcbiAgICAgICAgaWYgKHNhZmFyaSAmJiAvXih1bHxvbCkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIGxldCBza2lwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHNraXAuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHNraXAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb20ucGFyZW50Tm9kZS5sYXN0Q2hpbGQgPT0gZG9tIHx8IHNhZmFyaSAmJiAvXih0cnx0YWJsZSkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIklNR1wiICYmIGRvbS5nZXRBdHRyaWJ1dGUoXCJtYXJrLXBsYWNlaG9sZGVyXCIpKSB7XG4gICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IGlzSW5saW5lID0gL14oYXxhYmJyfGFjcm9ueW18YnxiZFtpb118YmlnfGJyfGJ1dHRvbnxjaXRlfGNvZGV8ZGF0YShsaXN0KT98ZGVsfGRmbnxlbXxpfGluc3xrYmR8bGFiZWx8bWFwfG1hcmt8bWV0ZXJ8b3V0cHV0fHF8cnVieXxzfHNhbXB8c21hbGx8c3BhbnxzdHJvbmd8c3VbYnBdfHRpbWV8dXx0dHx2YXIpJC9pO1xuZnVuY3Rpb24gcmVhZERPTUNoYW5nZSh2aWV3LCBmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkTm9kZXMpIHtcbiAgICBsZXQgY29tcG9zaXRpb25JRCA9IHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyB8fCAodmlldy5jb21wb3NpbmcgPyB2aWV3LmlucHV0LmNvbXBvc2l0aW9uSUQgOiAwKTtcbiAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSAwO1xuICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICBsZXQgb3JpZ2luID0gdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uVGltZSA+IERhdGUubm93KCkgLSA1MCA/IHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvbk9yaWdpbiA6IG51bGw7XG4gICAgICAgIGxldCBuZXdTZWwgPSBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcsIG9yaWdpbik7XG4gICAgICAgIGlmIChuZXdTZWwgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLmVxKG5ld1NlbCkpIHtcbiAgICAgICAgICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCAmJlxuICAgICAgICAgICAgICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDEzICYmIERhdGUubm93KCkgLSAxMDAgPCB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlVGltZSAmJlxuICAgICAgICAgICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ld1NlbCk7XG4gICAgICAgICAgICBpZiAob3JpZ2luID09IFwicG9pbnRlclwiKVxuICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJwb2ludGVyXCIsIHRydWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAob3JpZ2luID09IFwia2V5XCIpXG4gICAgICAgICAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgIGlmIChjb21wb3NpdGlvbklEKVxuICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJjb21wb3NpdGlvblwiLCBjb21wb3NpdGlvbklEKTtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0ICRiZWZvcmUgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGZyb20pO1xuICAgIGxldCBzaGFyZWQgPSAkYmVmb3JlLnNoYXJlZERlcHRoKHRvKTtcbiAgICBmcm9tID0gJGJlZm9yZS5iZWZvcmUoc2hhcmVkICsgMSk7XG4gICAgdG8gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHRvKS5hZnRlcihzaGFyZWQgKyAxKTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHBhcnNlID0gcGFyc2VCZXR3ZWVuKHZpZXcsIGZyb20sIHRvKTtcbiAgICBsZXQgZG9jID0gdmlldy5zdGF0ZS5kb2MsIGNvbXBhcmUgPSBkb2Muc2xpY2UocGFyc2UuZnJvbSwgcGFyc2UudG8pO1xuICAgIGxldCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGU7XG4gICAgLy8gUHJlZmVyIGFuY2hvcmluZyB0byBlbmQgd2hlbiBCYWNrc3BhY2UgaXMgcHJlc3NlZFxuICAgIGlmICh2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09PSA4ICYmIERhdGUubm93KCkgLSAxMDAgPCB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlVGltZSkge1xuICAgICAgICBwcmVmZXJyZWRQb3MgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgcHJlZmVycmVkU2lkZSA9IFwiZW5kXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcmVmZXJyZWRQb3MgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tO1xuICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJzdGFydFwiO1xuICAgIH1cbiAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID0gbnVsbDtcbiAgICBsZXQgY2hhbmdlID0gZmluZERpZmYoY29tcGFyZS5jb250ZW50LCBwYXJzZS5kb2MuY29udGVudCwgcGFyc2UuZnJvbSwgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKTtcbiAgICBpZiAoKGlvcyAmJiB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA+IERhdGUubm93KCkgLSAyMjUgfHwgYW5kcm9pZCkgJiZcbiAgICAgICAgYWRkZWROb2Rlcy5zb21lKG4gPT4gbi5ub2RlVHlwZSA9PSAxICYmICFpc0lubGluZS50ZXN0KG4ubm9kZU5hbWUpKSAmJlxuICAgICAgICAoIWNoYW5nZSB8fCBjaGFuZ2UuZW5kQSA+PSBjaGFuZ2UuZW5kQikgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpIHtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hhbmdlKSB7XG4gICAgICAgIGlmICh0eXBlT3ZlciAmJiBzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmICFzZWwuZW1wdHkgJiYgc2VsLiRoZWFkLnNhbWVQYXJlbnQoc2VsLiRhbmNob3IpICYmXG4gICAgICAgICAgICAhdmlldy5jb21wb3NpbmcgJiYgIShwYXJzZS5zZWwgJiYgcGFyc2Uuc2VsLmFuY2hvciAhPSBwYXJzZS5zZWwuaGVhZCkpIHtcbiAgICAgICAgICAgIGNoYW5nZSA9IHsgc3RhcnQ6IHNlbC5mcm9tLCBlbmRBOiBzZWwudG8sIGVuZEI6IHNlbC50byB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhcnNlLnNlbCkge1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIHZpZXcuc3RhdGUuZG9jLCBwYXJzZS5zZWwpO1xuICAgICAgICAgICAgICAgIGlmIChzZWwgJiYgIXNlbC5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uSUQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiY29tcG9zaXRpb25cIiwgY29tcG9zaXRpb25JRCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDaHJvbWUgc29tZXRpbWVzIGxlYXZlcyB0aGUgY3Vyc29yIGJlZm9yZSB0aGUgaW5zZXJ0ZWQgdGV4dCB3aGVuXG4gICAgLy8gY29tcG9zaW5nIGFmdGVyIGEgY3Vyc29yIHdyYXBwZXIuIFRoaXMgbW92ZXMgaXQgZm9yd2FyZC5cbiAgICBpZiAoY2hyb21lICYmIHZpZXcuY3Vyc29yV3JhcHBlciAmJiBwYXJzZS5zZWwgJiYgcGFyc2Uuc2VsLmFuY2hvciA9PSB2aWV3LmN1cnNvcldyYXBwZXIuZGVjby5mcm9tICYmXG4gICAgICAgIHBhcnNlLnNlbC5oZWFkID09IHBhcnNlLnNlbC5hbmNob3IpIHtcbiAgICAgICAgbGV0IHNpemUgPSBjaGFuZ2UuZW5kQiAtIGNoYW5nZS5zdGFydDtcbiAgICAgICAgcGFyc2Uuc2VsID0geyBhbmNob3I6IHBhcnNlLnNlbC5hbmNob3IgKyBzaXplLCBoZWFkOiBwYXJzZS5zZWwuYW5jaG9yICsgc2l6ZSB9O1xuICAgIH1cbiAgICB2aWV3LmlucHV0LmRvbUNoYW5nZUNvdW50Kys7XG4gICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIG92ZXJ3cml0aW5nIGEgc2VsZWN0aW9uIGJ5IHR5cGluZyBtYXRjaGVzXG4gICAgLy8gdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgc2VsZWN0ZWQgY29udGVudCwgY3JlYXRpbmcgYSBjaGFuZ2VcbiAgICAvLyB0aGF0J3Mgc21hbGxlciB0aGFuIHdoYXQgd2FzIGFjdHVhbGx5IG92ZXJ3cml0dGVuLlxuICAgIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tIDwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gJiZcbiAgICAgICAgY2hhbmdlLnN0YXJ0ID09IGNoYW5nZS5lbmRCICYmXG4gICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xuICAgICAgICBpZiAoY2hhbmdlLnN0YXJ0ID4gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSAmJiBjaGFuZ2Uuc3RhcnQgPD0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSArIDIgJiZcbiAgICAgICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPj0gcGFyc2UuZnJvbSkge1xuICAgICAgICAgICAgY2hhbmdlLnN0YXJ0ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UuZW5kQSA8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvICYmIGNoYW5nZS5lbmRBID49IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIC0gMiAmJlxuICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gPD0gcGFyc2UudG8pIHtcbiAgICAgICAgICAgIGNoYW5nZS5lbmRCICs9ICh2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAtIGNoYW5nZS5lbmRBKTtcbiAgICAgICAgICAgIGNoYW5nZS5lbmRBID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG87XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSUUxMSB3aWxsIGluc2VydCBhIG5vbi1icmVha2luZyBzcGFjZSBfYWhlYWRfIG9mIHRoZSBzcGFjZSBhZnRlclxuICAgIC8vIHRoZSBjdXJzb3Igc3BhY2Ugd2hlbiBhZGRpbmcgYSBzcGFjZSBiZWZvcmUgYW5vdGhlciBzcGFjZS4gV2hlblxuICAgIC8vIHRoYXQgaGFwcGVuZWQsIGFkanVzdCB0aGUgY2hhbmdlIHRvIGNvdmVyIHRoZSBzcGFjZSBpbnN0ZWFkLlxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIGNoYW5nZS5lbmRCID09IGNoYW5nZS5zdGFydCArIDEgJiZcbiAgICAgICAgY2hhbmdlLmVuZEEgPT0gY2hhbmdlLnN0YXJ0ICYmIGNoYW5nZS5zdGFydCA+IHBhcnNlLmZyb20gJiZcbiAgICAgICAgcGFyc2UuZG9jLnRleHRCZXR3ZWVuKGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20gLSAxLCBjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tICsgMSkgPT0gXCIgXFx1MDBhMFwiKSB7XG4gICAgICAgIGNoYW5nZS5zdGFydC0tO1xuICAgICAgICBjaGFuZ2UuZW5kQS0tO1xuICAgICAgICBjaGFuZ2UuZW5kQi0tO1xuICAgIH1cbiAgICBsZXQgJGZyb20gPSBwYXJzZS5kb2MucmVzb2x2ZU5vQ2FjaGUoY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSk7XG4gICAgbGV0ICR0byA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pO1xuICAgIGxldCAkZnJvbUEgPSBkb2MucmVzb2x2ZShjaGFuZ2Uuc3RhcnQpO1xuICAgIGxldCBpbmxpbmVDaGFuZ2UgPSAkZnJvbS5zYW1lUGFyZW50KCR0bykgJiYgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgJiYgJGZyb21BLmVuZCgpID49IGNoYW5nZS5lbmRBO1xuICAgIGxldCBuZXh0U2VsO1xuICAgIC8vIElmIHRoaXMgbG9va3MgbGlrZSB0aGUgZWZmZWN0IG9mIHByZXNzaW5nIEVudGVyIChvciB3YXMgcmVjb3JkZWRcbiAgICAvLyBhcyBiZWluZyBhbiBpT1MgZW50ZXIgcHJlc3MpLCBqdXN0IGRpc3BhdGNoIGFuIEVudGVyIGtleSBpbnN0ZWFkLlxuICAgIGlmICgoKGlvcyAmJiB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA+IERhdGUubm93KCkgLSAyMjUgJiZcbiAgICAgICAgKCFpbmxpbmVDaGFuZ2UgfHwgYWRkZWROb2Rlcy5zb21lKG4gPT4gbi5ub2RlTmFtZSA9PSBcIkRJVlwiIHx8IG4ubm9kZU5hbWUgPT0gXCJQXCIpKSkgfHxcbiAgICAgICAgKCFpbmxpbmVDaGFuZ2UgJiYgJGZyb20ucG9zIDwgcGFyc2UuZG9jLmNvbnRlbnQuc2l6ZSAmJiAhJGZyb20uc2FtZVBhcmVudCgkdG8pICYmXG4gICAgICAgICAgICAobmV4dFNlbCA9IFNlbGVjdGlvbi5maW5kRnJvbShwYXJzZS5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAxKSwgMSwgdHJ1ZSkpICYmXG4gICAgICAgICAgICBuZXh0U2VsLmhlYWQgPT0gJHRvLnBvcykpICYmXG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSkpKSB7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTYW1lIGZvciBiYWNrc3BhY2VcbiAgICBpZiAodmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yID4gY2hhbmdlLnN0YXJ0ICYmXG4gICAgICAgIGxvb2tzTGlrZUpvaW4oZG9jLCBjaGFuZ2Uuc3RhcnQsIGNoYW5nZS5lbmRBLCAkZnJvbSwgJHRvKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoOCwgXCJCYWNrc3BhY2VcIikpKSkge1xuICAgICAgICBpZiAoYW5kcm9pZCAmJiBjaHJvbWUpXG4gICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcygpOyAvLyAjODIwXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBvY2Nhc2lvbmFsbHksIGR1cmluZyBjb21wb3NpdGlvbiwgZGVsZXRlIHRoZVxuICAgIC8vIGVudGlyZSBjb21wb3NpdGlvbiBhbmQgdGhlbiBpbW1lZGlhdGVseSBpbnNlcnQgaXQgYWdhaW4uIFRoaXMgaXNcbiAgICAvLyB1c2VkIHRvIGRldGVjdCB0aGF0IHNpdHVhdGlvbi5cbiAgICBpZiAoY2hyb21lICYmIGFuZHJvaWQgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0KVxuICAgICAgICB2aWV3LmlucHV0Lmxhc3RBbmRyb2lkRGVsZXRlID0gRGF0ZS5ub3coKTtcbiAgICAvLyBUaGlzIHRyaWVzIHRvIGRldGVjdCBBbmRyb2lkIHZpcnR1YWwga2V5Ym9hcmRcbiAgICAvLyBlbnRlci1hbmQtcGljay1zdWdnZXN0aW9uIGFjdGlvbi4gVGhhdCBzb21ldGltZXMgKHNlZSBpc3N1ZVxuICAgIC8vICMxMDU5KSBmaXJzdCBmaXJlcyBhIERPTSBtdXRhdGlvbiwgYmVmb3JlIG1vdmluZyB0aGUgc2VsZWN0aW9uIHRvXG4gICAgLy8gdGhlIG5ld2x5IGNyZWF0ZWQgYmxvY2suIEFuZCB0aGVuLCBiZWNhdXNlIFByb3NlTWlycm9yIGNsZWFucyB1cFxuICAgIC8vIHRoZSBET00gc2VsZWN0aW9uLCBpdCBnaXZlcyB1cCBtb3ZpbmcgdGhlIHNlbGVjdGlvbiBlbnRpcmVseSxcbiAgICAvLyBsZWF2aW5nIHRoZSBjdXJzb3IgaW4gdGhlIHdyb25nIHBsYWNlLiBXaGVuIHRoYXQgaGFwcGVucywgd2UgZHJvcFxuICAgIC8vIHRoZSBuZXcgcGFyYWdyYXBoIGZyb20gdGhlIGluaXRpYWwgY2hhbmdlLCBhbmQgZmlyZSBhIHNpbXVsYXRlZFxuICAgIC8vIGVudGVyIGtleSBhZnRlcndhcmRzLlxuICAgIGlmIChhbmRyb2lkICYmICFpbmxpbmVDaGFuZ2UgJiYgJGZyb20uc3RhcnQoKSAhPSAkdG8uc3RhcnQoKSAmJiAkdG8ucGFyZW50T2Zmc2V0ID09IDAgJiYgJGZyb20uZGVwdGggPT0gJHRvLmRlcHRoICYmXG4gICAgICAgIHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yID09IHBhcnNlLnNlbC5oZWFkICYmIHBhcnNlLnNlbC5oZWFkID09IGNoYW5nZS5lbmRBKSB7XG4gICAgICAgIGNoYW5nZS5lbmRCIC09IDI7XG4gICAgICAgICR0byA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKTsgfSk7XG4gICAgICAgIH0sIDIwKTtcbiAgICB9XG4gICAgbGV0IGNoRnJvbSA9IGNoYW5nZS5zdGFydCwgY2hUbyA9IGNoYW5nZS5lbmRBO1xuICAgIGxldCB0ciwgc3RvcmVkTWFya3MsIG1hcmtDaGFuZ2U7XG4gICAgaWYgKGlubGluZUNoYW5nZSkge1xuICAgICAgICBpZiAoJGZyb20ucG9zID09ICR0by5wb3MpIHsgLy8gRGVsZXRpb25cbiAgICAgICAgICAgIC8vIElFMTEgc29tZXRpbWVzIHdlaXJkbHkgbW92ZXMgdGhlIERPTSBzZWxlY3Rpb24gYXJvdW5kIGFmdGVyXG4gICAgICAgICAgICAvLyBiYWNrc3BhY2luZyBvdXQgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSB0ZXh0YmxvY2tcbiAgICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmICRmcm9tLnBhcmVudE9mZnNldCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNlbGVjdGlvblRvRE9NKHZpZXcpLCAyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ciA9IHZpZXcuc3RhdGUudHIuZGVsZXRlKGNoRnJvbSwgY2hUbyk7XG4gICAgICAgICAgICBzdG9yZWRNYXJrcyA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCkubWFya3NBY3Jvc3MoZG9jLnJlc29sdmUoY2hhbmdlLmVuZEEpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggLy8gQWRkaW5nIG9yIHJlbW92aW5nIGEgbWFya1xuICAgICAgICBjaGFuZ2UuZW5kQSA9PSBjaGFuZ2UuZW5kQiAmJlxuICAgICAgICAgICAgKG1hcmtDaGFuZ2UgPSBpc01hcmtDaGFuZ2UoJGZyb20ucGFyZW50LmNvbnRlbnQuY3V0KCRmcm9tLnBhcmVudE9mZnNldCwgJHRvLnBhcmVudE9mZnNldCksICRmcm9tQS5wYXJlbnQuY29udGVudC5jdXQoJGZyb21BLnBhcmVudE9mZnNldCwgY2hhbmdlLmVuZEEgLSAkZnJvbUEuc3RhcnQoKSkpKSkge1xuICAgICAgICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgICAgICAgICAgaWYgKG1hcmtDaGFuZ2UudHlwZSA9PSBcImFkZFwiKVxuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoY2hGcm9tLCBjaFRvLCBtYXJrQ2hhbmdlLm1hcmspO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRyLnJlbW92ZU1hcmsoY2hGcm9tLCBjaFRvLCBtYXJrQ2hhbmdlLm1hcmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCRmcm9tLnBhcmVudC5jaGlsZCgkZnJvbS5pbmRleCgpKS5pc1RleHQgJiYgJGZyb20uaW5kZXgoKSA9PSAkdG8uaW5kZXgoKSAtICgkdG8udGV4dE9mZnNldCA/IDAgOiAxKSkge1xuICAgICAgICAgICAgLy8gQm90aCBwb3NpdGlvbnMgaW4gdGhlIHNhbWUgdGV4dCBub2RlIC0tIHNpbXBseSBpbnNlcnQgdGV4dFxuICAgICAgICAgICAgbGV0IHRleHQgPSAkZnJvbS5wYXJlbnQudGV4dEJldHdlZW4oJGZyb20ucGFyZW50T2Zmc2V0LCAkdG8ucGFyZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlVGV4dElucHV0XCIsIGYgPT4gZih2aWV3LCBjaEZyb20sIGNoVG8sIHRleHQpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0ciA9IHZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dCh0ZXh0LCBjaEZyb20sIGNoVG8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghdHIpXG4gICAgICAgIHRyID0gdmlldy5zdGF0ZS50ci5yZXBsYWNlKGNoRnJvbSwgY2hUbywgcGFyc2UuZG9jLnNsaWNlKGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20sIGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSkpO1xuICAgIGlmIChwYXJzZS5zZWwpIHtcbiAgICAgICAgbGV0IHNlbCA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdHIuZG9jLCBwYXJzZS5zZWwpO1xuICAgICAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aWxsIHNvbWV0aW1lcywgZHVyaW5nIGNvbXBvc2l0aW9uLCByZXBvcnQgdGhlXG4gICAgICAgIC8vIHNlbGVjdGlvbiBpbiB0aGUgd3JvbmcgcGxhY2UuIElmIGl0IGxvb2tzIGxpa2UgdGhhdCBpc1xuICAgICAgICAvLyBoYXBwZW5pbmcsIGRvbid0IHVwZGF0ZSB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAvLyBFZGdlIGp1c3QgZG9lc24ndCBtb3ZlIHRoZSBjdXJzb3IgZm9yd2FyZCB3aGVuIHlvdSBzdGFydCB0eXBpbmdcbiAgICAgICAgLy8gaW4gYW4gZW1wdHkgYmxvY2sgb3IgYmV0d2VlbiBiciBub2Rlcy5cbiAgICAgICAgaWYgKHNlbCAmJiAhKGNocm9tZSAmJiBhbmRyb2lkICYmIHZpZXcuY29tcG9zaW5nICYmIHNlbC5lbXB0eSAmJlxuICAgICAgICAgICAgKGNoYW5nZS5zdGFydCAhPSBjaGFuZ2UuZW5kQiB8fCB2aWV3LmlucHV0Lmxhc3RBbmRyb2lkRGVsZXRlIDwgRGF0ZS5ub3coKSAtIDEwMCkgJiZcbiAgICAgICAgICAgIChzZWwuaGVhZCA9PSBjaEZyb20gfHwgc2VsLmhlYWQgPT0gdHIubWFwcGluZy5tYXAoY2hUbykgLSAxKSB8fFxuICAgICAgICAgICAgaWUgJiYgc2VsLmVtcHR5ICYmIHNlbC5oZWFkID09IGNoRnJvbSkpXG4gICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsKTtcbiAgICB9XG4gICAgaWYgKHN0b3JlZE1hcmtzKVxuICAgICAgICB0ci5lbnN1cmVNYXJrcyhzdG9yZWRNYXJrcyk7XG4gICAgaWYgKGNvbXBvc2l0aW9uSUQpXG4gICAgICAgIHRyLnNldE1ldGEoXCJjb21wb3NpdGlvblwiLCBjb21wb3NpdGlvbklEKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCBkb2MsIHBhcnNlZFNlbCkge1xuICAgIGlmIChNYXRoLm1heChwYXJzZWRTZWwuYW5jaG9yLCBwYXJzZWRTZWwuaGVhZCkgPiBkb2MuY29udGVudC5zaXplKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCBkb2MucmVzb2x2ZShwYXJzZWRTZWwuYW5jaG9yKSwgZG9jLnJlc29sdmUocGFyc2VkU2VsLmhlYWQpKTtcbn1cbi8vIEdpdmVuIHR3byBzYW1lLWxlbmd0aCwgbm9uLWVtcHR5IGZyYWdtZW50cyBvZiBpbmxpbmUgY29udGVudCxcbi8vIGRldGVybWluZSB3aGV0aGVyIHRoZSBmaXJzdCBjb3VsZCBiZSBjcmVhdGVkIGZyb20gdGhlIHNlY29uZCBieVxuLy8gcmVtb3Zpbmcgb3IgYWRkaW5nIGEgc2luZ2xlIG1hcmsgdHlwZS5cbmZ1bmN0aW9uIGlzTWFya0NoYW5nZShjdXIsIHByZXYpIHtcbiAgICBsZXQgY3VyTWFya3MgPSBjdXIuZmlyc3RDaGlsZC5tYXJrcywgcHJldk1hcmtzID0gcHJldi5maXJzdENoaWxkLm1hcmtzO1xuICAgIGxldCBhZGRlZCA9IGN1ck1hcmtzLCByZW1vdmVkID0gcHJldk1hcmtzLCB0eXBlLCBtYXJrLCB1cGRhdGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2TWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgIGFkZGVkID0gcHJldk1hcmtzW2ldLnJlbW92ZUZyb21TZXQoYWRkZWQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyTWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlbW92ZWQgPSBjdXJNYXJrc1tpXS5yZW1vdmVGcm9tU2V0KHJlbW92ZWQpO1xuICAgIGlmIChhZGRlZC5sZW5ndGggPT0gMSAmJiByZW1vdmVkLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIG1hcmsgPSBhZGRlZFswXTtcbiAgICAgICAgdHlwZSA9IFwiYWRkXCI7XG4gICAgICAgIHVwZGF0ZSA9IChub2RlKSA9PiBub2RlLm1hcmsobWFyay5hZGRUb1NldChub2RlLm1hcmtzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFkZGVkLmxlbmd0aCA9PSAwICYmIHJlbW92ZWQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgbWFyayA9IHJlbW92ZWRbMF07XG4gICAgICAgIHR5cGUgPSBcInJlbW92ZVwiO1xuICAgICAgICB1cGRhdGUgPSAobm9kZSkgPT4gbm9kZS5tYXJrKG1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHVwZGF0ZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICB1cGRhdGVkLnB1c2godXBkYXRlKHByZXYuY2hpbGQoaSkpKTtcbiAgICBpZiAoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKS5lcShjdXIpKVxuICAgICAgICByZXR1cm4geyBtYXJrLCB0eXBlIH07XG59XG5mdW5jdGlvbiBsb29rc0xpa2VKb2luKG9sZCwgc3RhcnQsIGVuZCwgJG5ld1N0YXJ0LCAkbmV3RW5kKSB7XG4gICAgaWYgKCEkbmV3U3RhcnQucGFyZW50LmlzVGV4dGJsb2NrIHx8XG4gICAgICAgIC8vIFRoZSBjb250ZW50IG11c3QgaGF2ZSBzaHJ1bmtcbiAgICAgICAgZW5kIC0gc3RhcnQgPD0gJG5ld0VuZC5wb3MgLSAkbmV3U3RhcnQucG9zIHx8XG4gICAgICAgIC8vIG5ld0VuZCBtdXN0IHBvaW50IGRpcmVjdGx5IGF0IG9yIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGJsb2NrIHRoYXQgbmV3U3RhcnQgcG9pbnRzIGludG9cbiAgICAgICAgc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRuZXdTdGFydCwgdHJ1ZSwgZmFsc2UpIDwgJG5ld0VuZC5wb3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHN0YXJ0ID0gb2xkLnJlc29sdmUoc3RhcnQpO1xuICAgIC8vIFN0YXJ0IG11c3QgYmUgYXQgdGhlIGVuZCBvZiBhIGJsb2NrXG4gICAgaWYgKCRzdGFydC5wYXJlbnRPZmZzZXQgPCAkc3RhcnQucGFyZW50LmNvbnRlbnQuc2l6ZSB8fCAhJHN0YXJ0LnBhcmVudC5pc1RleHRibG9jaylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkbmV4dCA9IG9sZC5yZXNvbHZlKHNraXBDbG9zaW5nQW5kT3BlbmluZygkc3RhcnQsIHRydWUsIHRydWUpKTtcbiAgICAvLyBUaGUgbmV4dCB0ZXh0YmxvY2sgbXVzdCBzdGFydCBiZWZvcmUgZW5kIGFuZCBlbmQgbmVhciBpdFxuICAgIGlmICghJG5leHQucGFyZW50LmlzVGV4dGJsb2NrIHx8ICRuZXh0LnBvcyA+IGVuZCB8fFxuICAgICAgICBza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJG5leHQsIHRydWUsIGZhbHNlKSA8IGVuZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFRoZSBmcmFnbWVudHMgYWZ0ZXIgdGhlIGpvaW4gcG9pbnQgbXVzdCBtYXRjaFxuICAgIHJldHVybiAkbmV3U3RhcnQucGFyZW50LmNvbnRlbnQuY3V0KCRuZXdTdGFydC5wYXJlbnRPZmZzZXQpLmVxKCRuZXh0LnBhcmVudC5jb250ZW50KTtcbn1cbmZ1bmN0aW9uIHNraXBDbG9zaW5nQW5kT3BlbmluZygkcG9zLCBmcm9tRW5kLCBtYXlPcGVuKSB7XG4gICAgbGV0IGRlcHRoID0gJHBvcy5kZXB0aCwgZW5kID0gZnJvbUVuZCA/ICRwb3MuZW5kKCkgOiAkcG9zLnBvcztcbiAgICB3aGlsZSAoZGVwdGggPiAwICYmIChmcm9tRW5kIHx8ICRwb3MuaW5kZXhBZnRlcihkZXB0aCkgPT0gJHBvcy5ub2RlKGRlcHRoKS5jaGlsZENvdW50KSkge1xuICAgICAgICBkZXB0aC0tO1xuICAgICAgICBlbmQrKztcbiAgICAgICAgZnJvbUVuZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobWF5T3Blbikge1xuICAgICAgICBsZXQgbmV4dCA9ICRwb3Mubm9kZShkZXB0aCkubWF5YmVDaGlsZCgkcG9zLmluZGV4QWZ0ZXIoZGVwdGgpKTtcbiAgICAgICAgd2hpbGUgKG5leHQgJiYgIW5leHQuaXNMZWFmKSB7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dC5maXJzdENoaWxkO1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cbmZ1bmN0aW9uIGZpbmREaWZmKGEsIGIsIHBvcywgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKSB7XG4gICAgbGV0IHN0YXJ0ID0gYS5maW5kRGlmZlN0YXJ0KGIsIHBvcyk7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB7IGE6IGVuZEEsIGI6IGVuZEIgfSA9IGEuZmluZERpZmZFbmQoYiwgcG9zICsgYS5zaXplLCBwb3MgKyBiLnNpemUpO1xuICAgIGlmIChwcmVmZXJyZWRTaWRlID09IFwiZW5kXCIpIHtcbiAgICAgICAgbGV0IGFkanVzdCA9IE1hdGgubWF4KDAsIHN0YXJ0IC0gTWF0aC5taW4oZW5kQSwgZW5kQikpO1xuICAgICAgICBwcmVmZXJyZWRQb3MgLT0gZW5kQSArIGFkanVzdCAtIHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoZW5kQSA8IHN0YXJ0ICYmIGEuc2l6ZSA8IGIuc2l6ZSkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBzdGFydCAmJiBwcmVmZXJyZWRQb3MgPj0gZW5kQSA/IHN0YXJ0IC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgc3RhcnQgLT0gbW92ZTtcbiAgICAgICAgaWYgKHN0YXJ0ICYmIHN0YXJ0IDwgYi5zaXplICYmIGlzU3Vycm9nYXRlUGFpcihiLnRleHRCZXR3ZWVuKHN0YXJ0IC0gMSwgc3RhcnQgKyAxKSkpXG4gICAgICAgICAgICBzdGFydCArPSBtb3ZlID8gMSA6IC0xO1xuICAgICAgICBlbmRCID0gc3RhcnQgKyAoZW5kQiAtIGVuZEEpO1xuICAgICAgICBlbmRBID0gc3RhcnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVuZEIgPCBzdGFydCkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBzdGFydCAmJiBwcmVmZXJyZWRQb3MgPj0gZW5kQiA/IHN0YXJ0IC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgc3RhcnQgLT0gbW92ZTtcbiAgICAgICAgaWYgKHN0YXJ0ICYmIHN0YXJ0IDwgYS5zaXplICYmIGlzU3Vycm9nYXRlUGFpcihhLnRleHRCZXR3ZWVuKHN0YXJ0IC0gMSwgc3RhcnQgKyAxKSkpXG4gICAgICAgICAgICBzdGFydCArPSBtb3ZlID8gMSA6IC0xO1xuICAgICAgICBlbmRBID0gc3RhcnQgKyAoZW5kQSAtIGVuZEIpO1xuICAgICAgICBlbmRCID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmRBLCBlbmRCIH07XG59XG5mdW5jdGlvbiBpc1N1cnJvZ2F0ZVBhaXIoc3RyKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggIT0gMilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhID0gc3RyLmNoYXJDb2RlQXQoMCksIGIgPSBzdHIuY2hhckNvZGVBdCgxKTtcbiAgICByZXR1cm4gYSA+PSAweERDMDAgJiYgYSA8PSAweERGRkYgJiYgYiA+PSAweEQ4MDAgJiYgYiA8PSAweERCRkY7XG59XG5cbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX19zZXJpYWxpemVGb3JDbGlwYm9hcmQgPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQ7XG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fcGFyc2VGcm9tQ2xpcGJvYXJkID0gcGFyc2VGcm9tQ2xpcGJvYXJkO1xuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX2VuZENvbXBvc2l0aW9uID0gZW5kQ29tcG9zaXRpb247XG4vKipcbkFuIGVkaXRvciB2aWV3IG1hbmFnZXMgdGhlIERPTSBzdHJ1Y3R1cmUgdGhhdCByZXByZXNlbnRzIGFuXG5lZGl0YWJsZSBkb2N1bWVudC4gSXRzIHN0YXRlIGFuZCBiZWhhdmlvciBhcmUgZGV0ZXJtaW5lZCBieSBpdHNcbltwcm9wc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRGlyZWN0RWRpdG9yUHJvcHMpLlxuKi9cbmNsYXNzIEVkaXRvclZpZXcge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHZpZXcuIGBwbGFjZWAgbWF5IGJlIGEgRE9NIG5vZGUgdGhhdCB0aGUgZWRpdG9yIHNob3VsZFxuICAgIGJlIGFwcGVuZGVkIHRvLCBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBwbGFjZSBpdCBpbnRvIHRoZSBkb2N1bWVudCxcbiAgICBvciBhbiBvYmplY3Qgd2hvc2UgYG1vdW50YCBwcm9wZXJ0eSBob2xkcyB0aGUgbm9kZSB0byB1c2UgYXMgdGhlXG4gICAgZG9jdW1lbnQgY29udGFpbmVyLiBJZiBpdCBpcyBgbnVsbGAsIHRoZSBlZGl0b3Igd2lsbCBub3QgYmVcbiAgICBhZGRlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwbGFjZSwgcHJvcHMpIHtcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBLbHVkZ2UgdXNlZCB0byB3b3JrIGFyb3VuZCBhIENocm9tZSBidWcgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudHJhY2tXcml0ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcmtDdXJzb3IgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY3Vyc29yV3JhcHBlciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlucHV0ID0gbmV3IElucHV0U3RhdGU7XG4gICAgICAgIHRoaXMucHJldkRpcmVjdFBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW5WaWV3cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgSG9sZHMgYHRydWVgIHdoZW4gYSBoYWNrIG5vZGUgaXMgbmVlZGVkIGluIEZpcmVmb3ggdG8gcHJldmVudCB0aGVcbiAgICAgICAgW3NwYWNlIGlzIGVhdGVuIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3IvaXNzdWVzLzY1MSlcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucmVxdWlyZXNHZWNrb0hhY2tOb2RlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBXaGVuIGVkaXRvciBjb250ZW50IGlzIGJlaW5nIGRyYWdnZWQsIHRoaXMgb2JqZWN0IGNvbnRhaW5zXG4gICAgICAgIGluZm9ybWF0aW9uIGFib3V0IHRoZSBkcmFnZ2VkIHNsaWNlIGFuZCB3aGV0aGVyIGl0IGlzIGJlaW5nXG4gICAgICAgIGNvcGllZCBvciBtb3ZlZC4gQXQgYW55IG90aGVyIHRpbWUsIGl0IGlzIG51bGwuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLnN0YXRlID0gcHJvcHMuc3RhdGU7XG4gICAgICAgIHRoaXMuZGlyZWN0UGx1Z2lucyA9IHByb3BzLnBsdWdpbnMgfHwgW107XG4gICAgICAgIHRoaXMuZGlyZWN0UGx1Z2lucy5mb3JFYWNoKGNoZWNrU3RhdGVDb21wb25lbnQpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRvbSA9IChwbGFjZSAmJiBwbGFjZS5tb3VudCkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaWYgKHBsYWNlKSB7XG4gICAgICAgICAgICBpZiAocGxhY2UuYXBwZW5kQ2hpbGQpXG4gICAgICAgICAgICAgICAgcGxhY2UuYXBwZW5kQ2hpbGQodGhpcy5kb20pO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBsYWNlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBwbGFjZSh0aGlzLmRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmIChwbGFjZS5tb3VudClcbiAgICAgICAgICAgICAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBnZXRFZGl0YWJsZSh0aGlzKTtcbiAgICAgICAgdXBkYXRlQ3Vyc29yV3JhcHBlcih0aGlzKTtcbiAgICAgICAgdGhpcy5ub2RlVmlld3MgPSBidWlsZE5vZGVWaWV3cyh0aGlzKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3ID0gZG9jVmlld0Rlc2ModGhpcy5zdGF0ZS5kb2MsIGNvbXB1dGVEb2NEZWNvKHRoaXMpLCB2aWV3RGVjb3JhdGlvbnModGhpcyksIHRoaXMuZG9tLCB0aGlzKTtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlciA9IG5ldyBET01PYnNlcnZlcih0aGlzLCAoZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZCkgPT4gcmVhZERPTUNoYW5nZSh0aGlzLCBmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKSk7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgaW5pdElucHV0KHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpblZpZXdzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEhvbGRzIGB0cnVlYCB3aGVuIGFcbiAgICBbY29tcG9zaXRpb25dKGh0dHBzOi8vdzNjLmdpdGh1Yi5pby91aWV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzKVxuICAgIGlzIGFjdGl2ZS5cbiAgICAqL1xuICAgIGdldCBjb21wb3NpbmcoKSB7IHJldHVybiB0aGlzLmlucHV0LmNvbXBvc2luZzsgfVxuICAgIC8qKlxuICAgIFRoZSB2aWV3J3MgY3VycmVudCBbcHJvcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzKS5cbiAgICAqL1xuICAgIGdldCBwcm9wcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb3BzLnN0YXRlICE9IHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gdGhpcy5fcHJvcHM7XG4gICAgICAgICAgICB0aGlzLl9wcm9wcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcmV2KVxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzW25hbWVdID0gcHJldltuYW1lXTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BzLnN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcHM7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldydzIHByb3BzLiBXaWxsIGltbWVkaWF0ZWx5IGNhdXNlIGFuIHVwZGF0ZSB0b1xuICAgIHRoZSBET00uXG4gICAgKi9cbiAgICB1cGRhdGUocHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzLmhhbmRsZURPTUV2ZW50cyAhPSB0aGlzLl9wcm9wcy5oYW5kbGVET01FdmVudHMpXG4gICAgICAgICAgICBlbnN1cmVMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIGxldCBwcmV2UHJvcHMgPSB0aGlzLl9wcm9wcztcbiAgICAgICAgdGhpcy5fcHJvcHMgPSBwcm9wcztcbiAgICAgICAgaWYgKHByb3BzLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIHByb3BzLnBsdWdpbnMuZm9yRWFjaChjaGVja1N0YXRlQ29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0UGx1Z2lucyA9IHByb3BzLnBsdWdpbnM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUlubmVyKHByb3BzLnN0YXRlLCBwcmV2UHJvcHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHZpZXcgYnkgdXBkYXRpbmcgZXhpc3RpbmcgcHJvcHMgb2JqZWN0IHdpdGggdGhlIG9iamVjdFxuICAgIGdpdmVuIGFzIGFyZ3VtZW50LiBFcXVpdmFsZW50IHRvIGB2aWV3LnVwZGF0ZShPYmplY3QuYXNzaWduKHt9LFxuICAgIHZpZXcucHJvcHMsIHByb3BzKSlgLlxuICAgICovXG4gICAgc2V0UHJvcHMocHJvcHMpIHtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLl9wcm9wcylcbiAgICAgICAgICAgIHVwZGF0ZWRbbmFtZV0gPSB0aGlzLl9wcm9wc1tuYW1lXTtcbiAgICAgICAgdXBkYXRlZC5zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJvcHMpXG4gICAgICAgICAgICB1cGRhdGVkW25hbWVdID0gcHJvcHNbbmFtZV07XG4gICAgICAgIHRoaXMudXBkYXRlKHVwZGF0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIGVkaXRvcidzIGBzdGF0ZWAgcHJvcCwgd2l0aG91dCB0b3VjaGluZyBhbnkgb2YgdGhlXG4gICAgb3RoZXIgcHJvcHMuXG4gICAgKi9cbiAgICB1cGRhdGVTdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlSW5uZXIoc3RhdGUsIHRoaXMuX3Byb3BzKTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdGVJbm5lcihzdGF0ZSwgcHJldlByb3BzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHByZXYgPSB0aGlzLnN0YXRlLCByZWRyYXcgPSBmYWxzZSwgdXBkYXRlU2VsID0gZmFsc2U7XG4gICAgICAgIC8vIFdoZW4gc3RvcmVkIG1hcmtzIGFyZSBhZGRlZCwgc3RvcCBjb21wb3NpdGlvbiwgc28gdGhhdCB0aGV5IGNhblxuICAgICAgICAvLyBiZSBkaXNwbGF5ZWQuXG4gICAgICAgIGlmIChzdGF0ZS5zdG9yZWRNYXJrcyAmJiB0aGlzLmNvbXBvc2luZykge1xuICAgICAgICAgICAgY2xlYXJDb21wb3NpdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZVNlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICBsZXQgcGx1Z2luc0NoYW5nZWQgPSBwcmV2LnBsdWdpbnMgIT0gc3RhdGUucGx1Z2lucyB8fCB0aGlzLl9wcm9wcy5wbHVnaW5zICE9IHByZXZQcm9wcy5wbHVnaW5zO1xuICAgICAgICBpZiAocGx1Z2luc0NoYW5nZWQgfHwgdGhpcy5fcHJvcHMucGx1Z2lucyAhPSBwcmV2UHJvcHMucGx1Z2lucyB8fCB0aGlzLl9wcm9wcy5ub2RlVmlld3MgIT0gcHJldlByb3BzLm5vZGVWaWV3cykge1xuICAgICAgICAgICAgbGV0IG5vZGVWaWV3cyA9IGJ1aWxkTm9kZVZpZXdzKHRoaXMpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWROb2RlVmlld3Mobm9kZVZpZXdzLCB0aGlzLm5vZGVWaWV3cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVWaWV3cyA9IG5vZGVWaWV3cztcbiAgICAgICAgICAgICAgICByZWRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwbHVnaW5zQ2hhbmdlZCB8fCBwcmV2UHJvcHMuaGFuZGxlRE9NRXZlbnRzICE9IHRoaXMuX3Byb3BzLmhhbmRsZURPTUV2ZW50cykge1xuICAgICAgICAgICAgZW5zdXJlTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBnZXRFZGl0YWJsZSh0aGlzKTtcbiAgICAgICAgdXBkYXRlQ3Vyc29yV3JhcHBlcih0aGlzKTtcbiAgICAgICAgbGV0IGlubmVyRGVjbyA9IHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgb3V0ZXJEZWNvID0gY29tcHV0ZURvY0RlY28odGhpcyk7XG4gICAgICAgIGxldCBzY3JvbGwgPSBwcmV2LnBsdWdpbnMgIT0gc3RhdGUucGx1Z2lucyAmJiAhcHJldi5kb2MuZXEoc3RhdGUuZG9jKSA/IFwicmVzZXRcIlxuICAgICAgICAgICAgOiBzdGF0ZS5zY3JvbGxUb1NlbGVjdGlvbiA+IHByZXYuc2Nyb2xsVG9TZWxlY3Rpb24gPyBcInRvIHNlbGVjdGlvblwiIDogXCJwcmVzZXJ2ZVwiO1xuICAgICAgICBsZXQgdXBkYXRlRG9jID0gcmVkcmF3IHx8ICF0aGlzLmRvY1ZpZXcubWF0Y2hlc05vZGUoc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICAgIGlmICh1cGRhdGVEb2MgfHwgIXN0YXRlLnNlbGVjdGlvbi5lcShwcmV2LnNlbGVjdGlvbikpXG4gICAgICAgICAgICB1cGRhdGVTZWwgPSB0cnVlO1xuICAgICAgICBsZXQgb2xkU2Nyb2xsUG9zID0gc2Nyb2xsID09IFwicHJlc2VydmVcIiAmJiB1cGRhdGVTZWwgJiYgdGhpcy5kb20uc3R5bGUub3ZlcmZsb3dBbmNob3IgPT0gbnVsbCAmJiBzdG9yZVNjcm9sbFBvcyh0aGlzKTtcbiAgICAgICAgaWYgKHVwZGF0ZVNlbCkge1xuICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBhbiBpc3N1ZSBpbiBDaHJvbWUsIElFLCBhbmQgRWRnZSB3aGVyZSBjaGFuZ2luZ1xuICAgICAgICAgICAgLy8gdGhlIERPTSBhcm91bmQgYW4gYWN0aXZlIHNlbGVjdGlvbiBwdXRzIGl0IGludG8gYSBicm9rZW5cbiAgICAgICAgICAgIC8vIHN0YXRlIHdoZXJlIHRoZSB0aGluZyB0aGUgdXNlciBzZWVzIGRpZmZlcnMgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiByZXBvcnRlZCBieSB0aGUgU2VsZWN0aW9uIG9iamVjdCAoIzcxMCwgIzk3MyxcbiAgICAgICAgICAgIC8vICMxMDExLCAjMTAxMywgIzEwMzUpLlxuICAgICAgICAgICAgbGV0IGZvcmNlU2VsVXBkYXRlID0gdXBkYXRlRG9jICYmIChpZSB8fCBjaHJvbWUpICYmICF0aGlzLmNvbXBvc2luZyAmJlxuICAgICAgICAgICAgICAgICFwcmV2LnNlbGVjdGlvbi5lbXB0eSAmJiAhc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmIHNlbGVjdGlvbkNvbnRleHRDaGFuZ2VkKHByZXYuc2VsZWN0aW9uLCBzdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZURvYykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBub2RlIHRoYXQgdGhlIHNlbGVjdGlvbiBwb2ludHMgaW50byBpcyB3cml0dGVuIHRvLFxuICAgICAgICAgICAgICAgIC8vIENocm9tZSBzb21ldGltZXMgc3RhcnRzIG1pc3JlcG9ydGluZyB0aGUgc2VsZWN0aW9uLCBzbyB0aGlzXG4gICAgICAgICAgICAgICAgLy8gdHJhY2tzIHRoYXQgYW5kIGZvcmNlcyBhIHNlbGVjdGlvbiByZXNldCB3aGVuIG91ciB1cGRhdGVcbiAgICAgICAgICAgICAgICAvLyBkaWQgd3JpdGUgdG8gdGhlIG5vZGUuXG4gICAgICAgICAgICAgICAgbGV0IGNocm9tZUtsdWRnZSA9IGNocm9tZSA/ICh0aGlzLnRyYWNrV3JpdGVzID0gdGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpLmZvY3VzTm9kZSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZWRyYXcgfHwgIXRoaXMuZG9jVmlldy51cGRhdGUoc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgdGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZU91dGVyRGVjbyhbXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldyA9IGRvY1ZpZXdEZXNjKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHRoaXMuZG9tLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNocm9tZUtsdWRnZSAmJiAhdGhpcy50cmFja1dyaXRlcylcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VTZWxVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV29yayBhcm91bmQgZm9yIGFuIGlzc3VlIHdoZXJlIGFuIHVwZGF0ZSBhcnJpdmluZyByaWdodCBiZXR3ZWVuXG4gICAgICAgICAgICAvLyBhIERPTSBzZWxlY3Rpb24gY2hhbmdlIGFuZCB0aGUgXCJzZWxlY3Rpb25jaGFuZ2VcIiBldmVudCBmb3IgaXRcbiAgICAgICAgICAgIC8vIGNhbiBjYXVzZSBhIHNwdXJpb3VzIERPTSBzZWxlY3Rpb24gdXBkYXRlLCBkaXNydXB0aW5nIG1vdXNlXG4gICAgICAgICAgICAvLyBkcmFnIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIGlmIChmb3JjZVNlbFVwZGF0ZSB8fFxuICAgICAgICAgICAgICAgICEodGhpcy5pbnB1dC5tb3VzZURvd24gJiYgdGhpcy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmVxKHRoaXMuZG9tU2VsZWN0aW9uUmFuZ2UoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9ySW5SaWdodFBsYWNlKHRoaXMpKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHRoaXMsIGZvcmNlU2VsVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bmNOb2RlU2VsZWN0aW9uKHRoaXMsIHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpblZpZXdzKHByZXYpO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMuZHJhZ2dpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub2RlKSAmJiAhcHJldi5kb2MuZXEoc3RhdGUuZG9jKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRHJhZ2dlZE5vZGUodGhpcy5kcmFnZ2luZywgcHJldik7XG4gICAgICAgIGlmIChzY3JvbGwgPT0gXCJyZXNldFwiKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5zY3JvbGxUb3AgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjcm9sbCA9PSBcInRvIHNlbGVjdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkU2Nyb2xsUG9zKSB7XG4gICAgICAgICAgICByZXNldFNjcm9sbFBvcyhvbGRTY3JvbGxQb3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2Nyb2xsVG9TZWxlY3Rpb24oKSB7XG4gICAgICAgIGxldCBzdGFydERPTSA9IHRoaXMuZG9tU2VsZWN0aW9uUmFuZ2UoKS5mb2N1c05vZGU7XG4gICAgICAgIGlmICh0aGlzLnNvbWVQcm9wKFwiaGFuZGxlU2Nyb2xsVG9TZWxlY3Rpb25cIiwgZiA9PiBmKHRoaXMpKSkgO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLmRvY1ZpZXcuZG9tQWZ0ZXJQb3ModGhpcy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc3RhcnRET00pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRoaXMuY29vcmRzQXRQb3ModGhpcy5zdGF0ZS5zZWxlY3Rpb24uaGVhZCwgMSksIHN0YXJ0RE9NKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95UGx1Z2luVmlld3MoKSB7XG4gICAgICAgIGxldCB2aWV3O1xuICAgICAgICB3aGlsZSAodmlldyA9IHRoaXMucGx1Z2luVmlld3MucG9wKCkpXG4gICAgICAgICAgICBpZiAodmlldy5kZXN0cm95KVxuICAgICAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgIH1cbiAgICB1cGRhdGVQbHVnaW5WaWV3cyhwcmV2U3RhdGUpIHtcbiAgICAgICAgaWYgKCFwcmV2U3RhdGUgfHwgcHJldlN0YXRlLnBsdWdpbnMgIT0gdGhpcy5zdGF0ZS5wbHVnaW5zIHx8IHRoaXMuZGlyZWN0UGx1Z2lucyAhPSB0aGlzLnByZXZEaXJlY3RQbHVnaW5zKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZEaXJlY3RQbHVnaW5zID0gdGhpcy5kaXJlY3RQbHVnaW5zO1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95UGx1Z2luVmlld3MoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kaXJlY3RQbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMudmlldylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5WaWV3cy5wdXNoKHBsdWdpbi5zcGVjLnZpZXcodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRlLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5zdGF0ZS5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy52aWV3KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpblZpZXdzLnB1c2gocGx1Z2luLnNwZWMudmlldyh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2luVmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luVmlldyA9IHRoaXMucGx1Z2luVmlld3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpblZpZXcudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5WaWV3LnVwZGF0ZSh0aGlzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZURyYWdnZWROb2RlKGRyYWdnaW5nLCBwcmV2KSB7XG4gICAgICAgIGxldCBzZWwgPSBkcmFnZ2luZy5ub2RlLCBmb3VuZCA9IC0xO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5kb2Mubm9kZUF0KHNlbC5mcm9tKSA9PSBzZWwubm9kZSkge1xuICAgICAgICAgICAgZm91bmQgPSBzZWwuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtb3ZlZFBvcyA9IHNlbC5mcm9tICsgKHRoaXMuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSAtIHByZXYuZG9jLmNvbnRlbnQuc2l6ZSk7XG4gICAgICAgICAgICBsZXQgbW92ZWQgPSBtb3ZlZFBvcyA+IDAgJiYgdGhpcy5zdGF0ZS5kb2Mubm9kZUF0KG1vdmVkUG9zKTtcbiAgICAgICAgICAgIGlmIChtb3ZlZCA9PSBzZWwubm9kZSlcbiAgICAgICAgICAgICAgICBmb3VuZCA9IG1vdmVkUG9zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBuZXcgRHJhZ2dpbmcoZHJhZ2dpbmcuc2xpY2UsIGRyYWdnaW5nLm1vdmUsIGZvdW5kIDwgMCA/IHVuZGVmaW5lZCA6IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRoaXMuc3RhdGUuZG9jLCBmb3VuZCkpO1xuICAgIH1cbiAgICBzb21lUHJvcChwcm9wTmFtZSwgZikge1xuICAgICAgICBsZXQgcHJvcCA9IHRoaXMuX3Byb3BzICYmIHRoaXMuX3Byb3BzW3Byb3BOYW1lXSwgdmFsdWU7XG4gICAgICAgIGlmIChwcm9wICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYocHJvcCkgOiBwcm9wKSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRpcmVjdFBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwcm9wID0gdGhpcy5kaXJlY3RQbHVnaW5zW2ldLnByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIGlmIChwcm9wICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYocHJvcCkgOiBwcm9wKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBsdWdpbnMgPSB0aGlzLnN0YXRlLnBsdWdpbnM7XG4gICAgICAgIGlmIChwbHVnaW5zKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwbHVnaW5zW2ldLnByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3ApIDogcHJvcCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcnkgd2hldGhlciB0aGUgdmlldyBoYXMgZm9jdXMuXG4gICAgKi9cbiAgICBoYXNGb2N1cygpIHtcbiAgICAgICAgLy8gV29yayBhcm91bmQgSUUgbm90IGhhbmRsaW5nIGZvY3VzIGNvcnJlY3RseSBpZiByZXNpemUgaGFuZGxlcyBhcmUgc2hvd24uXG4gICAgICAgIC8vIElmIHRoZSBjdXJzb3IgaXMgaW5zaWRlIGFuIGVsZW1lbnQgd2l0aCByZXNpemUgaGFuZGxlcywgYWN0aXZlRWxlbWVudFxuICAgICAgICAvLyB3aWxsIGJlIHRoYXQgZWxlbWVudCBpbnN0ZWFkIG9mIHRoaXMuZG9tLlxuICAgICAgICBpZiAoaWUpIHtcbiAgICAgICAgICAgIC8vIElmIGFjdGl2ZUVsZW1lbnQgaXMgd2l0aGluIHRoaXMuZG9tLCBhbmQgdGhlcmUgYXJlIG5vIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBzZXR0aW5nIGBjb250ZW50ZWRpdGFibGVgIHRvIGZhbHNlIGluIGJldHdlZW4sIHRyZWF0IGl0IGFzIGZvY3VzZWQuXG4gICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKG5vZGUgPT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgIXRoaXMuZG9tLmNvbnRhaW5zKG5vZGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICYmIHRoaXMuZG9tICE9IG5vZGUgJiYgdGhpcy5kb20uY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gJ2ZhbHNlJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5kb207XG4gICAgfVxuICAgIC8qKlxuICAgIEZvY3VzIHRoZSBlZGl0b3IuXG4gICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLmVkaXRhYmxlKVxuICAgICAgICAgICAgZm9jdXNQcmV2ZW50U2Nyb2xsKHRoaXMuZG9tKTtcbiAgICAgICAgc2VsZWN0aW9uVG9ET00odGhpcyk7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBkb2N1bWVudCByb290IGluIHdoaWNoIHRoZSBlZGl0b3IgZXhpc3RzLiBUaGlzIHdpbGxcbiAgICB1c3VhbGx5IGJlIHRoZSB0b3AtbGV2ZWwgYGRvY3VtZW50YCwgYnV0IG1pZ2h0IGJlIGEgW3NoYWRvd1xuICAgIERPTV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvV2ViX0NvbXBvbmVudHMvU2hhZG93X0RPTSlcbiAgICByb290IGlmIHRoZSBlZGl0b3IgaXMgaW5zaWRlIG9uZS5cbiAgICAqL1xuICAgIGdldCByb290KCkge1xuICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5fcm9vdDtcbiAgICAgICAgaWYgKGNhY2hlZCA9PSBudWxsKVxuICAgICAgICAgICAgZm9yIChsZXQgc2VhcmNoID0gdGhpcy5kb20ucGFyZW50Tm9kZTsgc2VhcmNoOyBzZWFyY2ggPSBzZWFyY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWFyY2gubm9kZVR5cGUgPT0gOSB8fCAoc2VhcmNoLm5vZGVUeXBlID09IDExICYmIHNlYXJjaC5ob3N0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlYXJjaC5nZXRTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2VhcmNoKS5nZXRTZWxlY3Rpb24gPSAoKSA9PiBzZWFyY2gub3duZXJEb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QgPSBzZWFyY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkIHx8IGRvY3VtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGVuIGFuIGV4aXN0aW5nIGVkaXRvciB2aWV3IGlzIG1vdmVkIHRvIGEgbmV3IGRvY3VtZW50IG9yXG4gICAgc2hhZG93IHRyZWUsIGNhbGwgdGhpcyB0byBtYWtlIGl0IHJlY29tcHV0ZSBpdHMgcm9vdC5cbiAgICAqL1xuICAgIHVwZGF0ZVJvb3QoKSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBHaXZlbiBhIHBhaXIgb2Ygdmlld3BvcnQgY29vcmRpbmF0ZXMsIHJldHVybiB0aGUgZG9jdW1lbnRcbiAgICBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZW0uIE1heSByZXR1cm4gbnVsbCBpZiB0aGUgZ2l2ZW5cbiAgICBjb29yZGluYXRlcyBhcmVuJ3QgaW5zaWRlIG9mIHRoZSBlZGl0b3IuIFdoZW4gYW4gb2JqZWN0IGlzXG4gICAgcmV0dXJuZWQsIGl0cyBgcG9zYCBwcm9wZXJ0eSBpcyB0aGUgcG9zaXRpb24gbmVhcmVzdCB0byB0aGVcbiAgICBjb29yZGluYXRlcywgYW5kIGl0cyBgaW5zaWRlYCBwcm9wZXJ0eSBob2xkcyB0aGUgcG9zaXRpb24gb2YgdGhlXG4gICAgaW5uZXIgbm9kZSB0aGF0IHRoZSBwb3NpdGlvbiBmYWxscyBpbnNpZGUgb2YsIG9yIC0xIGlmIGl0IGlzIGF0XG4gICAgdGhlIHRvcCBsZXZlbCwgbm90IGluIGFueSBub2RlLlxuICAgICovXG4gICAgcG9zQXRDb29yZHMoY29vcmRzKSB7XG4gICAgICAgIHJldHVybiBwb3NBdENvb3Jkcyh0aGlzLCBjb29yZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSB2aWV3cG9ydCByZWN0YW5nbGUgYXQgYSBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICBgbGVmdGAgYW5kIGByaWdodGAgd2lsbCBiZSB0aGUgc2FtZSBudW1iZXIsIGFzIHRoaXMgcmV0dXJucyBhXG4gICAgZmxhdCBjdXJzb3ItaXNoIHJlY3RhbmdsZS4gSWYgdGhlIHBvc2l0aW9uIGlzIGJldHdlZW4gdHdvIHRoaW5nc1xuICAgIHRoYXQgYXJlbid0IGRpcmVjdGx5IGFkamFjZW50LCBgc2lkZWAgZGV0ZXJtaW5lcyB3aGljaCBlbGVtZW50XG4gICAgaXMgdXNlZC4gV2hlbiA8IDAsIHRoZSBlbGVtZW50IGJlZm9yZSB0aGUgcG9zaXRpb24gaXMgdXNlZCxcbiAgICBvdGhlcndpc2UgdGhlIGVsZW1lbnQgYWZ0ZXIuXG4gICAgKi9cbiAgICBjb29yZHNBdFBvcyhwb3MsIHNpZGUgPSAxKSB7XG4gICAgICAgIHJldHVybiBjb29yZHNBdFBvcyh0aGlzLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAgICBwb3NpdGlvbi4gV2hlbiBgc2lkZWAgaXMgbmVnYXRpdmUsIGZpbmQgdGhlIHBvc2l0aW9uIGFzIGNsb3NlIGFzXG4gICAgcG9zc2libGUgdG8gdGhlIGNvbnRlbnQgYmVmb3JlIHRoZSBwb3NpdGlvbi4gV2hlbiBwb3NpdGl2ZSxcbiAgICBwcmVmZXIgcG9zaXRpb25zIGNsb3NlIHRvIHRoZSBjb250ZW50IGFmdGVyIHRoZSBwb3NpdGlvbi4gV2hlblxuICAgIHplcm8sIHByZWZlciBhcyBzaGFsbG93IGEgcG9zaXRpb24gYXMgcG9zc2libGUuXG4gICAgXG4gICAgTm90ZSB0aGF0IHlvdSBzaG91bGQgKipub3QqKiBtdXRhdGUgdGhlIGVkaXRvcidzIGludGVybmFsIERPTSxcbiAgICBvbmx5IGluc3BlY3QgaXQgKGFuZCBldmVuIHRoYXQgaXMgdXN1YWxseSBub3QgbmVjZXNzYXJ5KS5cbiAgICAqL1xuICAgIGRvbUF0UG9zKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBub2RlIHRoYXQgcmVwcmVzZW50cyB0aGUgZG9jdW1lbnQgbm9kZSBhZnRlciB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbi4gTWF5IHJldHVybiBgbnVsbGAgd2hlbiB0aGUgcG9zaXRpb24gZG9lc24ndCBwb2ludFxuICAgIGluIGZyb250IG9mIGEgbm9kZSBvciBpZiB0aGUgbm9kZSBpcyBpbnNpZGUgYW4gb3BhcXVlIG5vZGUgdmlldy5cbiAgICBcbiAgICBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGFibGUgdG8gY2FsbCB0aGluZ3MgbGlrZVxuICAgIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIG9uIHRoYXQgRE9NIG5vZGUuIERvICoqbm90KiogbXV0YXRlIHRoZVxuICAgIGVkaXRvciBET00gZGlyZWN0bHksIG9yIGFkZCBzdHlsaW5nIHRoaXMgd2F5LCBzaW5jZSB0aGF0IHdpbGwgYmVcbiAgICBpbW1lZGlhdGVseSBvdmVycmlkZW4gYnkgdGhlIGVkaXRvciBhcyBpdCByZWRyYXdzIHRoZSBub2RlLlxuICAgICovXG4gICAgbm9kZURPTShwb3MpIHtcbiAgICAgICAgbGV0IGRlc2MgPSB0aGlzLmRvY1ZpZXcuZGVzY0F0KHBvcyk7XG4gICAgICAgIHJldHVybiBkZXNjID8gZGVzYy5ub2RlRE9NIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZG9jdW1lbnQgcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byBhIGdpdmVuIERPTVxuICAgIHBvc2l0aW9uLiAoV2hlbmV2ZXIgcG9zc2libGUsIGl0IGlzIHByZWZlcmFibGUgdG8gaW5zcGVjdCB0aGVcbiAgICBkb2N1bWVudCBzdHJ1Y3R1cmUgZGlyZWN0bHksIHJhdGhlciB0aGFuIHBva2luZyBhcm91bmQgaW4gdGhlXG4gICAgRE9NLCBidXQgc29tZXRpbWVz4oCUZm9yIGV4YW1wbGUgd2hlbiBpbnRlcnByZXRpbmcgYW4gZXZlbnRcbiAgICB0YXJnZXTigJR5b3UgZG9uJ3QgaGF2ZSBhIGNob2ljZS4pXG4gICAgXG4gICAgVGhlIGBiaWFzYCBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgdG8gaW5mbHVlbmNlIHdoaWNoIHNpZGUgb2YgYSBET01cbiAgICBub2RlIHRvIHVzZSB3aGVuIHRoZSBwb3NpdGlvbiBpcyBpbnNpZGUgYSBsZWFmIG5vZGUuXG4gICAgKi9cbiAgICBwb3NBdERPTShub2RlLCBvZmZzZXQsIGJpYXMgPSAtMSkge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCBiaWFzKTtcbiAgICAgICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJET00gcG9zaXRpb24gbm90IGluc2lkZSB0aGUgZWRpdG9yXCIpO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIG91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jayB3aGVuXG4gICAgbW92aW5nIGluIGEgZ2l2ZW4gZGlyZWN0aW9uLiBXaGVuLCBmb3IgZXhhbXBsZSwgZ2l2ZW4gYFwibGVmdFwiYCxcbiAgICBpdCB3aWxsIHJldHVybiB0cnVlIGlmIG1vdmluZyBsZWZ0IGZyb20gdGhlIGN1cnJlbnQgY3Vyc29yXG4gICAgcG9zaXRpb24gd291bGQgbGVhdmUgdGhhdCBwb3NpdGlvbidzIHBhcmVudCB0ZXh0YmxvY2suIFdpbGwgYXBwbHlcbiAgICB0byB0aGUgdmlldydzIGN1cnJlbnQgc3RhdGUgYnkgZGVmYXVsdCwgYnV0IGl0IGlzIHBvc3NpYmxlIHRvXG4gICAgcGFzcyBhIGRpZmZlcmVudCBzdGF0ZS5cbiAgICAqL1xuICAgIGVuZE9mVGV4dGJsb2NrKGRpciwgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGVuZE9mVGV4dGJsb2NrKHRoaXMsIHN0YXRlIHx8IHRoaXMuc3RhdGUsIGRpcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFJ1biB0aGUgZWRpdG9yJ3MgcGFzdGUgbG9naWMgd2l0aCB0aGUgZ2l2ZW4gSFRNTCBzdHJpbmcuIFRoZVxuICAgIGBldmVudGAsIGlmIGdpdmVuLCB3aWxsIGJlIHBhc3NlZCB0byB0aGVcbiAgICBbYGhhbmRsZVBhc3RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMuaGFuZGxlUGFzdGUpIGhvb2suXG4gICAgKi9cbiAgICBwYXN0ZUhUTUwoaHRtbCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFzdGUodGhpcywgXCJcIiwgaHRtbCwgZmFsc2UsIGV2ZW50IHx8IG5ldyBDbGlwYm9hcmRFdmVudChcInBhc3RlXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUnVuIHRoZSBlZGl0b3IncyBwYXN0ZSBsb2dpYyB3aXRoIHRoZSBnaXZlbiBwbGFpbi10ZXh0IGlucHV0LlxuICAgICovXG4gICAgcGFzdGVUZXh0KHRleHQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkb1Bhc3RlKHRoaXMsIHRleHQsIG51bGwsIHRydWUsIGV2ZW50IHx8IG5ldyBDbGlwYm9hcmRFdmVudChcInBhc3RlXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyB0aGUgZWRpdG9yIGZyb20gdGhlIERPTSBhbmQgZGVzdHJveXMgYWxsIFtub2RlXG4gICAgdmlld3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3Lk5vZGVWaWV3KS5cbiAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy5kb2NWaWV3KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZXN0cm95SW5wdXQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdHJveVBsdWdpblZpZXdzKCk7XG4gICAgICAgIGlmICh0aGlzLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGUodGhpcy5zdGF0ZS5kb2MsIFtdLCB2aWV3RGVjb3JhdGlvbnModGhpcyksIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kb20udGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgdHJ1ZSB3aGVuIHRoZSB2aWV3IGhhcyBiZWVuXG4gICAgW2Rlc3Ryb3llZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kZXN0cm95KSAoYW5kIHRodXMgc2hvdWxkIG5vdCBiZVxuICAgIHVzZWQgYW55bW9yZSkuXG4gICAgKi9cbiAgICBnZXQgaXNEZXN0cm95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcgPT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXNlZCBmb3IgdGVzdGluZy5cbiAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBEaXNwYXRjaCBhIHRyYW5zYWN0aW9uLiBXaWxsIGNhbGxcbiAgICBbYGRpc3BhdGNoVHJhbnNhY3Rpb25gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EaXJlY3RFZGl0b3JQcm9wcy5kaXNwYXRjaFRyYW5zYWN0aW9uKVxuICAgIHdoZW4gZ2l2ZW4sIGFuZCBvdGhlcndpc2UgZGVmYXVsdHMgdG8gYXBwbHlpbmcgdGhlIHRyYW5zYWN0aW9uIHRvXG4gICAgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGNhbGxpbmdcbiAgICBbYHVwZGF0ZVN0YXRlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy51cGRhdGVTdGF0ZSkgd2l0aCB0aGUgcmVzdWx0LlxuICAgIFRoaXMgbWV0aG9kIGlzIGJvdW5kIHRvIHRoZSB2aWV3IGluc3RhbmNlLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgIGVhc2lseSBwYXNzZWQgYXJvdW5kLlxuICAgICovXG4gICAgZGlzcGF0Y2godHIpIHtcbiAgICAgICAgbGV0IGRpc3BhdGNoVHJhbnNhY3Rpb24gPSB0aGlzLl9wcm9wcy5kaXNwYXRjaFRyYW5zYWN0aW9uO1xuICAgICAgICBpZiAoZGlzcGF0Y2hUcmFuc2FjdGlvbilcbiAgICAgICAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb24uY2FsbCh0aGlzLCB0cik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5zdGF0ZS5hcHBseSh0cikpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbVNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICByZXR1cm4gc2FmYXJpICYmIHRoaXMucm9vdC5ub2RlVHlwZSA9PT0gMTEgJiYgZGVlcEFjdGl2ZUVsZW1lbnQodGhpcy5kb20ub3duZXJEb2N1bWVudCkgPT0gdGhpcy5kb21cbiAgICAgICAgICAgID8gc2FmYXJpU2hhZG93U2VsZWN0aW9uUmFuZ2UodGhpcykgOiB0aGlzLmRvbVNlbGVjdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbVNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlRG9jRGVjbyh2aWV3KSB7XG4gICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBhdHRycy5jbGFzcyA9IFwiUHJvc2VNaXJyb3JcIjtcbiAgICBhdHRycy5jb250ZW50ZWRpdGFibGUgPSBTdHJpbmcodmlldy5lZGl0YWJsZSk7XG4gICAgdmlldy5zb21lUHJvcChcImF0dHJpYnV0ZXNcIiwgdmFsdWUgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUodmlldy5zdGF0ZSk7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIGZvciAobGV0IGF0dHIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ciA9PSBcImNsYXNzXCIpXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLmNsYXNzICs9IFwiIFwiICsgdmFsdWVbYXR0cl07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0ciA9PSBcInN0eWxlXCIpXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLnN0eWxlID0gKGF0dHJzLnN0eWxlID8gYXR0cnMuc3R5bGUgKyBcIjtcIiA6IFwiXCIpICsgdmFsdWVbYXR0cl07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWF0dHJzW2F0dHJdICYmIGF0dHIgIT0gXCJjb250ZW50ZWRpdGFibGVcIiAmJiBhdHRyICE9IFwibm9kZU5hbWVcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnNbYXR0cl0gPSBTdHJpbmcodmFsdWVbYXR0cl0pO1xuICAgICAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghYXR0cnMudHJhbnNsYXRlKVxuICAgICAgICBhdHRycy50cmFuc2xhdGUgPSBcIm5vXCI7XG4gICAgcmV0dXJuIFtEZWNvcmF0aW9uLm5vZGUoMCwgdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplLCBhdHRycyldO1xufVxuZnVuY3Rpb24gdXBkYXRlQ3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gICAgaWYgKHZpZXcubWFya0N1cnNvcikge1xuICAgICAgICBsZXQgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3Itc2VwYXJhdG9yXCI7XG4gICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJtYXJrLXBsYWNlaG9sZGVyXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcImFsdFwiLCBcIlwiKTtcbiAgICAgICAgdmlldy5jdXJzb3JXcmFwcGVyID0geyBkb20sIGRlY286IERlY29yYXRpb24ud2lkZ2V0KHZpZXcuc3RhdGUuc2VsZWN0aW9uLmhlYWQsIGRvbSwgeyByYXc6IHRydWUsIG1hcmtzOiB2aWV3Lm1hcmtDdXJzb3IgfSkgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuY3Vyc29yV3JhcHBlciA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RWRpdGFibGUodmlldykge1xuICAgIHJldHVybiAhdmlldy5zb21lUHJvcChcImVkaXRhYmxlXCIsIHZhbHVlID0+IHZhbHVlKHZpZXcuc3RhdGUpID09PSBmYWxzZSk7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Db250ZXh0Q2hhbmdlZChzZWwxLCBzZWwyKSB7XG4gICAgbGV0IGRlcHRoID0gTWF0aC5taW4oc2VsMS4kYW5jaG9yLnNoYXJlZERlcHRoKHNlbDEuaGVhZCksIHNlbDIuJGFuY2hvci5zaGFyZWREZXB0aChzZWwyLmhlYWQpKTtcbiAgICByZXR1cm4gc2VsMS4kYW5jaG9yLnN0YXJ0KGRlcHRoKSAhPSBzZWwyLiRhbmNob3Iuc3RhcnQoZGVwdGgpO1xufVxuZnVuY3Rpb24gYnVpbGROb2RlVmlld3Modmlldykge1xuICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZ1bmN0aW9uIGFkZChvYmopIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBvYmopXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIHByb3ApKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICB9XG4gICAgdmlldy5zb21lUHJvcChcIm5vZGVWaWV3c1wiLCBhZGQpO1xuICAgIHZpZXcuc29tZVByb3AoXCJtYXJrVmlld3NcIiwgYWRkKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2hhbmdlZE5vZGVWaWV3cyhhLCBiKSB7XG4gICAgbGV0IG5BID0gMCwgbkIgPSAwO1xuICAgIGZvciAobGV0IHByb3AgaW4gYSkge1xuICAgICAgICBpZiAoYVtwcm9wXSAhPSBiW3Byb3BdKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIG5BKys7XG4gICAgfVxuICAgIGZvciAobGV0IF8gaW4gYilcbiAgICAgICAgbkIrKztcbiAgICByZXR1cm4gbkEgIT0gbkI7XG59XG5mdW5jdGlvbiBjaGVja1N0YXRlQ29tcG9uZW50KHBsdWdpbikge1xuICAgIGlmIChwbHVnaW4uc3BlYy5zdGF0ZSB8fCBwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbiB8fCBwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJQbHVnaW5zIHBhc3NlZCBkaXJlY3RseSB0byB0aGUgdmlldyBtdXN0IG5vdCBoYXZlIGEgc3RhdGUgY29tcG9uZW50XCIpO1xufVxuXG5leHBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0LCBFZGl0b3JWaWV3LCBfX2VuZENvbXBvc2l0aW9uLCBfX3BhcnNlRnJvbUNsaXBib2FyZCwgX19zZXJpYWxpemVGb3JDbGlwYm9hcmQgfTtcbiJdLCJuYW1lcyI6WyJUZXh0U2VsZWN0aW9uIiwiTm9kZVNlbGVjdGlvbiIsIkFsbFNlbGVjdGlvbiIsIlNlbGVjdGlvbiIsIkRPTVNlcmlhbGl6ZXIiLCJGcmFnbWVudCIsIk1hcmsiLCJTbGljZSIsIkRPTVBhcnNlciIsImRyb3BQb2ludCIsImRvbUluZGV4Iiwibm9kZSIsImluZGV4IiwicHJldmlvdXNTaWJsaW5nIiwicGFyZW50Tm9kZSIsInBhcmVudCIsImFzc2lnbmVkU2xvdCIsIm5vZGVUeXBlIiwiaG9zdCIsInJldXNlZFJhbmdlIiwidGV4dFJhbmdlIiwiZnJvbSIsInRvIiwicmFuZ2UiLCJkb2N1bWVudCIsImNyZWF0ZVJhbmdlIiwic2V0RW5kIiwibm9kZVZhbHVlIiwibGVuZ3RoIiwic2V0U3RhcnQiLCJpc0VxdWl2YWxlbnRQb3NpdGlvbiIsIm9mZiIsInRhcmdldE5vZGUiLCJ0YXJnZXRPZmYiLCJzY2FuRm9yIiwiYXRvbUVsZW1lbnRzIiwiZGlyIiwibm9kZVNpemUiLCJoYXNCbG9ja0Rlc2MiLCJ0ZXN0Iiwibm9kZU5hbWUiLCJjb250ZW50RWRpdGFibGUiLCJjaGlsZE5vZGVzIiwiaXNPbkVkZ2UiLCJvZmZzZXQiLCJhdFN0YXJ0IiwiYXRFbmQiLCJkb20iLCJkZXNjIiwiY3VyIiwicG1WaWV3RGVzYyIsImlzQmxvY2siLCJjb250ZW50RE9NIiwic2VsZWN0aW9uQ29sbGFwc2VkIiwiZG9tU2VsIiwiZm9jdXNOb2RlIiwiZm9jdXNPZmZzZXQiLCJhbmNob3JOb2RlIiwiYW5jaG9yT2Zmc2V0Iiwia2V5RXZlbnQiLCJrZXlDb2RlIiwia2V5IiwiZXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImNvZGUiLCJkZWVwQWN0aXZlRWxlbWVudCIsImRvYyIsImVsdCIsImFjdGl2ZUVsZW1lbnQiLCJzaGFkb3dSb290IiwiY2FyZXRGcm9tUG9pbnQiLCJ4IiwieSIsImNhcmV0UG9zaXRpb25Gcm9tUG9pbnQiLCJwb3MiLCJvZmZzZXROb2RlIiwiXyIsImNhcmV0UmFuZ2VGcm9tUG9pbnQiLCJzdGFydENvbnRhaW5lciIsInN0YXJ0T2Zmc2V0IiwibmF2IiwibmF2aWdhdG9yIiwiYWdlbnQiLCJ1c2VyQWdlbnQiLCJpZV9lZGdlIiwiZXhlYyIsImllX3VwdG8xMCIsImllXzExdXAiLCJpZSIsImllX3ZlcnNpb24iLCJkb2N1bWVudE1vZGUiLCJnZWNrbyIsIl9jaHJvbWUiLCJjaHJvbWUiLCJjaHJvbWVfdmVyc2lvbiIsInNhZmFyaSIsInZlbmRvciIsImlvcyIsIm1heFRvdWNoUG9pbnRzIiwibWFjIiwicGxhdGZvcm0iLCJ3aW5kb3dzIiwiYW5kcm9pZCIsIndlYmtpdCIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwid2Via2l0X3ZlcnNpb24iLCJ3aW5kb3dSZWN0IiwibGVmdCIsInJpZ2h0IiwiY2xpZW50V2lkdGgiLCJ0b3AiLCJib3R0b20iLCJjbGllbnRIZWlnaHQiLCJnZXRTaWRlIiwidmFsdWUiLCJzaWRlIiwiY2xpZW50UmVjdCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzY2FsZVgiLCJ3aWR0aCIsIm9mZnNldFdpZHRoIiwic2NhbGVZIiwiaGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsUmVjdEludG9WaWV3IiwidmlldyIsInN0YXJ0RE9NIiwic2Nyb2xsVGhyZXNob2xkIiwic29tZVByb3AiLCJzY3JvbGxNYXJnaW4iLCJvd25lckRvY3VtZW50IiwiYXRUb3AiLCJib2R5IiwiYm91bmRpbmciLCJtb3ZlWCIsIm1vdmVZIiwiZGVmYXVsdFZpZXciLCJzY3JvbGxCeSIsInN0YXJ0WCIsInNjcm9sbExlZnQiLCJzdGFydFkiLCJzY3JvbGxUb3AiLCJkWCIsImRZIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInBvc2l0aW9uIiwic3RvcmVTY3JvbGxQb3MiLCJNYXRoIiwibWF4IiwicmVmRE9NIiwicmVmVG9wIiwibWluIiwiaW5uZXJIZWlnaHQiLCJyb290IiwiZWxlbWVudEZyb21Qb2ludCIsImNvbnRhaW5zIiwibG9jYWxSZWN0Iiwic3RhY2siLCJzY3JvbGxTdGFjayIsInB1c2giLCJyZXNldFNjcm9sbFBvcyIsIm5ld1JlZlRvcCIsInJlc3RvcmVTY3JvbGxTdGFjayIsImRUb3AiLCJpIiwicHJldmVudFNjcm9sbFN1cHBvcnRlZCIsImZvY3VzUHJldmVudFNjcm9sbCIsInNldEFjdGl2ZSIsImZvY3VzIiwic3RvcmVkIiwicHJldmVudFNjcm9sbCIsInVuZGVmaW5lZCIsImZpbmRPZmZzZXRJbk5vZGUiLCJjb29yZHMiLCJjbG9zZXN0IiwiZHhDbG9zZXN0IiwiY29vcmRzQ2xvc2VzdCIsInJvd0JvdCIsInJvd1RvcCIsImZpcnN0QmVsb3ciLCJjb29yZHNCZWxvdyIsImNoaWxkIiwiZmlyc3RDaGlsZCIsImNoaWxkSW5kZXgiLCJuZXh0U2libGluZyIsInJlY3RzIiwiZ2V0Q2xpZW50UmVjdHMiLCJkeCIsImZpbmRPZmZzZXRJblRleHQiLCJsZW4iLCJzaW5nbGVSZWN0IiwiaW5SZWN0IiwidGFyZ2V0S2x1ZGdlIiwicG9zRnJvbUVsZW1lbnQiLCJiaWFzIiwiZG9jVmlldyIsInBvc0Zyb21ET00iLCJwb3NGcm9tQ2FyZXQiLCJvdXRzaWRlQmxvY2siLCJzYXdCbG9jayIsIm5lYXJlc3REZXNjIiwicG9zQmVmb3JlIiwicG9zQWZ0ZXIiLCJpc1RleHQiLCJiZWZvcmUiLCJlbGVtZW50IiwiYm94Iiwic3RhcnRJIiwiZmxvb3IiLCJqIiwicG9zQXRDb29yZHMiLCJjYXJldCIsInAiLCJkcmFnZ2FibGUiLCJuZXh0IiwicHJldiIsImxhc3RDaGlsZCIsInN0YXRlIiwiY29udGVudCIsInNpemUiLCJpbnNpZGUiLCJwb3NBdFN0YXJ0IiwiYm9yZGVyIiwibm9uWmVybyIsInRhcmdldCIsImZpcnN0IiwiQXJyYXkiLCJwcm90b3R5cGUiLCJmaW5kIiwiY2FsbCIsIkJJREkiLCJjb29yZHNBdFBvcyIsImF0b20iLCJkb21Gcm9tUG9zIiwic3VwcG9ydEVtcHR5UmFuZ2UiLCJyZWN0QmVmb3JlIiwicmVjdEFmdGVyIiwiZmxhdHRlblYiLCJ0YWtlU2lkZSIsIiRkb20iLCJyZXNvbHZlIiwiaW5saW5lQ29udGVudCIsImZsYXR0ZW5IIiwiYWZ0ZXIiLCJpZ25vcmVGb3JDb29yZHMiLCJ3aXRoRmx1c2hlZFN0YXRlIiwiZiIsInZpZXdTdGF0ZSIsImFjdGl2ZSIsInVwZGF0ZVN0YXRlIiwiZW5kT2ZUZXh0YmxvY2tWZXJ0aWNhbCIsInNlbCIsInNlbGVjdGlvbiIsIiRwb3MiLCIkZnJvbSIsIiR0byIsIm5lYXJlc3QiLCJib3hlcyIsIm1heWJlUlRMIiwiZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsIiwiJGhlYWQiLCJpc1RleHRibG9jayIsInBhcmVudE9mZnNldCIsImRvbVNlbGVjdGlvbiIsInRleHRDb250ZW50IiwibW9kaWZ5Iiwib2xkTm9kZSIsIm9sZE9mZiIsImRvbVNlbGVjdGlvblJhbmdlIiwib2xkQmlkaUxldmVsIiwiY2FyZXRCaWRpTGV2ZWwiLCJwYXJlbnRET00iLCJkZXB0aCIsImRvbUFmdGVyUG9zIiwibmV3Tm9kZSIsIm5ld09mZiIsInJlc3VsdCIsImNvbGxhcHNlIiwiZXh0ZW5kIiwiY2FjaGVkU3RhdGUiLCJjYWNoZWREaXIiLCJjYWNoZWRSZXN1bHQiLCJlbmRPZlRleHRibG9jayIsIk5PVF9ESVJUWSIsIkNISUxEX0RJUlRZIiwiQ09OVEVOVF9ESVJUWSIsIk5PREVfRElSVFkiLCJWaWV3RGVzYyIsImNvbnN0cnVjdG9yIiwiY2hpbGRyZW4iLCJkaXJ0eSIsIm1hdGNoZXNXaWRnZXQiLCJ3aWRnZXQiLCJtYXRjaGVzTWFyayIsIm1hcmsiLCJtYXRjaGVzTm9kZSIsIm91dGVyRGVjbyIsImlubmVyRGVjbyIsIm1hdGNoZXNIYWNrIiwicGFyc2VSdWxlIiwic3RvcEV2ZW50IiwiZGVzdHJveSIsInBvc0JlZm9yZUNoaWxkIiwicG9zQXRFbmQiLCJsb2NhbFBvc0Zyb21ET00iLCJkb21CZWZvcmUiLCJkb21BZnRlciIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwic2VhcmNoIiwib25seU5vZGVzIiwiZ2V0RGVzYyIsIm5vZGVET00iLCJzY2FuIiwiZGVzY0F0IiwiZW5kIiwiY3VyUG9zIiwiVHJhaWxpbmdIYWNrVmlld0Rlc2MiLCJXaWRnZXRWaWV3RGVzYyIsImVudGVyIiwiZG9tQXRvbSIsInBhcnNlUmFuZ2UiLCJiYXNlIiwiZnJvbU9mZnNldCIsInRvT2Zmc2V0IiwiY2hpbGRCYXNlIiwiZW1wdHlDaGlsZEF0IiwiUmFuZ2VFcnJvciIsInNldFNlbGVjdGlvbiIsImFuY2hvciIsImhlYWQiLCJmb3JjZSIsImFuY2hvckRPTSIsImhlYWRET00iLCJnZXRTZWxlY3Rpb24iLCJicktsdWRnZSIsImRvbVNlbEV4dGVuZGVkIiwidG1wIiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJpZ25vcmVNdXRhdGlvbiIsIm11dGF0aW9uIiwidHlwZSIsImNvbnRlbnRMb3N0IiwibWFya0RpcnR5Iiwic3RhcnRJbnNpZGUiLCJlbmRJbnNpZGUiLCJtYXJrUGFyZW50c0RpcnR5IiwibGV2ZWwiLCJzZWxmIiwidG9ET00iLCJzcGVjIiwicmF3Iiwid3JhcCIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsImNsYXNzTGlzdCIsImFkZCIsImVxIiwiaWdub3JlIiwic3RvcCIsImlnbm9yZVNlbGVjdGlvbiIsIkNvbXBvc2l0aW9uVmlld0Rlc2MiLCJ0ZXh0RE9NIiwidGV4dCIsIm11dCIsIm9sZFZhbHVlIiwiTWFya1ZpZXdEZXNjIiwiY3JlYXRlIiwiaW5saW5lIiwiY3VzdG9tIiwibm9kZVZpZXdzIiwibmFtZSIsInJlbmRlclNwZWMiLCJyZXBhcnNlSW5WaWV3IiwiYXR0cnMiLCJjb250ZW50RWxlbWVudCIsInNsaWNlIiwiY29weSIsIm5vZGVzIiwicmVwbGFjZU5vZGVzIiwiTm9kZVZpZXdEZXNjIiwiZGVzY09iaiIsImNyZWF0ZVRleHROb2RlIiwiaGFzQXR0cmlidXRlIiwiYXBwbHlPdXRlckRlY28iLCJDdXN0b21Ob2RlVmlld0Rlc2MiLCJUZXh0Vmlld0Rlc2MiLCJydWxlIiwid2hpdGVzcGFjZSIsInByZXNlcnZlV2hpdGVzcGFjZSIsImdldENvbnRlbnQiLCJlbXB0eSIsInNhbWVPdXRlckRlY28iLCJpc0xlYWYiLCJ1cGRhdGVDaGlsZHJlbiIsImNvbXBvc2l0aW9uIiwiY29tcG9zaW5nIiwibG9jYWxDb21wb3NpdGlvbkluZm8iLCJsb2NhbENvbXBvc2l0aW9uIiwiY29tcG9zaXRpb25JbkNoaWxkIiwidXBkYXRlciIsIlZpZXdUcmVlVXBkYXRlciIsIml0ZXJEZWNvIiwiaW5zaWRlTm9kZSIsIm1hcmtzIiwic3luY1RvTWFya3MiLCJjaGlsZENvdW50Iiwibm9uZSIsInBsYWNlV2lkZ2V0IiwiY29tcEluZGV4IiwiZmluZE5vZGVNYXRjaCIsImZpbmRJbmRleFdpdGhDaGlsZCIsInVwZGF0ZU5vZGVBdCIsInVwZGF0ZU5leHROb2RlIiwiYWRkTm9kZSIsImFkZFRleHRibG9ja0hhY2tzIiwiZGVzdHJveVJlc3QiLCJjaGFuZ2VkIiwicHJvdGVjdExvY2FsQ29tcG9zaXRpb24iLCJyZW5kZXJEZXNjcyIsImlvc0hhY2tzIiwidGV4dE5vZGUiLCJuZWFyYnlUZXh0Tm9kZSIsInRleHRQb3MiLCJmaW5kVGV4dEluRnJhZ21lbnQiLCJ0b3BOb2RlIiwicmVtb3ZlQ2hpbGQiLCJpbnB1dCIsImNvbXBvc2l0aW9uTm9kZXMiLCJ1cGRhdGUiLCJzYW1lTWFya3VwIiwidXBkYXRlSW5uZXIiLCJ1cGRhdGVPdXRlckRlY28iLCJuZWVkc1dyYXAiLCJvbGRET00iLCJwYXRjaE91dGVyRGVjbyIsImNvbXB1dGVPdXRlckRlY28iLCJzZWxlY3ROb2RlIiwiZGVzZWxlY3ROb2RlIiwicmVtb3ZlIiwicmVtb3ZlQXR0cmlidXRlIiwiaXNBdG9tIiwiZG9jVmlld0Rlc2MiLCJza2lwIiwicG1Jc0RlY28iLCJpblBhcmVudCIsInRyYWNrV3JpdGVzIiwibiIsImN1dCIsImRlc2NzIiwid3JpdHRlbiIsImNoaWxkRE9NIiwicm0iLCJpbnNlcnRCZWZvcmUiLCJPdXRlckRlY29MZXZlbCIsIk9iamVjdCIsIm5vRGVjbyIsInZhbCIsImlzSW5saW5lIiwiY2xhc3MiLCJvdXRlckRPTSIsInByZXZDb21wdXRlZCIsImN1ckNvbXB1dGVkIiwiY3VyRE9NIiwiZGVjbyIsInRvTG93ZXJDYXNlIiwicGF0Y2hBdHRyaWJ1dGVzIiwic2V0QXR0cmlidXRlIiwicHJldkxpc3QiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJjdXJMaXN0IiwiaW5kZXhPZiIsInByb3AiLCJtIiwicmVtb3ZlUHJvcGVydHkiLCJjc3NUZXh0IiwiYSIsImIiLCJsb2NrIiwicHJlTWF0Y2giLCJkZXN0cm95QmV0d2VlbiIsInN0YXJ0Iiwic3BsaWNlIiwia2VlcCIsIm1heEtlZXAiLCJzcGFubmluZyIsInBvcCIsImZvdW5kIiwiaXNMb2NrZWQiLCJtYXJrRGVzYyIsInRhcmdldERlc2MiLCJtYXRjaGVzIiwiZSIsIm1hdGNoZWQiLCJoYXMiLCJkb21Ob2RlIiwiZ2V0IiwibmV4dERPTSIsInVwZGF0ZWQiLCJsb2NrZWQiLCJyZWNyZWF0ZVdyYXBwZXIiLCJ3cmFwcGVyIiwiY2giLCJyZXF1aXJlc0dlY2tvSGFja05vZGUiLCJhZGRIYWNrTm9kZSIsImNsYXNzTmFtZSIsImFsdCIsImhhY2siLCJmcmFnIiwicGFyZW50RGVzYyIsImN1ckRlc2MiLCJkZXNjSSIsImZJIiwiTWFwIiwib3V0ZXIiLCJzZXQiLCJyZXZlcnNlIiwiY29tcGFyZVNpZGUiLCJvbldpZGdldCIsIm9uTm9kZSIsImxvY2FscyIsImZvckNoaWxkIiwiZGVjb0luZGV4IiwicmVzdE5vZGUiLCJwYXJlbnRJbmRleCIsIndpZGdldHMiLCJzb3J0IiwiY3V0QXQiLCJkIiwib2xkQ1NTIiwid2luZG93IiwibGlzdFN0eWxlIiwiY2hpbGRTdGFydCIsInN0ciIsImxhc3RJbmRleE9mIiwicmVwbGFjZW1lbnQiLCJzZWxlY3Rpb25Gcm9tRE9NIiwib3JpZ2luIiwiaW5XaWRnZXQiLCIkYW5jaG9yIiwibmVhcmVzdERlc2NOb2RlIiwiaXNTZWxlY3RhYmxlIiwic2VsZWN0aW9uQmV0d2VlbiIsImVkaXRvck93bnNTZWxlY3Rpb24iLCJlZGl0YWJsZSIsImhhc0ZvY3VzIiwiaGFzU2VsZWN0aW9uIiwic2VsZWN0aW9uVG9ET00iLCJzeW5jTm9kZVNlbGVjdGlvbiIsIm1vdXNlRG93biIsImFsbG93RGVmYXVsdCIsImN1clNlbCIsImRvbU9ic2VydmVyIiwiY3VycmVudFNlbGVjdGlvbiIsImRlbGF5ZWRTZWxlY3Rpb25TeW5jIiwic2V0Q3VyU2VsZWN0aW9uIiwiZGlzY29ubmVjdFNlbGVjdGlvbiIsImN1cnNvcldyYXBwZXIiLCJzZWxlY3RDdXJzb3JXcmFwcGVyIiwicmVzZXRFZGl0YWJsZUZyb20iLCJyZXNldEVkaXRhYmxlVG8iLCJicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSIsInRlbXBvcmFyaWx5RWRpdGFibGVOZWFyIiwicmVzZXRFZGl0YWJsZSIsInZpc2libGUiLCJyZW1vdmVDbGFzc09uU2VsZWN0aW9uQ2hhbmdlIiwiY29ubmVjdFNlbGVjdGlvbiIsInNldEVkaXRhYmxlIiwid2FzRHJhZ2dhYmxlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhpZGVTZWxlY3Rpb25HdWFyZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzZXRUaW1lb3V0IiwiaW1nIiwiZGlzYWJsZWQiLCJsYXN0U2VsZWN0ZWRWaWV3RGVzYyIsImNsZWFyTm9kZVNlbGVjdGlvbiIsImJldHdlZW4iLCJoYXNGb2N1c0FuZFNlbGVjdGlvbiIsImFuY2hvckluUmlnaHRQbGFjZSIsIm1vdmVTZWxlY3Rpb25CbG9jayIsIiRzaWRlIiwiJHN0YXJ0IiwiZmluZEZyb20iLCJhcHBseSIsImRpc3BhdGNoIiwidHIiLCJzY3JvbGxJbnRvVmlldyIsInNlbGVjdEhvcml6b250YWxseSIsIm1vZHMiLCJ0ZXh0T2Zmc2V0Iiwibm9kZUJlZm9yZSIsIm5vZGVBZnRlciIsIiRuZXdIZWFkIiwibm9kZVBvcyIsIm5vZGVMZW4iLCJpc0lnbm9yYWJsZSIsInNraXBJZ25vcmVkTm9kZXMiLCJza2lwSWdub3JlZE5vZGVzQmVmb3JlIiwic2tpcElnbm9yZWROb2Rlc0FmdGVyIiwibW92ZU5vZGUiLCJtb3ZlT2Zmc2V0IiwiaXNCbG9ja05vZGUiLCJzZXRTZWxGb2N1cyIsInRleHROb2RlQWZ0ZXIiLCJ0ZXh0Tm9kZUJlZm9yZSIsImZpbmREaXJlY3Rpb24iLCJtaWQiLCJhYnMiLCJjb21wdXRlZCIsImRpcmVjdGlvbiIsInNlbGVjdFZlcnRpY2FsbHkiLCJiZXlvbmQiLCJuZWFyIiwic3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUiLCJzYW1lUGFyZW50IiwibmV4dE5vZGUiLCJkZWxldGUiLCJzd2l0Y2hFZGl0YWJsZSIsInNhZmFyaURvd25BcnJvd0J1ZyIsImdldE1vZHMiLCJjdHJsS2V5IiwibWV0YUtleSIsImFsdEtleSIsInNoaWZ0S2V5IiwiY2FwdHVyZUtleURvd24iLCJzZXJpYWxpemVGb3JDbGlwYm9hcmQiLCJjb250ZXh0Iiwib3BlblN0YXJ0Iiwib3BlbkVuZCIsImRlZmF1bHRBdHRycyIsInNlcmlhbGl6ZXIiLCJmcm9tU2NoZW1hIiwic2NoZW1hIiwiZGV0YWNoZWREb2MiLCJzZXJpYWxpemVGcmFnbWVudCIsIndyYXBwZXJzIiwid3JhcE1hcCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0ZXh0QmV0d2VlbiIsInBhcnNlRnJvbUNsaXBib2FyZCIsImh0bWwiLCJwbGFpblRleHQiLCIkY29udGV4dCIsImluQ29kZSIsImFzVGV4dCIsInJlcGxhY2UiLCJwYXJzZWQiLCJmb3JFYWNoIiwiYmxvY2siLCJzZXJpYWxpemVOb2RlIiwicmVhZEhUTUwiLCJyZXN0b3JlUmVwbGFjZWRTcGFjZXMiLCJjb250ZXh0Tm9kZSIsInF1ZXJ5U2VsZWN0b3IiLCJzbGljZURhdGEiLCJnZXRBdHRyaWJ1dGUiLCJwYXJzZXIiLCJwYXJzZVNsaWNlIiwicnVsZUZyb21Ob2RlIiwiaW5saW5lUGFyZW50cyIsImFkZENvbnRleHQiLCJjbG9zZVNsaWNlIiwibWF4T3BlbiIsIm5vcm1hbGl6ZVNpYmxpbmdzIiwiaXNvbGF0aW5nIiwiZnJhZ21lbnQiLCJtYXRjaCIsImNvbnRlbnRNYXRjaEF0IiwibGFzdFdyYXAiLCJmaW5kV3JhcHBpbmciLCJpbkxhc3QiLCJhZGRUb1NpYmxpbmciLCJjbG9zZVJpZ2h0Iiwid3JhcHBlZCIsIndpdGhXcmFwcGVycyIsIm1hdGNoVHlwZSIsInNpYmxpbmciLCJpbm5lciIsInJlcGxhY2VDaGlsZCIsImFwcGVuZCIsImZpbGwiLCJmaWxsQmVmb3JlIiwiY2xvc2VSYW5nZSIsInRoZWFkIiwidGJvZHkiLCJ0Zm9vdCIsImNhcHRpb24iLCJjb2xncm91cCIsImNvbCIsInRkIiwidGgiLCJfZGV0YWNoZWREb2MiLCJpbXBsZW1lbnRhdGlvbiIsImNyZWF0ZUhUTUxEb2N1bWVudCIsIm1ldGFzIiwiZmlyc3RUYWciLCJtYXAiLCJqb2luIiwiaW5uZXJIVE1MIiwicXVlcnlTZWxlY3RvckFsbCIsImFycmF5IiwicGFyc2UiLCJoYXNSZXF1aXJlZEF0dHJzIiwiaGFuZGxlcnMiLCJlZGl0SGFuZGxlcnMiLCJwYXNzaXZlSGFuZGxlcnMiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwiSW5wdXRTdGF0ZSIsImxhc3RLZXlDb2RlIiwibGFzdEtleUNvZGVUaW1lIiwibGFzdENsaWNrIiwidGltZSIsImxhc3RTZWxlY3Rpb25PcmlnaW4iLCJsYXN0U2VsZWN0aW9uVGltZSIsImxhc3RJT1NFbnRlciIsImxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCIsImxhc3RGb2N1cyIsImxhc3RUb3VjaCIsImxhc3RBbmRyb2lkRGVsZXRlIiwiY29tcG9zaW5nVGltZW91dCIsImNvbXBvc2l0aW9uRW5kZWRBdCIsImNvbXBvc2l0aW9uSUQiLCJjb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzIiwiZG9tQ2hhbmdlQ291bnQiLCJldmVudEhhbmRsZXJzIiwiaW5pdElucHV0IiwiaGFuZGxlciIsImV2ZW50QmVsb25nc1RvVmlldyIsInJ1bkN1c3RvbUhhbmRsZXIiLCJwYXNzaXZlIiwiZW5zdXJlTGlzdGVuZXJzIiwic2V0U2VsZWN0aW9uT3JpZ2luIiwiRGF0ZSIsIm5vdyIsImRlc3Ryb3lJbnB1dCIsImNsZWFyVGltZW91dCIsImN1cnJlbnRIYW5kbGVycyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJidWJibGVzIiwiZGlzcGF0Y2hFdmVudCIsImtleWRvd24iLCJfZXZlbnQiLCJpbk9yTmVhckNvbXBvc2l0aW9uIiwiZm9yY2VGbHVzaCIsInByZXZlbnREZWZhdWx0Iiwia2V5dXAiLCJrZXlwcmVzcyIsImNoYXJDb2RlIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiaW5zZXJ0VGV4dCIsImV2ZW50Q29vcmRzIiwiY2xpZW50WCIsImNsaWVudFkiLCJpc05lYXIiLCJjbGljayIsImR5IiwicnVuSGFuZGxlck9uQ29udGV4dCIsInByb3BOYW1lIiwidXBkYXRlU2VsZWN0aW9uIiwiZm9jdXNlZCIsInNldE1ldGEiLCJzZWxlY3RDbGlja2VkTGVhZiIsInNlbGVjdENsaWNrZWROb2RlIiwic2VsZWN0ZWROb2RlIiwic2VsZWN0QXQiLCJoYW5kbGVTaW5nbGVDbGljayIsImhhbmRsZURvdWJsZUNsaWNrIiwiaGFuZGxlVHJpcGxlQ2xpY2siLCJkZWZhdWx0VHJpcGxlQ2xpY2siLCJidXR0b24iLCJmb3JjZURPTUZsdXNoIiwiZW5kQ29tcG9zaXRpb24iLCJzZWxlY3ROb2RlTW9kaWZpZXIiLCJtb3VzZWRvd24iLCJmbHVzaGVkIiwiZG9uZSIsIk1vdXNlRG93biIsIm1pZ2h0RHJhZyIsInN0YXJ0RG9jIiwidGFyZ2V0UG9zIiwibm9kZUF0Iiwic2VsZWN0YWJsZSIsImFkZEF0dHIiLCJzZXRVbmVkaXRhYmxlIiwidXAiLCJiaW5kIiwibW92ZSIsInVwZGF0ZUFsbG93RGVmYXVsdCIsImJ1dHRvbnMiLCJjb250ZXh0bWVudSIsInRpbWVTdGFtcCIsInRpbWVvdXRDb21wb3NpdGlvbiIsImNvbXBvc2l0aW9uc3RhcnQiLCJjb21wb3NpdGlvbnVwZGF0ZSIsImZsdXNoIiwic3RvcmVkTWFya3MiLCJzb21lIiwiaW5jbHVzaXZlIiwibWFya0N1cnNvciIsInNjaGVkdWxlQ29tcG9zZUVuZCIsImNvbXBvc2l0aW9uZW5kIiwicGVuZGluZ1JlY29yZHMiLCJQcm9taXNlIiwidGhlbiIsImRlbGF5IiwiY2xlYXJDb21wb3NpdGlvbiIsInRpbWVzdGFtcEZyb21DdXN0b21FdmVudCIsImZvcmNlVXBkYXRlIiwiZmx1c2hpbmdTb29uIiwiY2FwdHVyZUNvcHkiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJibHVyIiwiYnJva2VuQ2xpcGJvYXJkQVBJIiwiZGF0YSIsImNsaXBib2FyZERhdGEiLCJjbGVhckRhdGEiLCJzZXREYXRhIiwiZGVsZXRlU2VsZWN0aW9uIiwic2xpY2VTaW5nbGVOb2RlIiwiY2FwdHVyZVBhc3RlIiwicGxhaW4iLCJkb1Bhc3RlIiwicHJlZmVyUGxhaW4iLCJzaW5nbGVOb2RlIiwicmVwbGFjZVNlbGVjdGlvbldpdGgiLCJyZXBsYWNlU2VsZWN0aW9uIiwiZ2V0VGV4dCIsImdldERhdGEiLCJ1cmlzIiwicGFzdGUiLCJEcmFnZ2luZyIsImRyYWdDb3B5TW9kaWZpZXIiLCJkcmFnc3RhcnQiLCJkYXRhVHJhbnNmZXIiLCJlZmZlY3RBbGxvd2VkIiwiZHJhZ2dpbmciLCJkcmFnZW5kIiwiZHJhZ292ZXIiLCJkcmFnZW50ZXIiLCJkcm9wIiwiZXZlbnRQb3MiLCIkbW91c2UiLCJpbnNlcnRQb3MiLCJtYXBwaW5nIiwiaXNOb2RlIiwiYmVmb3JlSW5zZXJ0IiwicmVwbGFjZVJhbmdlV2l0aCIsInJlcGxhY2VSYW5nZSIsIm1hcHMiLCJfZnJvbSIsIl90byIsIl9uZXdGcm9tIiwibmV3VG8iLCJyZWxhdGVkVGFyZ2V0IiwiY2xlYXIiLCJiZWZvcmVpbnB1dCIsImlucHV0VHlwZSIsImZsdXNoU29vbiIsIiRjdXJzb3IiLCJjb21wYXJlT2JqcyIsIldpZGdldFR5cGUiLCJub1NwZWMiLCJzcGFuIiwib2xkT2Zmc2V0IiwiZGVsZXRlZCIsIm1hcFJlc3VsdCIsIkRlY29yYXRpb24iLCJ2YWxpZCIsIm90aGVyIiwiSW5saW5lVHlwZSIsImluY2x1c2l2ZVN0YXJ0IiwiaW5jbHVzaXZlRW5kIiwiaXMiLCJOb2RlVHlwZSIsImZpbmRJbmRleCIsIkRlY29yYXRpb25TZXQiLCJsb2NhbCIsImRlY29yYXRpb25zIiwiYnVpbGRUcmVlIiwicHJlZGljYXRlIiwiZmluZElubmVyIiwiY2hpbGRPZmYiLCJvcHRpb25zIiwibWFwSW5uZXIiLCJuZXdMb2NhbCIsIm1hcHBlZCIsIm9uUmVtb3ZlIiwibWFwQ2hpbGRyZW4iLCJieVBvcyIsImFkZElubmVyIiwiY2hpbGROb2RlIiwiY2hpbGRPZmZzZXQiLCJiYXNlT2Zmc2V0IiwidGFrZVNwYW5zRm9yTm9kZSIsIm1vdmVTcGFucyIsIndpdGhvdXROdWxscyIsImNvbmNhdCIsInJlbW92ZUlubmVyIiwicmVtb3ZlZCIsImRlYyIsImxvY2FsU2V0IiwiRGVjb3JhdGlvbkdyb3VwIiwicmVtb3ZlT3ZlcmxhcCIsImxvY2Fsc0lubmVyIiwibWVtYmVycyIsIm1hcHBlZERlY29zIiwibWVtYmVyIiwic29ydGVkIiwiZXZlcnkiLCJyZWR1Y2UiLCJyIiwib2xkQ2hpbGRyZW4iLCJtb3ZlZCIsIm9sZFN0YXJ0Iiwib2xkRW5kIiwibmV3U3RhcnQiLCJuZXdFbmQiLCJkU2l6ZSIsIm11c3RSZWJ1aWxkIiwiZnJvbUxvY2FsIiwidG9Mb2NhbCIsIm1heWJlQ2hpbGQiLCJtYXBBbmRHYXRoZXJSZW1haW5pbmdEZWNvcmF0aW9ucyIsImJ1aWx0Iiwic3BhbnMiLCJnYXRoZXIiLCJoYXNOdWxscyIsImxvY2FsU3RhcnQiLCJzdWJ0cmVlIiwid29ya2luZyIsImluc2VydEFoZWFkIiwidmlld0RlY29yYXRpb25zIiwib2JzZXJ2ZU9wdGlvbnMiLCJjaGlsZExpc3QiLCJjaGFyYWN0ZXJEYXRhIiwiY2hhcmFjdGVyRGF0YU9sZFZhbHVlIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZU9sZFZhbHVlIiwidXNlQ2hhckRhdGEiLCJTZWxlY3Rpb25TdGF0ZSIsIkRPTU9ic2VydmVyIiwiaGFuZGxlRE9NQ2hhbmdlIiwicXVldWUiLCJvYnNlcnZlciIsIm9uQ2hhckRhdGEiLCJzdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMiLCJNdXRhdGlvbk9ic2VydmVyIiwibXV0YXRpb25zIiwicmVtb3ZlZE5vZGVzIiwicHJldlZhbHVlIiwib25TZWxlY3Rpb25DaGFuZ2UiLCJ0YWtlUmVjb3JkcyIsIm9ic2VydmUiLCJ0YWtlIiwiZGlzY29ubmVjdCIsInN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcyIsImlnbm9yZVNlbGVjdGlvbkNoYW5nZSIsImFuY2VzdG9ycyIsIlNldCIsImNvbnRhaW5lciIsIm5ld1NlbCIsInR5cGVPdmVyIiwiYWRkZWQiLCJyZWdpc3Rlck11dGF0aW9uIiwiYnJzIiwicmVhZFNlbCIsInNjcm9sbFRvU2VsZWN0aW9uIiwiY2hlY2tDU1MiLCJhdHRyaWJ1dGVOYW1lIiwiYWRkZWROb2RlcyIsImNzc0NoZWNrZWQiLCJXZWFrTWFwIiwiY3NzQ2hlY2tXYXJuZWQiLCJ3aGl0ZVNwYWNlIiwiY29uc29sZSIsInNhZmFyaVNoYWRvd1NlbGVjdGlvblJhbmdlIiwicmVhZCIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsImdldFRhcmdldFJhbmdlcyIsImV4ZWNDb21tYW5kIiwiZW5kQ29udGFpbmVyIiwiZW5kT2Zmc2V0IiwiY3VycmVudEFuY2hvciIsImRvbUF0UG9zIiwicGFyc2VCZXR3ZWVuIiwiZnJvbV8iLCJ0b18iLCJ0b3BNYXRjaCIsInRvcE9wZW4iLCJmaW5kUG9zaXRpb25zIiwicmVhZERPTUNoYW5nZSIsIiRiZWZvcmUiLCJzaGFyZWQiLCJzaGFyZWREZXB0aCIsImNvbXBhcmUiLCJwcmVmZXJyZWRQb3MiLCJwcmVmZXJyZWRTaWRlIiwiY2hhbmdlIiwiZmluZERpZmYiLCJlbmRBIiwiZW5kQiIsInJlc29sdmVTZWxlY3Rpb24iLCJyZXNvbHZlTm9DYWNoZSIsIiRmcm9tQSIsImlubGluZUNoYW5nZSIsIm5leHRTZWwiLCJsb29rc0xpa2VKb2luIiwiY2hGcm9tIiwiY2hUbyIsIm1hcmtDaGFuZ2UiLCJtYXJrc0Fjcm9zcyIsImlzTWFya0NoYW5nZSIsImFkZE1hcmsiLCJyZW1vdmVNYXJrIiwiZW5zdXJlTWFya3MiLCJwYXJzZWRTZWwiLCJjdXJNYXJrcyIsInByZXZNYXJrcyIsInJlbW92ZUZyb21TZXQiLCJhZGRUb1NldCIsIm9sZCIsIiRuZXdTdGFydCIsIiRuZXdFbmQiLCJza2lwQ2xvc2luZ0FuZE9wZW5pbmciLCIkbmV4dCIsImZyb21FbmQiLCJtYXlPcGVuIiwiaW5kZXhBZnRlciIsImZpbmREaWZmU3RhcnQiLCJmaW5kRGlmZkVuZCIsImFkanVzdCIsImlzU3Vycm9nYXRlUGFpciIsImNoYXJDb2RlQXQiLCJfX3NlcmlhbGl6ZUZvckNsaXBib2FyZCIsIl9fcGFyc2VGcm9tQ2xpcGJvYXJkIiwiX19lbmRDb21wb3NpdGlvbiIsIkVkaXRvclZpZXciLCJwbGFjZSIsInByb3BzIiwiX3Jvb3QiLCJtb3VudGVkIiwicHJldkRpcmVjdFBsdWdpbnMiLCJwbHVnaW5WaWV3cyIsIl9wcm9wcyIsImRpcmVjdFBsdWdpbnMiLCJwbHVnaW5zIiwiY2hlY2tTdGF0ZUNvbXBvbmVudCIsIm1vdW50IiwiZ2V0RWRpdGFibGUiLCJ1cGRhdGVDdXJzb3JXcmFwcGVyIiwiYnVpbGROb2RlVmlld3MiLCJjb21wdXRlRG9jRGVjbyIsInVwZGF0ZVBsdWdpblZpZXdzIiwiaGFuZGxlRE9NRXZlbnRzIiwicHJldlByb3BzIiwidXBkYXRlU3RhdGVJbm5lciIsInNldFByb3BzIiwiX2EiLCJyZWRyYXciLCJ1cGRhdGVTZWwiLCJwbHVnaW5zQ2hhbmdlZCIsImNoYW5nZWROb2RlVmlld3MiLCJzY3JvbGwiLCJ1cGRhdGVEb2MiLCJvbGRTY3JvbGxQb3MiLCJvdmVyZmxvd0FuY2hvciIsImZvcmNlU2VsVXBkYXRlIiwic2VsZWN0aW9uQ29udGV4dENoYW5nZWQiLCJjaHJvbWVLbHVkZ2UiLCJ1cGRhdGVEcmFnZ2VkTm9kZSIsImRlc3Ryb3lQbHVnaW5WaWV3cyIsInByZXZTdGF0ZSIsInBsdWdpbiIsInBsdWdpblZpZXciLCJtb3ZlZFBvcyIsInBhcmVudEVsZW1lbnQiLCJjYWNoZWQiLCJnZXRQcm90b3R5cGVPZiIsInVwZGF0ZVJvb3QiLCJwb3NBdERPTSIsInBhc3RlSFRNTCIsIkNsaXBib2FyZEV2ZW50IiwicGFzdGVUZXh0IiwiaXNEZXN0cm95ZWQiLCJkaXNwYXRjaFRyYW5zYWN0aW9uIiwiY29udGVudGVkaXRhYmxlIiwiYXR0ciIsInRyYW5zbGF0ZSIsInNlbDEiLCJzZWwyIiwib2JqIiwiaGFzT3duUHJvcGVydHkiLCJuQSIsIm5CIiwiZmlsdGVyVHJhbnNhY3Rpb24iLCJhcHBlbmRUcmFuc2FjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-view/dist/index.js\n");

/***/ })

};
;