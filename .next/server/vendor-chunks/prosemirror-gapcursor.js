"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-gapcursor";
exports.ids = ["vendor-chunks/prosemirror-gapcursor"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-gapcursor/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-gapcursor/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: () => (/* binding */ GapCursor),\n/* harmony export */   gapCursor: () => (/* binding */ gapCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n\n\n\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/ class GapCursor extends prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection {\n    /**\n    Create a gap cursor.\n    */ constructor($pos){\n        super($pos, $pos);\n    }\n    map(doc, mapping) {\n        let $pos = doc.resolve(mapping.map(this.head));\n        return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);\n    }\n    content() {\n        return prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty;\n    }\n    eq(other) {\n        return other instanceof GapCursor && other.head == this.head;\n    }\n    toJSON() {\n        return {\n            type: \"gapcursor\",\n            pos: this.head\n        };\n    }\n    /**\n    @internal\n    */ static fromJSON(doc, json) {\n        if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n        return new GapCursor(doc.resolve(json.pos));\n    }\n    /**\n    @internal\n    */ getBookmark() {\n        return new GapBookmark(this.anchor);\n    }\n    /**\n    @internal\n    */ static valid($pos) {\n        let parent = $pos.parent;\n        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false;\n        let override = parent.type.spec.allowGapCursor;\n        if (override != null) return override;\n        let deflt = parent.contentMatchAt($pos.index()).defaultType;\n        return deflt && deflt.isTextblock;\n    }\n    /**\n    @internal\n    */ static findGapCursorFrom($pos, dir, mustMove = false) {\n        search: for(;;){\n            if (!mustMove && GapCursor.valid($pos)) return $pos;\n            let pos = $pos.pos, next = null;\n            // Scan up from this position\n            for(let d = $pos.depth;; d--){\n                let parent = $pos.node(d);\n                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n                    break;\n                } else if (d == 0) {\n                    return null;\n                }\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur)) return $cur;\n            }\n            // And then down into the next node\n            for(;;){\n                let inside = dir > 0 ? next.firstChild : next.lastChild;\n                if (!inside) {\n                    if (next.isAtom && !next.isText && !prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(next)) {\n                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n                        mustMove = false;\n                        continue search;\n                    }\n                    break;\n                }\n                next = inside;\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur)) return $cur;\n            }\n            return null;\n        }\n    }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nprosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n    constructor(pos){\n        this.pos = pos;\n    }\n    map(mapping) {\n        return new GapBookmark(mapping.map(this.pos));\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.pos);\n        return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);\n    }\n}\nfunction closedBefore($pos) {\n    for(let d = $pos.depth; d >= 0; d--){\n        let index = $pos.index(d), parent = $pos.node(d);\n        // At the start of this parent, look at next one\n        if (index == 0) {\n            if (parent.type.spec.isolating) return true;\n            continue;\n        }\n        // See if the node before (or its first ancestor) is closed\n        for(let before = parent.child(index - 1);; before = before.lastChild){\n            if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating) return true;\n            if (before.inlineContent) return false;\n        }\n    }\n    // Hit start of document\n    return true;\n}\nfunction closedAfter($pos) {\n    for(let d = $pos.depth; d >= 0; d--){\n        let index = $pos.indexAfter(d), parent = $pos.node(d);\n        if (index == parent.childCount) {\n            if (parent.type.spec.isolating) return true;\n            continue;\n        }\n        for(let after = parent.child(index);; after = after.firstChild){\n            if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating) return true;\n            if (after.inlineContent) return false;\n        }\n    }\n    return true;\n}\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/ function gapCursor() {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            decorations: drawGapCursor,\n            createSelectionBetween (_view, $anchor, $head) {\n                return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n            },\n            handleClick,\n            handleKeyDown,\n            handleDOMEvents: {\n                beforeinput: beforeinput\n            }\n        }\n    });\n}\nconst handleKeyDown = (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__.keydownHandler)({\n    \"ArrowLeft\": arrow(\"horiz\", -1),\n    \"ArrowRight\": arrow(\"horiz\", 1),\n    \"ArrowUp\": arrow(\"vert\", -1),\n    \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n    const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n    return function(state, dispatch, view) {\n        let sel = state.selection;\n        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n        if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n            if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false;\n            mustMove = false;\n            $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n        }\n        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n        if (!$found) return false;\n        if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)));\n        return true;\n    };\n}\nfunction handleClick(view, pos, event) {\n    if (!view || !view.editable) return false;\n    let $pos = view.state.doc.resolve(pos);\n    if (!GapCursor.valid($pos)) return false;\n    let clickPos = view.posAtCoords({\n        left: event.clientX,\n        top: event.clientY\n    });\n    if (clickPos && clickPos.inside > -1 && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside))) return false;\n    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n    return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n    if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor)) return false;\n    let { $from } = view.state.selection;\n    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n    if (!insert) return false;\n    let frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n    for(let i = insert.length - 1; i >= 0; i--)frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(insert[i].createAndFill(null, frag));\n    let tr = view.state.tr.replace($from.pos, $from.pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(frag, 0, 0));\n    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve($from.pos + 1)));\n    view.dispatch(tr);\n    return false;\n}\nfunction drawGapCursor(state) {\n    if (!(state.selection instanceof GapCursor)) return null;\n    let node = document.createElement(\"div\");\n    node.className = \"ProseMirror-gapcursor\";\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(state.doc, [\n        prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.widget(state.selection.head, node, {\n            key: \"gapcursor\"\n        })\n    ]);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItZ2FwY3Vyc29yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9EO0FBQ2dDO0FBQ2hDO0FBQ1M7QUFFN0Q7OztBQUdBLEdBQ0EsTUFBTVMsa0JBQWtCUix3REFBU0E7SUFDN0I7O0lBRUEsR0FDQVMsWUFBWUMsSUFBSSxDQUFFO1FBQ2QsS0FBSyxDQUFDQSxNQUFNQTtJQUNoQjtJQUNBQyxJQUFJQyxHQUFHLEVBQUVDLE9BQU8sRUFBRTtRQUNkLElBQUlILE9BQU9FLElBQUlFLE9BQU8sQ0FBQ0QsUUFBUUYsR0FBRyxDQUFDLElBQUksQ0FBQ0ksSUFBSTtRQUM1QyxPQUFPUCxVQUFVUSxLQUFLLENBQUNOLFFBQVEsSUFBSUYsVUFBVUUsUUFBUVYsd0RBQVNBLENBQUNpQixJQUFJLENBQUNQO0lBQ3hFO0lBQ0FRLFVBQVU7UUFBRSxPQUFPZCxvREFBS0EsQ0FBQ2UsS0FBSztJQUFFO0lBQ2hDQyxHQUFHQyxLQUFLLEVBQUU7UUFDTixPQUFPQSxpQkFBaUJiLGFBQWFhLE1BQU1OLElBQUksSUFBSSxJQUFJLENBQUNBLElBQUk7SUFDaEU7SUFDQU8sU0FBUztRQUNMLE9BQU87WUFBRUMsTUFBTTtZQUFhQyxLQUFLLElBQUksQ0FBQ1QsSUFBSTtRQUFDO0lBQy9DO0lBQ0E7O0lBRUEsR0FDQSxPQUFPVSxTQUFTYixHQUFHLEVBQUVjLElBQUksRUFBRTtRQUN2QixJQUFJLE9BQU9BLEtBQUtGLEdBQUcsSUFBSSxVQUNuQixNQUFNLElBQUlHLFdBQVc7UUFDekIsT0FBTyxJQUFJbkIsVUFBVUksSUFBSUUsT0FBTyxDQUFDWSxLQUFLRixHQUFHO0lBQzdDO0lBQ0E7O0lBRUEsR0FDQUksY0FBYztRQUFFLE9BQU8sSUFBSUMsWUFBWSxJQUFJLENBQUNDLE1BQU07SUFBRztJQUNyRDs7SUFFQSxHQUNBLE9BQU9kLE1BQU1OLElBQUksRUFBRTtRQUNmLElBQUlxQixTQUFTckIsS0FBS3FCLE1BQU07UUFDeEIsSUFBSUEsT0FBT0MsV0FBVyxJQUFJLENBQUNDLGFBQWF2QixTQUFTLENBQUN3QixZQUFZeEIsT0FDMUQsT0FBTztRQUNYLElBQUl5QixXQUFXSixPQUFPUixJQUFJLENBQUNhLElBQUksQ0FBQ0MsY0FBYztRQUM5QyxJQUFJRixZQUFZLE1BQ1osT0FBT0E7UUFDWCxJQUFJRyxRQUFRUCxPQUFPUSxjQUFjLENBQUM3QixLQUFLOEIsS0FBSyxJQUFJQyxXQUFXO1FBQzNELE9BQU9ILFNBQVNBLE1BQU1OLFdBQVc7SUFDckM7SUFDQTs7SUFFQSxHQUNBLE9BQU9VLGtCQUFrQmhDLElBQUksRUFBRWlDLEdBQUcsRUFBRUMsV0FBVyxLQUFLLEVBQUU7UUFDbERDLFFBQVEsT0FBUztZQUNiLElBQUksQ0FBQ0QsWUFBWXBDLFVBQVVRLEtBQUssQ0FBQ04sT0FDN0IsT0FBT0E7WUFDWCxJQUFJYyxNQUFNZCxLQUFLYyxHQUFHLEVBQUVzQixPQUFPO1lBQzNCLDZCQUE2QjtZQUM3QixJQUFLLElBQUlDLElBQUlyQyxLQUFLc0MsS0FBSyxHQUFHRCxJQUFLO2dCQUMzQixJQUFJaEIsU0FBU3JCLEtBQUt1QyxJQUFJLENBQUNGO2dCQUN2QixJQUFJSixNQUFNLElBQUlqQyxLQUFLd0MsVUFBVSxDQUFDSCxLQUFLaEIsT0FBT29CLFVBQVUsR0FBR3pDLEtBQUs4QixLQUFLLENBQUNPLEtBQUssR0FBRztvQkFDdEVELE9BQU9mLE9BQU9xQixLQUFLLENBQUNULE1BQU0sSUFBSWpDLEtBQUt3QyxVQUFVLENBQUNILEtBQUtyQyxLQUFLOEIsS0FBSyxDQUFDTyxLQUFLO29CQUNuRTtnQkFDSixPQUNLLElBQUlBLEtBQUssR0FBRztvQkFDYixPQUFPO2dCQUNYO2dCQUNBdkIsT0FBT21CO2dCQUNQLElBQUlVLE9BQU8zQyxLQUFLRSxHQUFHLENBQUNFLE9BQU8sQ0FBQ1U7Z0JBQzVCLElBQUloQixVQUFVUSxLQUFLLENBQUNxQyxPQUNoQixPQUFPQTtZQUNmO1lBQ0EsbUNBQW1DO1lBQ25DLE9BQVM7Z0JBQ0wsSUFBSUMsU0FBU1gsTUFBTSxJQUFJRyxLQUFLUyxVQUFVLEdBQUdULEtBQUtVLFNBQVM7Z0JBQ3ZELElBQUksQ0FBQ0YsUUFBUTtvQkFDVCxJQUFJUixLQUFLVyxNQUFNLElBQUksQ0FBQ1gsS0FBS1ksTUFBTSxJQUFJLENBQUN6RCw0REFBYUEsQ0FBQzBELFlBQVksQ0FBQ2IsT0FBTzt3QkFDbEVwQyxPQUFPQSxLQUFLRSxHQUFHLENBQUNFLE9BQU8sQ0FBQ1UsTUFBTXNCLEtBQUtjLFFBQVEsR0FBR2pCO3dCQUM5Q0MsV0FBVzt3QkFDWCxTQUFTQztvQkFDYjtvQkFDQTtnQkFDSjtnQkFDQUMsT0FBT1E7Z0JBQ1A5QixPQUFPbUI7Z0JBQ1AsSUFBSVUsT0FBTzNDLEtBQUtFLEdBQUcsQ0FBQ0UsT0FBTyxDQUFDVTtnQkFDNUIsSUFBSWhCLFVBQVVRLEtBQUssQ0FBQ3FDLE9BQ2hCLE9BQU9BO1lBQ2Y7WUFDQSxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0E3QyxVQUFVcUQsU0FBUyxDQUFDQyxPQUFPLEdBQUc7QUFDOUJ0RCxVQUFVdUQsUUFBUSxHQUFHdkQsVUFBVWtDLGlCQUFpQjtBQUNoRDFDLHdEQUFTQSxDQUFDZ0UsTUFBTSxDQUFDLGFBQWF4RDtBQUM5QixNQUFNcUI7SUFDRnBCLFlBQVllLEdBQUcsQ0FBRTtRQUNiLElBQUksQ0FBQ0EsR0FBRyxHQUFHQTtJQUNmO0lBQ0FiLElBQUlFLE9BQU8sRUFBRTtRQUNULE9BQU8sSUFBSWdCLFlBQVloQixRQUFRRixHQUFHLENBQUMsSUFBSSxDQUFDYSxHQUFHO0lBQy9DO0lBQ0FWLFFBQVFGLEdBQUcsRUFBRTtRQUNULElBQUlGLE9BQU9FLElBQUlFLE9BQU8sQ0FBQyxJQUFJLENBQUNVLEdBQUc7UUFDL0IsT0FBT2hCLFVBQVVRLEtBQUssQ0FBQ04sUUFBUSxJQUFJRixVQUFVRSxRQUFRVix3REFBU0EsQ0FBQ2lCLElBQUksQ0FBQ1A7SUFDeEU7QUFDSjtBQUNBLFNBQVN1QixhQUFhdkIsSUFBSTtJQUN0QixJQUFLLElBQUlxQyxJQUFJckMsS0FBS3NDLEtBQUssRUFBRUQsS0FBSyxHQUFHQSxJQUFLO1FBQ2xDLElBQUlQLFFBQVE5QixLQUFLOEIsS0FBSyxDQUFDTyxJQUFJaEIsU0FBU3JCLEtBQUt1QyxJQUFJLENBQUNGO1FBQzlDLGdEQUFnRDtRQUNoRCxJQUFJUCxTQUFTLEdBQUc7WUFDWixJQUFJVCxPQUFPUixJQUFJLENBQUNhLElBQUksQ0FBQzZCLFNBQVMsRUFDMUIsT0FBTztZQUNYO1FBQ0o7UUFDQSwyREFBMkQ7UUFDM0QsSUFBSyxJQUFJQyxTQUFTbkMsT0FBT3FCLEtBQUssQ0FBQ1osUUFBUSxLQUFLMEIsU0FBU0EsT0FBT1YsU0FBUyxDQUFFO1lBQ25FLElBQUksT0FBUUwsVUFBVSxJQUFJLEtBQUssQ0FBQ2UsT0FBT0MsYUFBYSxJQUFLRCxPQUFPVCxNQUFNLElBQUlTLE9BQU8zQyxJQUFJLENBQUNhLElBQUksQ0FBQzZCLFNBQVMsRUFDaEcsT0FBTztZQUNYLElBQUlDLE9BQU9DLGFBQWEsRUFDcEIsT0FBTztRQUNmO0lBQ0o7SUFDQSx3QkFBd0I7SUFDeEIsT0FBTztBQUNYO0FBQ0EsU0FBU2pDLFlBQVl4QixJQUFJO0lBQ3JCLElBQUssSUFBSXFDLElBQUlyQyxLQUFLc0MsS0FBSyxFQUFFRCxLQUFLLEdBQUdBLElBQUs7UUFDbEMsSUFBSVAsUUFBUTlCLEtBQUt3QyxVQUFVLENBQUNILElBQUloQixTQUFTckIsS0FBS3VDLElBQUksQ0FBQ0Y7UUFDbkQsSUFBSVAsU0FBU1QsT0FBT29CLFVBQVUsRUFBRTtZQUM1QixJQUFJcEIsT0FBT1IsSUFBSSxDQUFDYSxJQUFJLENBQUM2QixTQUFTLEVBQzFCLE9BQU87WUFDWDtRQUNKO1FBQ0EsSUFBSyxJQUFJRyxRQUFRckMsT0FBT3FCLEtBQUssQ0FBQ1osU0FBUzRCLFFBQVFBLE1BQU1iLFVBQVUsQ0FBRTtZQUM3RCxJQUFJLE1BQU9KLFVBQVUsSUFBSSxLQUFLLENBQUNpQixNQUFNRCxhQUFhLElBQUtDLE1BQU1YLE1BQU0sSUFBSVcsTUFBTTdDLElBQUksQ0FBQ2EsSUFBSSxDQUFDNkIsU0FBUyxFQUM1RixPQUFPO1lBQ1gsSUFBSUcsTUFBTUQsYUFBYSxFQUNuQixPQUFPO1FBQ2Y7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUVBOzs7Ozs7OztBQVFBLEdBQ0EsU0FBU0U7SUFDTCxPQUFPLElBQUlsRSxxREFBTUEsQ0FBQztRQUNkbUUsT0FBTztZQUNIQyxhQUFhQztZQUNiQyx3QkFBdUJDLEtBQUssRUFBRUMsT0FBTyxFQUFFQyxLQUFLO2dCQUN4QyxPQUFPRCxRQUFRbkQsR0FBRyxJQUFJb0QsTUFBTXBELEdBQUcsSUFBSWhCLFVBQVVRLEtBQUssQ0FBQzRELFNBQVMsSUFBSXBFLFVBQVVvRSxTQUFTO1lBQ3ZGO1lBQ0FDO1lBQ0FDO1lBQ0FDLGlCQUFpQjtnQkFBRUMsYUFBYUE7WUFBWTtRQUNoRDtJQUNKO0FBQ0o7QUFDQSxNQUFNRixnQkFBZ0IvRSxrRUFBY0EsQ0FBQztJQUNqQyxhQUFha0YsTUFBTSxTQUFTLENBQUM7SUFDN0IsY0FBY0EsTUFBTSxTQUFTO0lBQzdCLFdBQVdBLE1BQU0sUUFBUSxDQUFDO0lBQzFCLGFBQWFBLE1BQU0sUUFBUTtBQUMvQjtBQUNBLFNBQVNBLE1BQU1DLElBQUksRUFBRXZDLEdBQUc7SUFDcEIsTUFBTXdDLFNBQVNELFFBQVEsU0FBVXZDLE1BQU0sSUFBSSxTQUFTLE9BQVNBLE1BQU0sSUFBSSxVQUFVO0lBQ2pGLE9BQU8sU0FBVXlDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxJQUFJO1FBQ2xDLElBQUlDLE1BQU1ILE1BQU1JLFNBQVM7UUFDekIsSUFBSUMsU0FBUzlDLE1BQU0sSUFBSTRDLElBQUlHLEdBQUcsR0FBR0gsSUFBSUksS0FBSyxFQUFFL0MsV0FBVzJDLElBQUlwRSxLQUFLO1FBQ2hFLElBQUlvRSxlQUFlckYsNERBQWFBLEVBQUU7WUFDOUIsSUFBSSxDQUFDb0YsS0FBS00sY0FBYyxDQUFDVCxXQUFXTSxPQUFPekMsS0FBSyxJQUFJLEdBQ2hELE9BQU87WUFDWEosV0FBVztZQUNYNkMsU0FBU0wsTUFBTXhFLEdBQUcsQ0FBQ0UsT0FBTyxDQUFDNkIsTUFBTSxJQUFJOEMsT0FBT3JCLEtBQUssS0FBS3FCLE9BQU92QixNQUFNO1FBQ3ZFO1FBQ0EsSUFBSTJCLFNBQVNyRixVQUFVa0MsaUJBQWlCLENBQUMrQyxRQUFROUMsS0FBS0M7UUFDdEQsSUFBSSxDQUFDaUQsUUFDRCxPQUFPO1FBQ1gsSUFBSVIsVUFDQUEsU0FBU0QsTUFBTVUsRUFBRSxDQUFDQyxZQUFZLENBQUMsSUFBSXZGLFVBQVVxRjtRQUNqRCxPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVNoQixZQUFZUyxJQUFJLEVBQUU5RCxHQUFHLEVBQUV3RSxLQUFLO0lBQ2pDLElBQUksQ0FBQ1YsUUFBUSxDQUFDQSxLQUFLVyxRQUFRLEVBQ3ZCLE9BQU87SUFDWCxJQUFJdkYsT0FBTzRFLEtBQUtGLEtBQUssQ0FBQ3hFLEdBQUcsQ0FBQ0UsT0FBTyxDQUFDVTtJQUNsQyxJQUFJLENBQUNoQixVQUFVUSxLQUFLLENBQUNOLE9BQ2pCLE9BQU87SUFDWCxJQUFJd0YsV0FBV1osS0FBS2EsV0FBVyxDQUFDO1FBQUVDLE1BQU1KLE1BQU1LLE9BQU87UUFBRUMsS0FBS04sTUFBTU8sT0FBTztJQUFDO0lBQzFFLElBQUlMLFlBQVlBLFNBQVM1QyxNQUFNLEdBQUcsQ0FBQyxLQUFLckQsNERBQWFBLENBQUMwRCxZQUFZLENBQUMyQixLQUFLRixLQUFLLENBQUN4RSxHQUFHLENBQUM0RixNQUFNLENBQUNOLFNBQVM1QyxNQUFNLElBQ3BHLE9BQU87SUFDWGdDLEtBQUtELFFBQVEsQ0FBQ0MsS0FBS0YsS0FBSyxDQUFDVSxFQUFFLENBQUNDLFlBQVksQ0FBQyxJQUFJdkYsVUFBVUU7SUFDdkQsT0FBTztBQUNYO0FBQ0Esb0VBQW9FO0FBQ3BFLHNFQUFzRTtBQUN0RSxrRUFBa0U7QUFDbEUsK0JBQStCO0FBQy9CLFNBQVNzRSxZQUFZTSxJQUFJLEVBQUVVLEtBQUs7SUFDNUIsSUFBSUEsTUFBTVMsU0FBUyxJQUFJLDJCQUEyQixDQUFFbkIsQ0FBQUEsS0FBS0YsS0FBSyxDQUFDSSxTQUFTLFlBQVloRixTQUFRLEdBQ3hGLE9BQU87SUFDWCxJQUFJLEVBQUVtRixLQUFLLEVBQUUsR0FBR0wsS0FBS0YsS0FBSyxDQUFDSSxTQUFTO0lBQ3BDLElBQUlrQixTQUFTZixNQUFNNUQsTUFBTSxDQUFDUSxjQUFjLENBQUNvRCxNQUFNbkQsS0FBSyxJQUFJbUUsWUFBWSxDQUFDckIsS0FBS0YsS0FBSyxDQUFDd0IsTUFBTSxDQUFDQyxLQUFLLENBQUNDLElBQUk7SUFDakcsSUFBSSxDQUFDSixRQUNELE9BQU87SUFDWCxJQUFJSyxPQUFPMUcsdURBQVFBLENBQUNjLEtBQUs7SUFDekIsSUFBSyxJQUFJNkYsSUFBSU4sT0FBT08sTUFBTSxHQUFHLEdBQUdELEtBQUssR0FBR0EsSUFDcENELE9BQU8xRyx1REFBUUEsQ0FBQzZHLElBQUksQ0FBQ1IsTUFBTSxDQUFDTSxFQUFFLENBQUNHLGFBQWEsQ0FBQyxNQUFNSjtJQUN2RCxJQUFJakIsS0FBS1IsS0FBS0YsS0FBSyxDQUFDVSxFQUFFLENBQUNzQixPQUFPLENBQUN6QixNQUFNbkUsR0FBRyxFQUFFbUUsTUFBTW5FLEdBQUcsRUFBRSxJQUFJcEIsb0RBQUtBLENBQUMyRyxNQUFNLEdBQUc7SUFDeEVqQixHQUFHQyxZQUFZLENBQUM3Riw0REFBYUEsQ0FBQ2UsSUFBSSxDQUFDNkUsR0FBR2xGLEdBQUcsQ0FBQ0UsT0FBTyxDQUFDNkUsTUFBTW5FLEdBQUcsR0FBRztJQUM5RDhELEtBQUtELFFBQVEsQ0FBQ1M7SUFDZCxPQUFPO0FBQ1g7QUFDQSxTQUFTdEIsY0FBY1ksS0FBSztJQUN4QixJQUFJLENBQUVBLENBQUFBLE1BQU1JLFNBQVMsWUFBWWhGLFNBQVEsR0FDckMsT0FBTztJQUNYLElBQUl5QyxPQUFPb0UsU0FBU0MsYUFBYSxDQUFDO0lBQ2xDckUsS0FBS3NFLFNBQVMsR0FBRztJQUNqQixPQUFPakgsMkRBQWFBLENBQUNrSCxNQUFNLENBQUNwQyxNQUFNeEUsR0FBRyxFQUFFO1FBQUNMLHdEQUFVQSxDQUFDa0gsTUFBTSxDQUFDckMsTUFBTUksU0FBUyxDQUFDekUsSUFBSSxFQUFFa0MsTUFBTTtZQUFFeUUsS0FBSztRQUFZO0tBQUc7QUFDaEg7QUFFZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmFsb2d1ZXNoaWZ0cy8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1nYXBjdXJzb3IvZGlzdC9pbmRleC5qcz81ZDIxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtleWRvd25IYW5kbGVyIH0gZnJvbSAncHJvc2VtaXJyb3Ita2V5bWFwJztcbmltcG9ydCB7IFNlbGVjdGlvbiwgTm9kZVNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiwgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgU2xpY2UsIEZyYWdtZW50IH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgRGVjb3JhdGlvblNldCwgRGVjb3JhdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuXG4vKipcbkdhcCBjdXJzb3Igc2VsZWN0aW9ucyBhcmUgcmVwcmVzZW50ZWQgdXNpbmcgdGhpcyBjbGFzcy4gSXRzXG5gJGFuY2hvcmAgYW5kIGAkaGVhZGAgcHJvcGVydGllcyBib3RoIHBvaW50IGF0IHRoZSBjdXJzb3IgcG9zaXRpb24uXG4qL1xuY2xhc3MgR2FwQ3Vyc29yIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBnYXAgY3Vyc29yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoJHBvcykge1xuICAgICAgICBzdXBlcigkcG9zLCAkcG9zKTtcbiAgICB9XG4gICAgbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgICAgICByZXR1cm4gR2FwQ3Vyc29yLnZhbGlkKCRwb3MpID8gbmV3IEdhcEN1cnNvcigkcG9zKSA6IFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbiAgICBjb250ZW50KCkgeyByZXR1cm4gU2xpY2UuZW1wdHk7IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBHYXBDdXJzb3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWQ7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJnYXBjdXJzb3JcIiwgcG9zOiB0aGlzLmhlYWQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgR2FwQ3Vyc29yLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEdhcEN1cnNvcihkb2MucmVzb2x2ZShqc29uLnBvcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldEJvb2ttYXJrKCkgeyByZXR1cm4gbmV3IEdhcEJvb2ttYXJrKHRoaXMuYW5jaG9yKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHZhbGlkKCRwb3MpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRwb3MucGFyZW50O1xuICAgICAgICBpZiAocGFyZW50LmlzVGV4dGJsb2NrIHx8ICFjbG9zZWRCZWZvcmUoJHBvcykgfHwgIWNsb3NlZEFmdGVyKCRwb3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSBwYXJlbnQudHlwZS5zcGVjLmFsbG93R2FwQ3Vyc29yO1xuICAgICAgICBpZiAob3ZlcnJpZGUgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBvdmVycmlkZTtcbiAgICAgICAgbGV0IGRlZmx0ID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KCRwb3MuaW5kZXgoKSkuZGVmYXVsdFR5cGU7XG4gICAgICAgIHJldHVybiBkZWZsdCAmJiBkZWZsdC5pc1RleHRibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEdhcEN1cnNvckZyb20oJHBvcywgZGlyLCBtdXN0TW92ZSA9IGZhbHNlKSB7XG4gICAgICAgIHNlYXJjaDogZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKCFtdXN0TW92ZSAmJiBHYXBDdXJzb3IudmFsaWQoJHBvcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3M7XG4gICAgICAgICAgICBsZXQgcG9zID0gJHBvcy5wb3MsIG5leHQgPSBudWxsO1xuICAgICAgICAgICAgLy8gU2NhbiB1cCBmcm9tIHRoaXMgcG9zaXRpb25cbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOzsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMCA/ICRwb3MuaW5kZXhBZnRlcihkKSA8IHBhcmVudC5jaGlsZENvdW50IDogJHBvcy5pbmRleChkKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBhcmVudC5jaGlsZChkaXIgPiAwID8gJHBvcy5pbmRleEFmdGVyKGQpIDogJHBvcy5pbmRleChkKSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gZGlyO1xuICAgICAgICAgICAgICAgIGxldCAkY3VyID0gJHBvcy5kb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChHYXBDdXJzb3IudmFsaWQoJGN1cikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQW5kIHRoZW4gZG93biBpbnRvIHRoZSBuZXh0IG5vZGVcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zaWRlID0gZGlyID4gMCA/IG5leHQuZmlyc3RDaGlsZCA6IG5leHQubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmICghaW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmlzQXRvbSAmJiAhbmV4dC5pc1RleHQgJiYgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcG9zID0gJHBvcy5kb2MucmVzb2x2ZShwb3MgKyBuZXh0Lm5vZGVTaXplICogZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBzZWFyY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQgPSBpbnNpZGU7XG4gICAgICAgICAgICAgICAgcG9zICs9IGRpcjtcbiAgICAgICAgICAgICAgICBsZXQgJGN1ciA9ICRwb3MuZG9jLnJlc29sdmUocG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoR2FwQ3Vyc29yLnZhbGlkKCRjdXIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuR2FwQ3Vyc29yLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5HYXBDdXJzb3IuZmluZEZyb20gPSBHYXBDdXJzb3IuZmluZEdhcEN1cnNvckZyb207XG5TZWxlY3Rpb24uanNvbklEKFwiZ2FwY3Vyc29yXCIsIEdhcEN1cnNvcik7XG5jbGFzcyBHYXBCb29rbWFyayB7XG4gICAgY29uc3RydWN0b3IocG9zKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbmV3IEdhcEJvb2ttYXJrKG1hcHBpbmcubWFwKHRoaXMucG9zKSk7XG4gICAgfVxuICAgIHJlc29sdmUoZG9jKSB7XG4gICAgICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUodGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gR2FwQ3Vyc29yLnZhbGlkKCRwb3MpID8gbmV3IEdhcEN1cnNvcigkcG9zKSA6IFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlZEJlZm9yZSgkcG9zKSB7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXgoZCksIHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICAgICAgLy8gQXQgdGhlIHN0YXJ0IG9mIHRoaXMgcGFyZW50LCBsb29rIGF0IG5leHQgb25lXG4gICAgICAgIGlmIChpbmRleCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgaWYgdGhlIG5vZGUgYmVmb3JlIChvciBpdHMgZmlyc3QgYW5jZXN0b3IpIGlzIGNsb3NlZFxuICAgICAgICBmb3IgKGxldCBiZWZvcmUgPSBwYXJlbnQuY2hpbGQoaW5kZXggLSAxKTs7IGJlZm9yZSA9IGJlZm9yZS5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmICgoYmVmb3JlLmNoaWxkQ291bnQgPT0gMCAmJiAhYmVmb3JlLmlubGluZUNvbnRlbnQpIHx8IGJlZm9yZS5pc0F0b20gfHwgYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoYmVmb3JlLmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhpdCBzdGFydCBvZiBkb2N1bWVudFxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2xvc2VkQWZ0ZXIoJHBvcykge1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoZCksIHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICAgICAgaWYgKGluZGV4ID09IHBhcmVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBhZnRlciA9IHBhcmVudC5jaGlsZChpbmRleCk7OyBhZnRlciA9IGFmdGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmICgoYWZ0ZXIuY2hpbGRDb3VudCA9PSAwICYmICFhZnRlci5pbmxpbmVDb250ZW50KSB8fCBhZnRlci5pc0F0b20gfHwgYWZ0ZXIudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChhZnRlci5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG5DcmVhdGUgYSBnYXAgY3Vyc29yIHBsdWdpbi4gV2hlbiBlbmFibGVkLCB0aGlzIHdpbGwgY2FwdHVyZSBjbGlja3Ncbm5lYXIgYW5kIGFycm93LWtleS1tb3Rpb24gcGFzdCBwbGFjZXMgdGhhdCBkb24ndCBoYXZlIGEgbm9ybWFsbHlcbnNlbGVjdGFibGUgcG9zaXRpb24gbmVhcmJ5LCBhbmQgY3JlYXRlIGEgZ2FwIGN1cnNvciBzZWxlY3Rpb24gZm9yXG50aGVtLiBUaGUgY3Vyc29yIGlzIGRyYXduIGFzIGFuIGVsZW1lbnQgd2l0aCBjbGFzc1xuYFByb3NlTWlycm9yLWdhcGN1cnNvcmAuIFlvdSBjYW4gZWl0aGVyIGluY2x1ZGVcbmBzdHlsZS9nYXBjdXJzb3IuY3NzYCBmcm9tIHRoZSBwYWNrYWdlJ3MgZGlyZWN0b3J5IG9yIGFkZCB5b3VyIG93blxuc3R5bGVzIHRvIG1ha2UgaXQgdmlzaWJsZS5cbiovXG5mdW5jdGlvbiBnYXBDdXJzb3IoKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IGRyYXdHYXBDdXJzb3IsXG4gICAgICAgICAgICBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuKF92aWV3LCAkYW5jaG9yLCAkaGVhZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkYW5jaG9yLnBvcyA9PSAkaGVhZC5wb3MgJiYgR2FwQ3Vyc29yLnZhbGlkKCRoZWFkKSA/IG5ldyBHYXBDdXJzb3IoJGhlYWQpIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVDbGljayxcbiAgICAgICAgICAgIGhhbmRsZUtleURvd24sXG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHsgYmVmb3JlaW5wdXQ6IGJlZm9yZWlucHV0IH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgaGFuZGxlS2V5RG93biA9IGtleWRvd25IYW5kbGVyKHtcbiAgICBcIkFycm93TGVmdFwiOiBhcnJvdyhcImhvcml6XCIsIC0xKSxcbiAgICBcIkFycm93UmlnaHRcIjogYXJyb3coXCJob3JpelwiLCAxKSxcbiAgICBcIkFycm93VXBcIjogYXJyb3coXCJ2ZXJ0XCIsIC0xKSxcbiAgICBcIkFycm93RG93blwiOiBhcnJvdyhcInZlcnRcIiwgMSlcbn0pO1xuZnVuY3Rpb24gYXJyb3coYXhpcywgZGlyKSB7XG4gICAgY29uc3QgZGlyU3RyID0gYXhpcyA9PSBcInZlcnRcIiA/IChkaXIgPiAwID8gXCJkb3duXCIgOiBcInVwXCIpIDogKGRpciA+IDAgPyBcInJpZ2h0XCIgOiBcImxlZnRcIik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICAgICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0ICRzdGFydCA9IGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tLCBtdXN0TW92ZSA9IHNlbC5lbXB0eTtcbiAgICAgICAgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghdmlldy5lbmRPZlRleHRibG9jayhkaXJTdHIpIHx8ICRzdGFydC5kZXB0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHN0YXJ0LmFmdGVyKCkgOiAkc3RhcnQuYmVmb3JlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCAkZm91bmQgPSBHYXBDdXJzb3IuZmluZEdhcEN1cnNvckZyb20oJHN0YXJ0LCBkaXIsIG11c3RNb3ZlKTtcbiAgICAgICAgaWYgKCEkZm91bmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgR2FwQ3Vyc29yKCRmb3VuZCkpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNsaWNrKHZpZXcsIHBvcywgZXZlbnQpIHtcbiAgICBpZiAoIXZpZXcgfHwgIXZpZXcuZWRpdGFibGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoIUdhcEN1cnNvci52YWxpZCgkcG9zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjbGlja1BvcyA9IHZpZXcucG9zQXRDb29yZHMoeyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfSk7XG4gICAgaWYgKGNsaWNrUG9zICYmIGNsaWNrUG9zLmluc2lkZSA+IC0xICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKHZpZXcuc3RhdGUuZG9jLm5vZGVBdChjbGlja1Bvcy5pbnNpZGUpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEdhcEN1cnNvcigkcG9zKSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gVGhpcyBpcyBhIGhhY2sgdGhhdCwgd2hlbiBhIGNvbXBvc2l0aW9uIHN0YXJ0cyB3aGlsZSBhIGdhcCBjdXJzb3Jcbi8vIGlzIGFjdGl2ZSwgcXVpY2tseSBjcmVhdGVzIGFuIGlubGluZSBjb250ZXh0IGZvciB0aGUgY29tcG9zaXRpb24gdG9cbi8vIGhhcHBlbiBpbiwgdG8gYXZvaWQgaXQgYmVpbmcgYWJvcnRlZCBieSB0aGUgRE9NIHNlbGVjdGlvbiBiZWluZ1xuLy8gbW92ZWQgaW50byBhIHZhbGlkIHBvc2l0aW9uLlxuZnVuY3Rpb24gYmVmb3JlaW5wdXQodmlldywgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaW5wdXRUeXBlICE9IFwiaW5zZXJ0Q29tcG9zaXRpb25UZXh0XCIgfHwgISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEdhcEN1cnNvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyAkZnJvbSB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IGluc2VydCA9ICRmcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleCgpKS5maW5kV3JhcHBpbmcodmlldy5zdGF0ZS5zY2hlbWEubm9kZXMudGV4dCk7XG4gICAgaWYgKCFpbnNlcnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZnJhZyA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGkgPSBpbnNlcnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGZyYWcgPSBGcmFnbWVudC5mcm9tKGluc2VydFtpXS5jcmVhdGVBbmRGaWxsKG51bGwsIGZyYWcpKTtcbiAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnJlcGxhY2UoJGZyb20ucG9zLCAkZnJvbS5wb3MsIG5ldyBTbGljZShmcmFnLCAwLCAwKSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAxKSkpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRyYXdHYXBDdXJzb3Ioc3RhdGUpIHtcbiAgICBpZiAoIShzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBHYXBDdXJzb3IpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbm9kZS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLWdhcGN1cnNvclwiO1xuICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtEZWNvcmF0aW9uLndpZGdldChzdGF0ZS5zZWxlY3Rpb24uaGVhZCwgbm9kZSwgeyBrZXk6IFwiZ2FwY3Vyc29yXCIgfSldKTtcbn1cblxuZXhwb3J0IHsgR2FwQ3Vyc29yLCBnYXBDdXJzb3IgfTtcbiJdLCJuYW1lcyI6WyJrZXlkb3duSGFuZGxlciIsIlNlbGVjdGlvbiIsIk5vZGVTZWxlY3Rpb24iLCJUZXh0U2VsZWN0aW9uIiwiUGx1Z2luIiwiU2xpY2UiLCJGcmFnbWVudCIsIkRlY29yYXRpb25TZXQiLCJEZWNvcmF0aW9uIiwiR2FwQ3Vyc29yIiwiY29uc3RydWN0b3IiLCIkcG9zIiwibWFwIiwiZG9jIiwibWFwcGluZyIsInJlc29sdmUiLCJoZWFkIiwidmFsaWQiLCJuZWFyIiwiY29udGVudCIsImVtcHR5IiwiZXEiLCJvdGhlciIsInRvSlNPTiIsInR5cGUiLCJwb3MiLCJmcm9tSlNPTiIsImpzb24iLCJSYW5nZUVycm9yIiwiZ2V0Qm9va21hcmsiLCJHYXBCb29rbWFyayIsImFuY2hvciIsInBhcmVudCIsImlzVGV4dGJsb2NrIiwiY2xvc2VkQmVmb3JlIiwiY2xvc2VkQWZ0ZXIiLCJvdmVycmlkZSIsInNwZWMiLCJhbGxvd0dhcEN1cnNvciIsImRlZmx0IiwiY29udGVudE1hdGNoQXQiLCJpbmRleCIsImRlZmF1bHRUeXBlIiwiZmluZEdhcEN1cnNvckZyb20iLCJkaXIiLCJtdXN0TW92ZSIsInNlYXJjaCIsIm5leHQiLCJkIiwiZGVwdGgiLCJub2RlIiwiaW5kZXhBZnRlciIsImNoaWxkQ291bnQiLCJjaGlsZCIsIiRjdXIiLCJpbnNpZGUiLCJmaXJzdENoaWxkIiwibGFzdENoaWxkIiwiaXNBdG9tIiwiaXNUZXh0IiwiaXNTZWxlY3RhYmxlIiwibm9kZVNpemUiLCJwcm90b3R5cGUiLCJ2aXNpYmxlIiwiZmluZEZyb20iLCJqc29uSUQiLCJpc29sYXRpbmciLCJiZWZvcmUiLCJpbmxpbmVDb250ZW50IiwiYWZ0ZXIiLCJnYXBDdXJzb3IiLCJwcm9wcyIsImRlY29yYXRpb25zIiwiZHJhd0dhcEN1cnNvciIsImNyZWF0ZVNlbGVjdGlvbkJldHdlZW4iLCJfdmlldyIsIiRhbmNob3IiLCIkaGVhZCIsImhhbmRsZUNsaWNrIiwiaGFuZGxlS2V5RG93biIsImhhbmRsZURPTUV2ZW50cyIsImJlZm9yZWlucHV0IiwiYXJyb3ciLCJheGlzIiwiZGlyU3RyIiwic3RhdGUiLCJkaXNwYXRjaCIsInZpZXciLCJzZWwiLCJzZWxlY3Rpb24iLCIkc3RhcnQiLCIkdG8iLCIkZnJvbSIsImVuZE9mVGV4dGJsb2NrIiwiJGZvdW5kIiwidHIiLCJzZXRTZWxlY3Rpb24iLCJldmVudCIsImVkaXRhYmxlIiwiY2xpY2tQb3MiLCJwb3NBdENvb3JkcyIsImxlZnQiLCJjbGllbnRYIiwidG9wIiwiY2xpZW50WSIsIm5vZGVBdCIsImlucHV0VHlwZSIsImluc2VydCIsImZpbmRXcmFwcGluZyIsInNjaGVtYSIsIm5vZGVzIiwidGV4dCIsImZyYWciLCJpIiwibGVuZ3RoIiwiZnJvbSIsImNyZWF0ZUFuZEZpbGwiLCJyZXBsYWNlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwiY3JlYXRlIiwid2lkZ2V0Iiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-gapcursor/dist/index.js\n");

/***/ })

};
;